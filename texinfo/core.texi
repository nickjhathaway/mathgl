@c ------------------------------------------------------------------
@node MathGL core, Plotter classes, Examples, Top
@chapter MathGL core
@cindex mglGraph

The core of MathGL is @strong{mglGraph} class defined in @code{#include <mgl/mgl.h>}. It contains a lot of plotting functions for 1D, 2D and 3D plots. It also encapsulates parameters for axes drawing. Moreover an arbitrary coordinate transformation may be used for each axis. All plotting functions use data encapsulated in mglData class (@pxref{mglData class}) that allows to check sizes of used arrays easily. Also it have many functions for data handling: modify it by formulas, find momentums and distribution (histogram), apply operator (differentiate, integrate, transpose, Fourier and so on), change data sizes (interpolate, squeeze, crop and so on). Additional information about colors, fonts, formula parsing can be found in @ref{Other classes}.

Note that class mglGraph is abstract and contains only interface functions for plotting but does not make plot by itself. For plotting in specific device (screen, memory or file) one should use derived classes: mglGraphZB -- for bitmap picture in file or in memory; mglGraphPS -- for vector PostScript picture; mglGraphGL -- for drawing using OpenGL, or for GLUT windows interface; and so on, @pxref{Plotter classes}. If you want not only to create a picture but to view it in a window/widget or to run animation and so on then look at @ref{Widget classes}.

@menu
* Graphics setup::              
* Axis settings::               
* Transformation matrix::       
* Export to file::              
* Primitives drawing::          
* Text printing::               
* Axis and Colorbar::           
* Legend::                      
* 1D plotting::                 
* 2D plotting::                 
* 3D plotting::                 
* Dual plotting::               
* Vector fields::               
* Other plotting::              
* Nonlinear fitting::           
* Frames/Animation::            
* IDTF functions::              
@end menu

@c ##################################################################
@node Graphics setup, Transformation matrix, , MathGL core
@section Graphics setup
@cindex MathGL setup

Functions and variables in this group influences on overall graphics appearance. So all of them should be placed @emph{before} any actual plotting function calls.

@deftypemethod mglGraph @code{void} DefaultPlotParam ()
Restore initial values for all of parameters except described in @ref{Zooming}.
@end deftypemethod

@menu
* Transparency::                
* Lighting::                    
* Fog::                         
* Default sizes::               
* Zooming::                     
* Cutting::                     
* Font settings::               
* Palette and colors::          
* Error handling::              
* Other settings::              
@end menu

@c ==================================================================
@node Transparency, Lighting, , Graphics setup
@subsection Transparency
@cindex Alpha
@cindex AlphaDef
@cindex Transparent
@cindex TranspType

There are several functions and variables for setup transparency. The general function is @code{Alpha()} which switch on/off the transparency for overall plot. It influence only for graphics which created after @code{Alpha()} call (with one exception, mglGraphGL). Variable @code{AlphaDef} specify the default value of alpha-channel. You may switch off transparency of selected plot by variable @code{Transparent}. Finally, variable @code{TranspType} set the kind of transparency. @sref{Transparent surface sample}

@deftypemethod mglGraph @code{bool} Alpha (@code{bool} enable)
Sets the transparency on/off. It is recommended to call this function before any plotting command. Function returns previous value of transparency. In any case it must be called before  @code{Finish()} function if the last is used. Default value is transparency off. Unfortunately it switches the transparency on/off for all subplots. Use @code{Transparent = false} in particular plot to disable its transparency.
@end deftypemethod

@deftypecv {General option} mglGraph @code{float} AlphaDef
Default value of alpha channel (transparency) for all plotting functions. Note, that OpenGL (mglGraphGL) has incorrect drawing for large values of alpha in case of several overlapping surfaces.
@end deftypecv

@deftypecv {General option} mglGraph @code{bool} Transparent
Flag which temporary switches transparency on/off for the plot.
@end deftypecv

@deftypecv {General option} mglGraph @code{int} TranspType
This variable set the transparency type. Normal transparency (@samp{0}) -- below things is less visible than upper ones. It does not look well in OpenGL mode (mglGraphGL) for several surfaces. Glass-like transparency (@samp{1}) -- below and upper things are commutable and just decrease intensity of light by RGB channel. Lamp-like transparency (@samp{2}) -- below and upper things are commutable and are the source of some additional light. I recommend to set @code{AlphaDef = 0.3} or less for lamp-like transparency.
@end deftypecv

@c ==================================================================
@node Lighting, Fog, Transparency, Graphics setup
@subsection Lighting
@cindex Light
@cindex Ambient

There are several functions for setup lighting. The general function is @code{Light(bool)} which switch on/off the lighting for overall plot. It influence only for graphics which created after @code{Light()} call (with one exception, mglGraphGL). Generally MathGL support up to 10 independent light sources. But in OpenGL mode only 8 of light sources is used due to OpenGL limitations. The position, color, brightness of each light source can be set separately. By default only one light source is active. It is source number @code{0} with white color, located at top of the plot.

@deftypemethod mglGraph @code{bool} Light (@code{bool} enable)
Sets the using of light on/off for overall plot. It is recommended to call this function before any plotting command. Function returns previous value of lighting. Default value is lightning off.
@end deftypemethod

@deftypemethod mglGraph @code{void} Light (@code{int} n, @code{bool} enable)
Switch on/off @var{n}-th light source separately.
@end deftypemethod

@deftypemethod mglGraph @code{void} Light (@code{int} n, @code{mglPoint} p, @code{mglColor} c, @code{float} bright=@code{0.5}, @code{bool} infty=@code{true})
@deftypemethodx mglGraph @code{void} Light (@code{int} n, @code{mglPoint} p, @code{char} c=@code{'w'}, @code{float} bright=@code{0.5}, @code{bool} infty=@code{true})
The function adds a light source with identification @var{n} at position @var{p}. The color of light is @var{c} (white by default). The brightness of light is @var{bright} which must be in range [0,1]. Flag @var{infty}=@code{true} puts the source to infinite distance (for the faster drawing). It is recommended to call this function before any plotting command.
@end deftypemethod

@deftypemethod mglGraph @code{void} Ambient (@code{float} bright=@code{0.5})
Sets the brightness of ambient light. The value should be in range [0,1]. It is recommended to call this function before any plotting command.
@end deftypemethod

@c ==================================================================
@node Fog, Default sizes, Lighting, Graphics setup
@subsection Fog
@cindex Fog

@deftypemethod mglGraph @code{void} Fog (@code{float} d, @code{float} dz=@code{0.25})
Function imitate a fog in the plot. Fog start from relative distance @var{dz} from view point and its density growths exponentially in depth. So that the fog influence is determined by law ~ 1-exp(-@emph{d*z}). Here @emph{z} is normalized to 1 depth of the plot. If value @var{d}=@code{0} then the fog is absent. @sref{Surface in fog sample}
@end deftypemethod

@c ==================================================================
@node Default sizes, Zooming, Fog, Graphics setup
@subsection Default sizes
@cindex BarWidth
@cindex MarkSize
@cindex ArrowSize
@cindex BaseLineWidth
@cindex TickLen

These variables control the default (initial) values for most graphics parameters including sizes of markers, arrows, linewidth and so on. As any other settings these ones will influence only on plots created after the settings change.

@deftypecv {General option} mglGraph @code{float} BarWidth
Relative width of rectangles in Bars plot (@pxref{Bars}). Default value is @code{0.7}.
@end deftypecv

@deftypecv {General option} mglGraph @code{float} MarkSize
The size of marks for @ref{1D plotting}. Default value is @code{0.02}.
@end deftypecv

@deftypecv {General option} mglGraph @code{float} ArrowSize
The size of arrows for @ref{1D plotting}, lines and curves (@pxref{Primitives drawing}). Default value is @code{0.03}.
@end deftypecv

@deftypecv {General option} mglGraph @code{float} BaseLineWidth
The variable define the base width for all lines. The value <1 is ignored. For values > 1 the real line width is result of multiplication of specified line width and the value of @var{BaseLineWidth}. Increase of this variables is actual for large bitmap pictures. Default value is @code{1}.
@end deftypecv

@deftypecv {General option} mglGraph @code{float} TickLen
The relative length of axis ticks. Default value is @code{0.1}. Note that subticks are @math{\sqrt@{2@}=1.41...} times smaller.
@end deftypecv

@c ==================================================================
@node Zooming, Cutting, Default sizes, Graphics setup
@subsection Zooming
@cindex PlotFactor
@cindex AutoPlotFactor
@cindex Zoom

These variables and functions control the overall zooming of the picture (see Zoom()) or the sub-picture (see PlotFactor). Normally you can use these variables and functions for removing ``white'' spaces around a plot.

@deftypecv {General option} mglGraph @code{float} PlotFactor
The factor of plot size. It is not recommended to set it lower then 1.6. This is some analogue of function Zoom() but applied not to overall image but for each InPlot (@pxref{Transformation matrix}).
@end deftypecv

@deftypecv {General option} mglGraph @code{bool} AutoPlotFactor
Switch on/off automatic change of PlotFactor variable during plot rotation.
@end deftypecv

@deftypemethod mglGraph @code{void} Zoom (@code{float} x1, @code{float} y1, @code{float} x2, @code{float} y2)
The function changes the scale of graphics that correspond to zoom in/out of the picture. After function call the current plot will be cleared and further the picture will contain plotting from its part [x1,x2]*[y1,y2]. Here picture coordinates @var{x1}, @var{x2}, @var{y1}, @var{y2} changes from 0 to 1. Attention! this settings can not be overwritten by any other functions. Use @code{Zoom(0,0,1,1)} to return default view.
@end deftypemethod

@c ==================================================================
@node Cutting, Font settings, Zooming, Graphics setup
@subsection Cutting
@cindex Cut
@cindex CutMin
@cindex CutMax
@cindex fc
@cindex CutOff

These variables and functions set the condition when the points are excluded (cutted) from the drawing.

@deftypecv {General option} mglGraph @code{bool} Cut
Flag which determines how points outside bounding box are drawn. If it is @code{true} then points are excluded from plot (it is default) otherwise the points are projected to edges of bounding box.
@end deftypecv

@float
@image{png_static/cut, 7cm}
@caption{Left figure is drawn with parameter @code{Cut=false}. Right one is drawn with parameter @code{Cut=true}}
@end float

@deftypecv {General option} mglGraph @code{mglPoint} {CutMin, CutMax}
Lower and upper edge of the box in which never points are drawn. If both edges are the same (the variables are equal) then the cutting box is empty. @sref{CutMinMax sample}
@end deftypecv

@deftypecv {General option} mglGraph @code{mglFormula *} fc
Formula for condition of point cutting. The point will be omitted (``cut'') if function return non-zero value for point coordinates. This variable is obsolete -- use CutOff() function instead.
@end deftypecv

@deftypemethod mglGraph @code{void} CutOff (@code{const char *}EqC)
Sets the cutting off condition by formula @var{EqC}. This condition determine will point be plotted or not. If value of formula is nonzero then point is omitted, otherwise it plotted. Set argument as @code{NULL} to disable cutting off condition. @sref{CutOff sample}
@end deftypemethod


@c ==================================================================
@node Font settings, Palette and colors, Cutting, Graphics setup
@subsection Font settings
@cindex FontSize
@cindex FontDef
@cindex RotatedText
@cindex SetFontSizePT
@cindex SetFontSizeCM
@cindex SetFontSizeIN
@cindex SetFont
@cindex GetFont

@deftypecv {General option} mglGraph @code{float} FontSize
The size of font for tick and axis labels. Default font size of axis labels is 1.4 times large than for tick labels.
@end deftypecv

@deftypecv {General option} mglGraph @code{char} FontDef@code{[32]}
Font specification (@pxref{Text printing}). Default is ``rC'' -- Roman font centering.
@end deftypecv

@deftypecv {General option} mglGraph @code{bool} RotatedText
Set to use or not text rotation along axis.
@end deftypecv

@deftypemethod mglGraph @code{void} SetFontSizePT (@code{float} cm, @code{int} dpi=@code{72})
Set FontSize by size in pt and picture DPI (default is 16 pt for dpi=72).
@end deftypemethod

@deftypemethod mglGraph @code{inline void} SetFontSizeCM (@code{float} cm, @code{int} dpi=@code{72})
Set FontSize by size in centimeters and picture DPI (default is 0.56 cm = 16 pt).
@end deftypemethod

@deftypemethod mglGraph @code{inline void} SetFontSizeIN (@code{float} cm, @code{int} dpi=@code{72})
Set FontSize by size in inch and picture DPI (default is 0.22 in = 16 pt).
@end deftypemethod

@deftypemethod mglGraph @code{void} SetFont (@code{mglFont *}f)
Sets font typeface. Note that each mglFont instance can be used with ONLY ONE mglGraph instance at a moment of time! If @code{f==NULL} then default font is used.
@end deftypemethod

@deftypemethod mglGraph @code{inline mglFont *}GetFont ()
Gets current typeface. Note that this variable can be deleted at next SetFont() call!
@end deftypemethod

@c ==================================================================
@node Palette and colors, Error handling, Font settings, Graphics setup
@subsection Pallete and colors
@cindex Pal
@cindex NumPal
@cindex SetPalette
@cindex SetScheme
@cindex SelectPen

@deftypemethod mglGraph @code{void} SetPalette (@code{const char *}@var{colors})
Sets the palette as selected colors. Default value is @code{"Hbgrcmyhlnqeup"} that corresponds to colors: dark gray @samp{H}, blue @samp{b}, green @samp{g}, red @samp{r}, cyan @samp{c}, magenta @samp{m}, yellow @samp{y}, gray @samp{h}, blue-green @samp{l}, sky-blue @samp{n}, orange @samp{q}, yellow-green @samp{e}, blue-violet @samp{u}, purple @samp{p}. The palette is used mostly in 1D plots (@pxref{1D plotting}) for curves which styles are not specified.
@end deftypemethod

@deftypecv {General option} mglGraph @code{mglColor} Pal@code{[101]}
Color palette for @ref{1D plotting}. This variable is obsolete -- use SetPalette() function instead.
@end deftypecv

@deftypecv {General option} mglGraph @code{int} NumPal
Number of actual colors in palette. The value must be less then 100. This variable is obsolete -- use SetPalette() function instead.
@end deftypecv

@deftypemethod mglGraph @code{void} SetScheme (@code{const char *}sch)
Set the color scheme for following plots. Usually this function is used internally. @xref{Color scheme}.
@end deftypemethod

@deftypemethod mglGraph @code{void} SelectPen (@code{const char *}sch)
Set the line and mark styles for following plots. Usually this function is used internally. @xref{Line styles}.
@end deftypemethod


@c ==================================================================
@node Error handling, Other settings, Palette and colors, Graphics setup
@subsection Error handling

@cindex Message
@cindex WarnCode
@cindex SetWarn

There are 2 variables which indicate the warnings/errors presence during plot creation. Normally user should set it to zero by @code{SetWarn(0);} before plotting and check if @var{WarnCode} is not zero after plotting. Note that only last warning will be saved.

@deftypecv {General option} mglGraph @code{char *} Message
Pointer to buffer for writing messages about matters why some plot are not drawn. Set to NULL to disable messages. The buffer length must be at least 1024. If Message[0]==0 then there are no messages
@end deftypecv

@deftypecv {General option} mglGraph @code{int} WarnCode
Numerical ID of warning about the not drawn plot. Possible values are:
@table @code
@item mglWarnNone=0
Everything OK
@item mglWarnDim
Data dimension(s) is incompatible
@item mglWarnLow
Data dimension(s) is too small
@item mglWarnNeg
Minimal data value is negative
@item mglWarnFile
No file or wrong data dimensions
@item mglWarnMem
Not enough memory
@item mglWarnZero
Data values are zero
@item mglWarnLegA
Too many legend entries
@item mglWarnLeg
No legend entries
@item mglWarnSlc
Slice value is out of range
@item mglWarnCnt
Number of contours is zero or negative
@item mglWarnOpen
Couldn't open file
@item mglWarnLId
Light: ID is out of range
@item mglWarnSize
Setsize: size(s) is zero or negative
@item mglWarnFmt
Format is not supported for that build
@item mglWarnEnd
Maximal number of warnings (must be last)
@end table
@end deftypecv

@deftypemethod mglGraph @code{void} SetWarn (@code{int} code, @code{const char *}who=@code{""})
Set warning code and corresponding message from function @var{who}. Normally you should call this function only for clearing the warning state, i.e. call @code{SetWarn(0);}.
@end deftypemethod

@c ==================================================================
@node Other settings, , Error handling, Graphics setup
@subsection Other settings

@deftypecv {General option} mglGraph @code{int} MeshNum
Sets approximate number of lines in Mesh(), Fall(), Grid() and also the number of hachures in Vect(), VectC(), Dew() and the number of cells in Cloud*(). By default (=0) it draws all lines/hachures/cells.
@end deftypecv

@deftypecv {General option} mglGraph @code{char} AxialDir
Set direction around which curve rotated in Axial() and Torus(). Default value is 'z'.
@end deftypecv

@deftypecv {General option} mglGraph @code{bool} DrawFace
If set to @code{true} then it prevent faces drawing. It is useful for speeding up drawing (for example, during rotation and so on).
@end deftypecv

@deftypecv {General option} mglGraph @code{int} CirclePnts
Number of points used for a circle approximation (for example, in @ref{Primitives drawing}, @ref{Tube}, @ref{Pipe} and so on). Default value is 40.
@end deftypecv

@deftypecv {General option} mglGraph @code{const char *} PlotId
Id of plot for saving filename (in GLUT window for example).
@end deftypecv

@c ==================================================================
@node Axis settings, Transformation matrix, Graphics setup, MathGL core
@section Axis settings

These large set of variables and functions control how the axis and ticks will be drawn. Note that there is 3-step transformation of data coordinates are performed. Firstly, coordinates are projected if @code{Cut=true} (@pxref{Cutting}), after it transformation formulas are applied, and finally the data was normalized in bounding box.

@menu
* Ranges (bounding box)::       
* Transformation::              
* Ticks::                       
@end menu

@c ------------------------------------------------------------------
@node Ranges (bounding box), Transformation, , Axis settings
@subsection Ranges (bounding box)
@cindex Axis
@cindex CAxis
@cindex XRange
@cindex YRange
@cindex ZRange
@cindex Min
@cindex Max
@cindex Cmin
@cindex Cmax
@cindex RecalcBorder
@cindex Org
@cindex AutoOrg
@cindex SetRanges
@cindex SetAutoRanges

@deftypemethod mglGraph @code{void} Axis (@code{mglPoint} min, @code{mglPoint} max, @code{mglPoint} org=@code{mglPoint(NAN,NAN,NAN)})
Safely sets the value for @var{Min}, @var{Max} and @var{Org} members (options) of the class. If minimal and maximal values of the coordinate are the same then they are ignored. This function also sets @var{Cmin}=@code{Min.z} and @var{Cmax}=@code{Max.z}. This is default color range for 2d plots.
@end deftypemethod

@deftypemethod {mglGraph} @code{void} SetRanges (@code{float} x1, @code{float} x2, @code{float} y1, @code{float} y2, @code{float} z1=@code{0}, @code{float} z2=@code{0})
Sets maximal and minimal values for coordinate range (bounding box). If minimal and maximal values of the coordinate are the same then they are ignored. This function also sets @var{Cmin}=@code{Min.z} and @var{Cmax}=@code{Max.z}. This is default color range for 2d plots.
@end deftypemethod

@deftypemethod mglGraph @code{void} CAxis (@code{float} min, @code{float} max)
Safely sets the values of @var{Cmin} and @var{Cmax}. This values are used later for determining the color of the surface.
@end deftypemethod

@deftypemethod mglGraph @code{void} XRange (@code{const mglData &} dat, @code{bool} add=@code{false}, @code{float} fact=@code{0})
Sets values of @code{Min.x} and @code{Max.x} as minimal and maximal values of data @var{a}. Parameter @var{fact} add additional range increase on value (@var{Max}-@var{Min})*@var{fact}. See also Axis().
@end deftypemethod

@deftypemethod mglGraph @code{void} YRange (@code{const mglData &} dat, @code{bool} add=@code{false}, @code{float} fact=@code{0})
Sets values of @code{Min.y} and @code{Max.y} as minimal and maximal values of data @var{a}. Parameter @var{fact} add additional range increase on value (@var{Max}-@var{Min})*@var{fact}. See also Axis().
@end deftypemethod

@deftypemethod mglGraph @code{void} ZRange (@code{const mglData &} dat, @code{bool} add=@code{false}, @code{float} fact=@code{0})
Sets values of @code{Min.z} and @code{Max.z} as minimal and maximal values of data @var{a}. Parameter @var{fact} add additional range increase on value (@var{Max}-@var{Min})*@var{fact}. See also Axis().
@end deftypemethod

@deftypemethod mglGraph @code{void} CRange (@code{const mglData &} dat, @code{bool} add=@code{false}, @code{float} fact=@code{0})
Sets values of @code{Cmin} and @code{Cmax} as minimal and maximal values of data @var{a}. Parameter @var{fact} add additional range increase on value (@var{Cmax}-@var{Cmin})*@var{fact}. See also CAxis().
@end deftypemethod

@deftypemethod mglGraph @code{void} RecalcBorder ()
Recalculates internal parameter for correct apply of transformation rules. @strong{Must be called} after any direct change of members @var{Min}, @var{Max}, @var{fx}, @var{fy}, @var{fz} if its changes should be seen on the plot.
@end deftypemethod

@deftypemethod mglGraph @code{void} SetAutoRanges (@code{float} x1, @code{float} x2, @code{float} y1=@code{0}, @code{float} y2=@code{0}, @code{float} z1=@code{0}, @code{float} z2=@code{0})
Sets ranges for automatic variables of plots. It act as changing of @var{Min}, @var{Max} proprties without calling of RecalcBorder(). Function don't change the direction if minimal and maximal values are the same. For example, if y@var{y1}=@var{y2} then ranges along y-direction will not be changed (will be used previous one). Note that the automatic range become axis range after next call of [XYZ]Range() function(s).
@end deftypemethod

@deftypecv {General option} mglGraph @code{mglPoint} {Min, Max}
Lower and upper edges of bounding box for graphics. These variables are used for determining the range of automatic (non-specified) arrays in most of plotting functions. So, you may change it before plot and return it back after it and the plot will have automatic x-(y-,z-)coordinate normalized in this range but not in bounding box. @strong{BUT} if you want to change the bounding box then you @strong{must} call @code{RecalcBorder();} after it or use Axis() function.
@end deftypecv

@deftypecv {General option} mglGraph @code{float} {Cmin, Cmax}
Minimal and maximal value for data (used for coloring).
@end deftypecv

@deftypecv {General option} mglGraph @code{mglPoint} Org
Center of axis cross section. If one of values is NAN then MathGL library try to select optimal axis position.
@end deftypecv

@deftypecv {General option} mglGraph @code{bool} AutoOrg
Flag for automatic shifting of axes origin @var{Org} if it lies out of range @var{Min} ... @var{Max}.
@end deftypecv


@c ------------------------------------------------------------------
@node Transformation, Ticks, Ranges (bounding box), Axis settings
@subsection Transformation (curved coordinates)
@cindex Axis
@cindex Ternary
@cindex fx
@cindex fy
@cindex fz

@deftypemethod mglGraph @code{void} Axis (@code{const char *}EqX, @code{const char *}EqY, @code{const char *}EqZ)
Safely sets the transformation formulas for curvilinear coordinate. Each string should contain mathematical expression for real coordinate depending on internal coordinates x, y, z. For example, the cylindrical coordinates are introduced as @code{Axis("x*cos(y)", "x*sin(y)", "z");}. For removing of formulas the corresponding parameter should be @code{NULL}. Using transformation formulas will slightly slowing the program, i.e. @code{Axis(NULL, NULL, NULL)} is faster than @code{Axis("x", "y", "z")}. @xref{mglFormula class}.
@end deftypemethod

@deftypemethod mglGraph @code{void} Ternary (@code{bool} tern)
The function sets to draws Ternary plot. This special plot is for 3 dependent coordinates (components) @var{a}, @var{b}, @var{c} so that @var{a}+@var{b}+@var{c}=1. MathGL uses only 2 independent coordinates @var{a}=x and @var{b}=y since it is enough to plot everything. At this third coordinate z act as another parameter to produce contour lines, surfaces and so on. @sref{Ternary plot sample}
@end deftypemethod

@deftypecv {General option} mglGraph @code{mglFormula} {*fx, *fy, *fz}
Transformation formula for x, y and z directions. These variables are obsolete -- use Axis() function instead.
@end deftypecv

@c ------------------------------------------------------------------
@node Ticks, , Transformation, Axis settings
@subsection Ticks

@cindex SetTicks
@cindex SetTicksVal
@cindex dx
@cindex dy
@cindex dx
@cindex NSx
@cindex NSy
@cindex NSz
@cindex xtt
@cindex ytt
@cindex ztt
@cindex ctt
@cindex OrgT
@cindex FactorPos
@cindex TuneTicks
@cindex AdjustTicks

@deftypemethod {mglGraph} @code{void} AdjustTicks (@code{const char *}dir)
Set the ticks step, number of sub-ticks and initial ticks position to be the most human readable for the axis along direction(s) @var{dir}. Also set @var{TuneTicks}=@code{true}.
@end deftypemethod

@deftypemethod mglGraph @code{void} SetTicks (@code{char} dir, @code{float} d=@code{-5}, @code{int} ns=@code{0}, @code{float} org=@code{NAN})
Set the ticks step @var{d}, number of sub-ticks @var{ns} and initial ticks position @var{org} for the axis along direction @var{dir}. Variable @var{d} set step for axis ticks (if positive) or it's number on the axis range (if negative). Zero value set logarithmic ticks. If @var{org} value is NAN then value from @var{Org} is used.
@end deftypemethod

@deftypemethod mglGraph @code{void} SetTicksVal (@code{char} dir, @code{int} n, @code{float *}val, @code{const char **}lbl)
@deftypemethodx mglGraph @code{void} SetTicksVal (@code{char} dir, @code{int} n, @code{float *}val, @code{const wchar_t **}lbl)
@deftypemethodx mglGraph @code{void} SetTicksVal (@code{char} dir, @code{float} val1, @code{wchar_t *}lbl1, ...)
Set the manual positions @var{val} and its labels @var{lbl} for @var{n}-th ticks along axis @var{dir}. The arrays @var{val} and @var{lbl} must contain @var{n} elements. Use @code{SetTicks()} to restore automatic ticks. Note, you @strong{have to be} very careful to use floating-point (not integer!!!) values as ticks position due to limitations of stdarg library (argument transfer). @sref{Manual ticks sample}
@end deftypemethod

@deftypecv {General option} mglGraph @code{float} {dx, dy, dz}
Step for axis ticks (if positive) or it's number (if negative) in x-,y-,z- directions. Zero value set logarithmic ticks. These variables are obsolete -- use SetTicks() function instead.
@end deftypecv

@deftypecv {General option} mglGraph @code{int} {NSx, NSy, NSz}
Number of axis sub-ticks in x-,y-,z- directions. These variables are obsolete -- use SetTicks() function instead.
@end deftypecv

@deftypecv {General option} mglGraph @code{mglPoint} OrgT
Starting point for ticks. If corresponding value is NAN then value from @var{Org} is used (it is default).
@end deftypecv

@deftypecv {General option} mglGraph @code{const wchar_t} {*xtt, *ytt, *ztt, *ctt}
The template for x-,y-,z-axis ticks or colorbar ticks. It may contain TeX symbols also. If @var{xtt}, @var{ytt}, @var{ztt}, @var{ctt}=@code{NULL} then default template is used (in simplest case it is @samp{%.2g}) with automatic detaching of common multiplier or common component (see @var{TuneTicks}).
@end deftypecv

@deftypecv {General option} mglGraph @code{bool} TuneTicks
Switch on/off ticks enhancing by factoring common multiplier (for small, like from 0.001 to 0.002, or large, like from 1000 to 2000, coordinate values) or common component (for narrow range, like from 0.999 to 1.000).
@end deftypecv

@deftypecv {General option} mglGraph @code{float} FactorPos
The position of common multiplier/component on the axis: =0 at minimal axis value, =1 at maximal axis value. Default value is 1.15.
@end deftypecv


@c ##################################################################
@node Transformation matrix, Export to file, Axis settings, MathGL core
@section Transformation matrix
@cindex Aspect
@cindex Rotate
@cindex RotateN
@cindex SubPlot
@cindex InPlot
@cindex Identity
@cindex Perspective
@cindex RestoreM
@cindex View
@cindex ColumnPlot

These functions control how and where further plotting will be placed. There is a curtain order of calling of these functions for the better plot view. First one should be SubPlot() or InPlot() for specifying the place. After it a Rotate() and Aspect(). And finally any other plotting functions may be called. Alternatevely you can use ColumnPlot() for position plots in the column one by another without gap between plot axis (bounding boxes).

@deftypemethod mglGraph @code{void} SubPlot (@code{int} nx, @code{int} ny, @code{int} m, @code{float} dx=@code{0}, @code{float} dy=@code{0})
Puts further plotting in a @var{m}-th cell of @var{nx}*@var{ny} grid of the whole frame area. This function set off any aspects or rotations. So it should be used first for creating the subplot. From the aesthetical point of view it is not recommended to use this function with different matrices in the same frame. The position of the cell can be shifted from its default position by relative size @var{dx}, @var{dy}.
@end deftypemethod

@deftypemethod mglGraph @code{void} InPlot (@code{float} x1, @code{float} x2, @code{float} y1, @code{float} y2, @code{bool} rel=@code{false})
Puts further plotting in some region of the whole frame surface. This function allows one to create a plot in arbitrary place of the screen. The position is defined by rectangular coordinates [@var{x1}, @var{x2}]*[@var{y1}, @var{y2}]. The coordinates @var{x1}, @var{x2}, @var{y1}, @var{y2} are normalized to interval [0, 1]. If parameter @var{rel}=@code{true} then the relative position to current SubPlot() (or last InPlot() with @var{rel}=@code{false}) is used. This function set off any aspects or rotations. So it should be used first for creating subplot.
@end deftypemethod

@deftypemethod mglGraph @code{void} ColumnPlot (@code{int} num, @code{int} ind)
Puts further plotting in @var{ind}-th cell of column with @var{num} cells. The position is relative to previous SubPlot() call (or InPlot() with @var{rel}=@code{false}).
@end deftypemethod

@deftypemethod mglGraph @code{void} Rotate (@code{float} TetX, @code{float} TetZ, @code{float} TetY=@code{0})
Rotates a further plotting relative to each axis (x, z, y) consecutively on angles @var{TetX}, @var{TetZ}, @var{TetY}.
@end deftypemethod

@deftypemethod mglGraph @code{void} RotateN (@code{float} Tet, @code{float} x, @code{float} y, @code{float} z)
Rotates a further plotting around vector @{x,y,z@}.
@end deftypemethod

@deftypemethod mglGraph @code{void} Aspect (@code{float} Ax, @code{float} Ay, @code{float} Az)
Defines aspect ratio for the plot. The viewable axes will be related one to another as the ratio @var{Ax:Ay:Az}. For the best effect it should be used after Rotate() function.
@end deftypemethod

@deftypemethod mglGraph @code{void} Perspective (@code{float} a)
Add (switch on) the perspective to plot. The parameter @math{a ~ 1/z_@{eff@} \in [0,1)}. By default (@code{a=0}) the perspective is off.
@end deftypemethod

@deftypemethod mglGraph @code{void} Identity ()
Clears transformation matrix. This function clears all previous effects of Aspect(), SubPlot(), InPlot() or Rotate() functions. It is equivalent to the call of  @code{InPlot(0,1,0,1)}.
@end deftypemethod

@deftypemethod mglGraph @code{void} RestoreM ()
Restore transformation matrix after last @code{InPlot()}. This function clears all previous effects of Aspect(), SubPlot(), InPlot() or Rotate() functions. It is useful to restore back the transformation matrix after @code{Identity()} call.
@end deftypemethod

@deftypemethod mglGraph @code{void} View (@code{float} tetx,  @code{float} tetz,  @code{float} tety= @code{0})
Sets angle of view independently from Rotate() but usually don't rotate actually.
@end deftypemethod


@c ##################################################################
@node Export to file, Primitives drawing, Transformation matrix, MathGL core
@section Export to file
@cindex WriteFrame
@cindex WritePNG
@cindex WriteGIF
@cindex WriteIDTF
@cindex WriteSVG
@cindex WriteBMP
@cindex WriteEPS
@cindex WriteJPEG
@cindex SetSize
@cindex Flush
@cindex Finish
@cindex ShowImage

These functions export current view to a graphic file. The filename @var{fname} should have appropriate extension. Parameter @var{descr} gives the short description of the picture. Just now the transparency is supported in PNG and SVG files.

@deftypemethod mglGraph @code{void} WriteFrame (@code{const char *}fname=@code{NULL}, @code{const char *}descr=@code{NULL})
Exports current frame to a file @var{fname} which type is determined by the extension. Parameter @var{descr} adds description to file (can be @code{NULL}). If @var{fname}=@code{NULL} then the file @samp{frame####.jpg} is used, where @samp{####} is current frame id and name @samp{frame} is defined by @var{PlotId} class property.
@end deftypemethod

@deftypemethod mglGraph @code{void} WritePNG (@code{const char *}fname, @code{const char *}descr=@code{NULL}, @code{int} compr=@code{NULL}, @code{bool} alpha=@code{true})
Exports current frame to PNG file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file, @var{alpha} gives the transparency type. By default there are no description added and transparent image used. This function does nothing if NO_PNG is defined during compilation of MathGL library.
@end deftypemethod

@deftypemethod mglGraph @code{void} WriteJPEG (@code{const char *}fname, @code{const char *}descr=@code{NULL})
Exports current frame to JPEG file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. By default there is no description added. This function does nothing if NO_JPEG is defined during compilation of MathGL library.
@end deftypemethod

@deftypemethod mglGraph @code{void} WriteGIF (@code{const char *}fname, @code{const char *}descr=@code{NULL})
Exports current frame to GIF file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. By default there is no description added.
@end deftypemethod

@deftypemethod mglGraph @code{void} WriteBMP (@code{const char *}fname, @code{const char *}descr=@code{NULL})
Exports current frame to BMP file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. There is no compression used.
@end deftypemethod

@deftypemethod mglGraph @code{void} WriteEPS (@code{const char *}fname, @code{const char *}descr=@code{NULL})
Exports current frame to EPS file. The vector representation is used if possible. So it is not recommended for the export of large data plot. It is better to use bitmap format (for example PNG or JPEG). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. By default there is no description added.
@end deftypemethod

@deftypemethod mglGraph @code{void} WriteSVG (@code{const char *}fname, @code{const char *}descr=@code{NULL})
Exports current frame to SVG (Scalable Vector Graphics) file. The vector representation is used. In difference of EPS format, SVG format support transparency that allows to correctly draw half-transparent plot (like SurfA(), Surf3A(), CloudQ() or CloudP()). Note, the output file may be too large for graphic of large data array (especially for surfaces). It is better to use bitmap format (for example PNG or JPEG). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name).
@end deftypemethod

@deftypemethod mglGraph @code{void} WriteIDTF (@code{const char *}fname, @code{const char *}descr=@code{NULL})
Exports current frame to IDTF file. Later this file can be converted to U3D format. The vector representation is used. So, the output file may be too large for graphic of large data array (especially for surfaces). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name).
@end deftypemethod

@deftypemethod mglGraph @code{void} ShowImage (@code{const char *}viewer=@code{"kuickshow"}, @code{bool} nowait=@code{false})
Displays the current picture using external program @var{viewer} for viewing. The function save the picture to temporary file and call @var{viewer} to display it. If @var{nowait}=@code{true} then the function return immediately (it will not wait while window will be closed).
@end deftypemethod

@deftypemethod mglGraph @code{void} SetSize (@code{int} width, @code{int} height)
Sets size of picture in pixels. This function @strong{must be} called before any other plotting because it completely remove picture contents.
@end deftypemethod

@deftypemethod mglGraph @code{void} Finish ()
Finishes plotting and create a picture. Normally this function is called internally.
@end deftypemethod

@deftypemethod mglGraph @code{void} Flush ()
Flushes the plotting commands to frame. This function may be useful if one wants to remove array before the finishing of the plot (i.e. before calling @code{Finish()}). Also call of this function separate the objects in mglGraphIDTF. Most of plots call this function internally.
@end deftypemethod


@c ##################################################################
@node Primitives drawing, Text printing, Export to file, MathGL core
@section Primitives drawing
@cindex Ball
@cindex Clf
@cindex Line
@cindex Curve
@cindex Glyph
@cindex Mark
@cindex Error
@cindex Face
@cindex FaceX
@cindex FaceY
@cindex FaceZ
@cindex Cone
@cindex Drop
@cindex Sphere

These functions draw some simple objects like line, point, sphere, drop, cone and so on.

@deftypemethod mglGraph @code{void} Clf (@code{mglColor} Back=@code{WC})
Clear the picture and will it by color @var{Back}.
@end deftypemethod

@deftypemethod mglGraph @code{void} Ball (@code{float} x, @code{float} y, @code{float} z, @code{mglColor} col=@code{RC}, @code{float} alpha=@code{1})
Draws a point (ball) at position @{@var{x}, @var{y}, @var{z}@} with color @var{col}.
@end deftypemethod

@deftypemethod mglGraph @code{void} Ball (@code{mglPoint} p, @code{char} col=@code{'r'})
Draws a point (ball) at position @var{p} with color @var{col}.
@end deftypemethod

@deftypemethod mglGraph @code{void} Error (@code{mglPoint} p, @code{mglPoint} e, @code{char} *pen=@code{NULL})
Draws a 3d error box at position @var{p} with sizes @var{e} and style @var{pen}.
@end deftypemethod

@deftypemethod mglGraph @code{void} Line (@code{mglPoint} p1, @code{mglPoint} p2, @code{char *}stl=@code{"B"}, @code{int}num=@code{2})
Draws a geodesic line (straight line in Cartesian coordinates) from point @var{p1} to @var{p2} using line style @var{stl}. Parameter @var{num} define the ``quality'' of the line. If @var{num}=@code{2} then the stright line will be drawn in all coordinate system (independently on transformation formulas (@pxref{Transformation}). Contrary, for large values (for example, =@code{100}) the geodesic line will be drawn in corresponding coordinate system (straight line in Cartesian coordinates, circle in polar coordinates and so on). Line will be drawn even if it lies out of bounding box.
@end deftypemethod

@deftypemethod mglGraph @code{void} Curve (@code{mglPoint} p1, @code{mglPoint} d1, @code{mglPoint} p2, @code{mglPoint} d2, @code{const char *}stl=@code{"B"}, @code{int} num=@code{100})
Draws Bezier-like curve from point @var{p1} to @var{p2} using line style @var{stl}. At this tangent is codirected with @var{d1}, @var{d2} and proportional to its amplitude. Parameter @var{num} define the ``quality'' of the curve. If @var{num}=@code{2} then the straight line will be drawn in all coordinate system (independently on transformation formulas (@pxref{Transformation}). Contrary, for large values (for example, =@code{100}) the spline like Bezier curve will be drawn in corresponding coordinate system. Curve will be drawn even if it lies out of bounding box.
@end deftypemethod

@deftypemethod mglGraph @code{void} Face (@code{mglPoint} p1, @code{mglPoint} p2, @code{mglPoint} p3, @code{mglPoint} p4, @code{const char *}stl=@code{"w"}, @code{int} num=@code{2})
Draws the solid quadrangle (face) with vertexes @var{p1}, @var{p2}, @var{p3}, @var{p4} and with color(s) @var{stl}. At this colors can be the same for all vertexes or different if all 4 colors are specified for each vertex. Face will be drawn even if it lies out of bounding box.
@end deftypemethod

@deftypemethod mglGraph @code{void} FaceX (@code{float} x0, @code{float} y0, @code{float} z0, @code{float} wy, @code{float} wz, @code{const char *}stl=@code{"w"}, @code{float} dx=@code{0}, @code{float} dy=@code{0})
Draws the solid rectangle (face) perpendicular to x-axis at position @{@var{x0}, @var{y0}, @var{z0}@} with widths @var{wy}, @var{wz} and with color @var{stl}. At this colors can be the same for all vertexes or different if all 4 colors are specified for each vertex. Parameters @var{d1}, @var{d2} set additional shift of the last vertex (i.e. to draw quadrangle). Face will be drawn even if it lies out of bounding box.
@end deftypemethod

@deftypemethod mglGraph @code{void} FaceY (@code{float} x0, @code{float} y0, @code{float} z0, @code{float} wx, @code{float} wz, @code{const char *}stl=@code{"w"}, @code{float} dx=@code{0}, @code{float} dy=@code{0})
Draws the solid rectangle (face) perpendicular to y-axis at position @{@var{x0}, @var{y0}, @var{z0}@} with widths @var{wx}, @var{wz} and with color @var{stl}. At this colors can be the same for all vertexes or different if all 4 colors are specified for each vertex. Parameters @var{d1}, @var{d2} set additional shift of the last vertex (i.e. to draw quadrangle). Face will be drawn even if it lies out of bounding box.
@end deftypemethod

@deftypemethod mglGraph @code{void} FaceZ (@code{float} x0, @code{float} y0, @code{float} z0, @code{float} wx, @code{float} wy, @code{const char *}stl=@code{"w"}, @code{float} dx=@code{0}, @code{float} dy=@code{0})
Draws the solid rectangle (face) perpendicular to z-axis at position @{@var{x0}, @var{y0}, @var{z0}@} with widths @var{wx}, @var{wy} and with color @var{stl}. At this colors can be the same for all vertexes or different if all 4 colors are specified for each vertex. Parameters @var{d1}, @var{d2} set additional shift of the last vertex (i.e. to draw quadrangle). Face will be drawn even if it lies out of bounding box.
@end deftypemethod

@deftypemethod mglGraph @code{void} Sphere (@code{mglPoint} p, @code{float} r, @code{const char *}stl=@code{"r"})
Draw the sphere with radius @var{r} and center at point @var{p} and color @var{stl}.
@end deftypemethod

@deftypemethod mglGraph @code{void} Drop (@code{mglPoint} p, @code{mglPoint} q, @code{float} r, @code{mglColor} col, @code{float} shift=@code{1}, @code{float} ap=@code{1})
@deftypemethodx mglGraph @code{void} Drop (@code{mglPoint} p, @code{mglPoint} q, @code{float} r, @code{const char *}col="r", @code{float} shift=@code{1}, @code{float} ap=@code{1})
Draw the drop with radius @var{r} at point @var{p} elongated in direction @var{q} and with color @var{col}. Parameter @var{shift} set the degree of drop oblongness: @samp{0} is sphere, @samp{1} is maximally oblongness drop. Parameter @var{ap} set relative width of the drop (this is analogue of ``ellipticity'' for the sphere). @sref{Drops sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} Cone (@code{mglPoint} p1, @code{mglPoint} p2, @code{float} r1, @code{float} r2=@code{-1}, @code{const char *}stl=@code{"B"}, @code{bool} edge=@code{false})
Draw tube (or truncated cone if @var{edge}=@code{false}) between points @var{p1}, @var{p2} with radius at the edges @var{r1}, @var{r2}. If @var{r2}<0 then it is supposed that @var{r2}=@var{r1}. The cone color is defined by string @var{stl}.
@end deftypemethod

@deftypemethod mglGraph @code{void} Mark (@code{mglPoint} p, @code{char} mark=@code{'.'})
Draws a marks of different type at position @var{p}.
@end deftypemethod

@deftypemethod mglGraph @code{void} Glyph (@code{float} x, @code{float} y, @code{float} f, @code{int} nt, @code{const short *}trig, @code{int} nl, @code{const short *}line)
Draw a set of triangles (or lines if @var{trig}=@code{NULL}) for glyph which is placed at point @{@var{x}, @var{y}@}. Values in the arrays are normalized by factor @var{f}. Normally this function is used internally.
@end deftypemethod

@c ##################################################################
@node Text printing, Axis and Colorbar, Primitives drawing, MathGL core
@section Text printing
@cindex Puts
@cindex Putsw
@cindex Text
@cindex Title

These functions draw the text. There are functions for drawing text in arbitrary place, in arbitrary direction and along arbitrary curve. The class mglFont (@pxref{mglFont class}) is used for low-level string parsing and printing. It can use arbitrary font-faces and parse many TeX commands. All these functions have 2 variant: for printing 8-bit text (@code{char *}) and for printing Unicode text (@code{wchar_t *}). In first case the conversion in current locale is used. So sometimes you need to specify it by @code{setlocale()} function. The size argument control the size of text: if positive it give the value, if negative it give the value relative to @var{FontSize}. The font type (STIX, arial, courier, times and so on) can be selected by function SetFont(), GetFont(). @xref{Font settings}.

The font parameters are described by string. This string may contain several characters of font type (@samp{rbiwou}) and/or align (@samp{LRC}) specification. Also it may contain the text color @samp{wkrgbcymhRGBCYMHW} (@pxref{mglColor class}) after symbol @samp{:}. The font types are: @samp{r} -- roman font, @samp{i} -- italic style, @samp{b} -- bold style, @samp{w} -- wired style, @samp{o} -- over-lined text, @samp{u} -- underlined text. By default roman font is used. The align types are: @samp{L} -- align left (default), @samp{C} -- align center, @samp{R} -- align right. Also a parsing of the LaTeX-like syntax is provided (for detail @pxref{mglFont class}). For example, string @samp{iC:b} correspond to italic font style for centered text which printed by blue color.

@deftypemethod mglGraph @code{void} Puts (@code{mglPoint} p, @code{const char *}text, @code{const char *}font=@code{NULL}, @code{float} size=@code{-1}, @code{char} dir=@code{0}, @code{float} shift=@code{0})
@deftypemethodx mglGraph @code{void} Putsw (@code{mglPoint} p, @code{const wchar_t *}text, @code{const char *}font=@code{NULL}, @code{float} size=@code{-1}, @code{char} dir=@code{0}, @code{float} shift=@code{0})
The function plots the string @var{text} at position @var{p} with fonts specifying by the criteria @var{how}. The size of font is set by @var{size} parameter (default is @var{FontSize}). Parameter @var{dir} specifies the additional string align. The aligns are: @samp{x} -- align as x-label, @samp{y} -- align as y-label, @samp{z} -- align as z-label, @samp{i} -- align as x-label but inverse writing direction, @samp{t} -- no align (default), @samp{n} -- align in x-y plane.
@end deftypemethod

@deftypemethod mglGraph @code{float} Puts (@code{mglPoint} p, @code{mglPoint} l, @code{const char *}text, @code{char}where=@code{'t'}, @code{float} size=@code{-1})
@deftypemethodx mglGraph @code{float} Putsw (@code{mglPoint} p, @code{mglPoint} l, @code{const wchar_t *}text, @code{char}where=@code{'t'}, @code{float} size=@code{-1})
The function plots the string @var{text} at position @var{p} along direction @var{l} with specified @var{size}. Parameter @var{where} set to print text above the line (@samp{T}) or under the line (@samp{t}). Function return the width of the string.
@end deftypemethod

@deftypemethod mglGraph @code{void} Text (@code{mglPoint} p, @code{const char *}text, @code{const char *}font=@code{NULL}, @code{float} size=@code{-1}, @code{char} dir=@code{0})
@deftypemethodx mglGraph @code{void} Text (@code{mglPoint} p, @code{const wchar_t *}text, @code{const char *}font=@code{NULL}, @code{float} size=@code{-1}, @code{char} dir=@code{0})
The function plots the string @var{text} at position @var{p} with fonts @var{how}. These functions are obsolete -- use Puts(), Putsw() functions instead.
@end deftypemethod

@deftypemethod mglGraph @code{void} Printf (@code{mglPoint} p, @code{const char *}arg, ...)
Print formatted string at point @var{p}.
@end deftypemethod

@deftypemethod mglGraph @code{void} Title (@code{const char *}text, @code{const char *}font=@code{0}, @code{float} size=@code{-2})
@deftypemethodx mglGraph @code{void} Title (@code{const wchar_t *}text, @code{const char *}font=@code{0}, @code{float} size=@code{-2})
Print string @var{text} as title of the picture (at the top of the picture). Can be used at any place (even inside SubPlot()).
@end deftypemethod

@deftypemethod mglGraph @code{void} Text (@code{const mglData &}y, @code{const char *}text, @code{const char *}font=@code{NULL}, float size=@code{-1}, @code{float} zVal=@code{NAN})
@deftypemethodx mglGraph @code{void} Text (@code{const mglData &}y, @code{const wchar_t *}text, @code{const char *}font=@code{NULL}, float size=@code{-1}, @code{float} zVal=@code{NAN})
@deftypemethodx mglGraph @code{void} Text (@code{const mglData &}x, @code{const mglData &}y, @code{const char *}text, @code{const char *}font=@code{NULL}, float size=@code{-1}, @code{float} zVal=@code{NAN})
@deftypemethodx mglGraph @code{void} Text (@code{const mglData &}x, @code{const mglData &}y, @code{const wchar_t *}text, @code{const char *}font=@code{NULL}, float size=@code{-1}, @code{float} zVal=@code{NAN})
@deftypemethodx mglGraph @code{void} Text (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}text, @code{const char *}font=@code{NULL}, float size=@code{-1})
@deftypemethodx mglGraph @code{void} Text (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const wchar_t *}text, @code{const char *}font=@code{NULL}, float size=@code{-1})
The function draws @var{text} along the curve between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} by font style @var{font} and with size @var{size}. The string @var{font} may contain symbols @samp{t} for printing the text under the curve (default), or @samp{T} for printing the text above the curve. The sizes of 1st dimension must be equal for all arrays @var{x.nx=y.nx=z.nx}. If array @var{x} is not specified then its an automatic array is used with values equidistantly distributed in interval [@var{Min}.x, @var{Max}.x] (@pxref{Ranges (bounding box)}). If array @var{z} is not specified then @var{z}[i] = @var{zVal} is used. @sref{Text sample}
@end deftypemethod

@c ##################################################################
@node Axis and Colorbar, Legend, Text printing, MathGL core
@section Axis and Colorbar
@cindex Axis
@cindex Box
@cindex Grid
@cindex Colorbar
@cindex Label

These functions draw the ``things for measuring'', like axis with ticks, colorbar with ticks, grid along axis, bounding box and labels for axis. For more information @pxref{Axis settings}.

@deftypemethod mglGraph @code{void} Axis (@code{const char *}dir=@code{"xyz"}, @code{bool} adjust=@code{false})
Draws axes with ticks (@pxref{Axis settings}) in directions determined by string parameter @var{dir}.If string contain the symbol @samp{_} then tick labels are not printed. Font for ticks labels is determined by @var{FontDef} (@pxref{Font settings}). Ticks will be adjusted if @var{adjust}=@code{true} (by call of @code{AdjustTicks()}). 
@end deftypemethod

@deftypemethod mglGraph @code{void} Colorbar (@code{const char *}sch=@code{NULL}, @code{int} where=@code{0})
Draws colorbar with color scheme @var{sch} (current scheme if @code{sch=NULL}) at edge of plot. Parameter @var{where} specifies the position of the colorbar: @samp{0} - at right (default), @samp{1} - at left, @samp{2} - at top, @samp{3} - at bottom. @sref{Dens sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} Colorbar (@code{const char *}sch, @code{int} where, @code{float} x, @code{float} y, @code{float} w, @code{float} h)
@deftypemethodx mglGraph @code{void} Colorbar (@code{int} where, @code{float} x, @code{float} y, @code{float} w, @code{float} h)
Draws colorbar with color scheme @var{sch} (current scheme if not specified) at arbitrary position of subplot @{@var{x}, @var{y}@} (supposed to be in range [0,1]). Parameter @var{where} specifies the position of colorbar labels: @samp{0} - at left, @samp{1} - at right, @samp{2} - at bottom, @samp{3} - at top. Parameters @var{w}, @var{h} set the relative width and height of the colorbar.
@end deftypemethod

@deftypemethod mglGraph @code{void} Grid (@code{const char *}dir=@code{"xyz"}, @code{const char *}pen=@code{"B-"})
Draws grid lines perpendicular to direction determined by string parameter @var{dir}. The step of grid lines is the same as tick step for an Axis(). The style of lines is determined by @var{pen} parameter (default value is dark blue solid line (@samp{B-}).
@end deftypemethod

@deftypemethod mglGraph @code{void} Box (@code{mglColor} col=@code{NC}, @code{bool} ticks=@code{true})
@deftypemethodx mglGraph @code{void} Box (@code{const char *}col, @code{bool} ticks=@code{true})
Draws bounding box outside the plotting volume with color @var{col}.
@end deftypemethod

@deftypemethod mglGraph @code{void} Label (@code{char} dir, @code{const char *}text, @code{int} pos=@code{+1}, @code{float} size=@code{-1.4}, @code{float} shift=@code{0})
@deftypemethodx mglGraph @code{void} Label (@code{char} dir, @code{const wchar_t *}text, @code{int} pos=@code{+1}, @code{float} size=@code{-1.4}, @code{float} shift=@code{0})
Prints the label @var{text} for axis @var{dir}. The position of label is determined by @var{pos} parameter. If @var{pos}=0 then label is printed at the center of axis. If @var{pos}>0 then label is printed at the maximum of axis. If @var{pos}<0 then label is printed at the minimum of axis. Parameter @var{size} determines the font size for the label. By default the font size is 1.4 times larger than the one for ticks @var{FontSize} (@pxref{Font settings}). @xref{Text printing}.
@end deftypemethod

@c ##################################################################
@node Legend, 1D plotting, Axis and Colorbar, MathGL core
@section Legend
@cindex Legend
@cindex AddLegend
@cindex ClearLegend

These functions draw legend to the graph (useful for @ref{1D plotting}). Legend entry is a pair of strings: one for style of the line, another one with description text (with included LaTeX parsing). The array of string may be used directly or by accumulating first to the internal arrays (by function AddLegend()) and further plotting it. The position of the legend can be selected automatic or manually. Parameters @var{font} and @var{size} specify the font style and size (@pxref{Font settings}). Parameter @var{llen} set the relative width of the line sample and the text indent. If line style string for entry is empty then the corresponding text is printed without indent. @sref{Legend sample}

@deftypemethod mglGraph @code{void} Legend (@code{int} where=@code{0x3}, @code{const char *}font=@code{"rL"}, @code{float} size=@code{-0.8}, @code{float} llen=@code{0.1})
Draws legend of accumulated legend entries by font @var{font} with @var{size}. Parameter @var{where} sets the position of the legend: @samp{0} is bottom left corner, @samp{1} is bottom right corner, @samp{2} is top left corner, @samp{3} is top right corner (is default).
@end deftypemethod

@deftypemethod mglGraph @code{void} Legend (@code{int} n, @code{wchar_t **}text, @code{char **}style, @code{int} where=@code{0x3}, @code{const char *}font=@code{"rL"}, @code{float} size=@code{-0.8}, @code{float} llen=@code{0.1})
Draws legend with @var{n}-th elements of string array @var{text} by font @var{font} with @var{size}. Entry strings @var{text} describe curves with line style @var{style} (including marks). Parameter @var{where} sets the position of the legend: @samp{0} is bottom left corner, @samp{1} is bottom right corner, @samp{2} is top left corner, @samp{3} is top right corner (is default).
@end deftypemethod

@deftypemethod mglGraph @code{void} Legend (@code{float} x, @code{float} y, @code{const char *}font=@code{"rL"}, @code{float} size=@code{-0.8}, @code{float} llen=@code{0.1})
Draws legend of accumulated legend entries by font @var{font} with @var{size}. Position of legend is determined by parameter @var{x}, @var{y} which supposed to be normalized to interval [0,1].
@end deftypemethod
@deftypemethod mglGraph @code{void} Legend (@code{int} n, @code{wchar_t **}text, @code{char **}style, @code{float} x, @code{float} y, @code{const char *}font=@code{"rL"}, @code{float} size=@code{-0.8}, @code{float} llen=@code{0.1})
Draws legend with @var{n}-th elements of string array @var{text} by font @var{font} with @var{size}. Entry strings @var{text} describe curves with line style @var{style} (including marks). Position of legend is determined by parameter @var{x}, @var{y} which supposed to be normalized to interval [0,1].
@end deftypemethod

@deftypemethod mglGraph @code{void} AddLegend (@code{const char *}text, @code{const char *}style)
@deftypemethodx mglGraph @code{void} AddLegend (@code{const wchar_t *}text, @code{const char *}style)
Adds string @var{text} to internal legend accumulator. The style of described line and mark is specified in string @var{style} (@pxref{Line styles}). Maximal number of entries is 100.
@end deftypemethod

@deftypemethod mglGraph @code{void} ClearLegend ()
Clears saved legend strings.
@end deftypemethod

@deftypecv {General option} mglGraph @code{bool} LegendBox
Switch on/off drawing box near legend. By default (=@code{true}) box is drawn.
@end deftypecv

@c ##################################################################
@node 1D plotting, 2D plotting, Legend, MathGL core
@section 1D plotting

These functions perform plotting of 1D data. 1D means that data depended from only 1 parameter like parametric curve @{x(i),y(i),z(i)@}, i=1...n. There are 5 generally different types of data representations: simple line plot (Plot), line plot with filling under it (Area), stairs plot (Step), bar plot (Bars, Barh) and vertical lines (Stem). Each type of plotting has similar interface. There are 3D version and two 2D versions. One of last requires single array. The parameters of line and marks are specified by the string argument. If the string parameter is NULL then solid line with color from palette Pal is used (@pxref{Palette and colors}). Also there are some special 1d plots having slightly different interface: surface of curve rotation (Torus), chart (Chart) and error boxes (Error), marks with variable size (Mark), tubes (Tube) and so on. @xref{Line styles}.


@menu
* Plot::                        
* Tens::                        
* Area::                        
* Region::                      
* Bars::                        
* Barh::                        
* Stem::                        
* Step::                        
* Torus::                       
* Chart::                       
* Mark::                        
* TextMark::                    
* Error::                       
* Tube::                        
@end menu


@c ==================================================================
@node Plot, Tens, , 1D plotting
@subsection Plot
@cindex Plot

These functions draw continuous lines between points. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Area}, @ref{Step}, @ref{Stem}, @ref{Tube}, @ref{Mark}, @ref{Error}, @ref{Belt}, @ref{Tens}. @sref{Plot sample}

@deftypemethod mglGraph @code{void} Plot (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}pen=@code{NULL})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space.
@end deftypemethod

@deftypemethod mglGraph @code{void} Plot (@code{const mglData &}x, @code{const mglData &}y, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}).
@end deftypemethod

@deftypemethod mglGraph @code{void} Plot (@code{const mglData &}y, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}), where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@deftypemethod mglGraph @code{void} Plot2 (@code{const mglData &}a, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}), where @var{x}=@var{a}(2*k,:), @var{y}=@var{a}(2*k+1,:), k \in 0 ... @var{a.ny}/2. This function is obsolete -- use Plot() and SubData() functions instead.
@end deftypemethod
@deftypemethod mglGraph @code{void} Plot3 (@code{const mglData &}a, @code{const char *}pen=@code{NULL})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space, where @var{x}=@var{a}(3*k,:), @var{y}=@var{a}(3*k+1,:), @var{z}=@var{a}(3*k+2,:), k \in 0 ... @var{a.ny}/3. This function is obsolete -- use Plot() and SubData() functions instead.
@end deftypemethod

@c ==================================================================
@node Tens, Area, Plot, 1D plotting
@subsection Tens
@cindex Tens

These functions draw continuous lines between points with color defined by the special array (look like tension plot). The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color scheme (@pxref{Color scheme}) and style and/or width of line (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with current color scheme is used. See also @ref{Plot}, @ref{Mesh}, @ref{Fall}. @sref{Tens sample}

@deftypemethod mglGraph @code{void} Tens (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}c, @code{const char *}pen=@code{NULL})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space with color defined by @var{c}[i].
@end deftypemethod

@deftypemethod mglGraph @code{void} Tens (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}c, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}) with color defined by @var{c}[i].
@end deftypemethod

@deftypemethod mglGraph @code{void} Tens (@code{const mglData &}y, @code{const mglData &}c, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}) with color defined by @var{c}[i], where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@c ==================================================================
@node Area, Region, Tens, 1D plotting
@subsection Area
@cindex Area

These functions draw continuous lines between points and fills it to axis plane. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Plot}, @ref{Bars}, @ref{Stem}. @sref{Area sample}

@deftypemethod mglGraph @code{void} Area (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}pen=@code{NULL})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space and fills it down to @var{z} = Org.z.
@end deftypemethod

@deftypemethod mglGraph @code{void} Area (@code{const mglData &}x, @code{const mglData &}y, @code{const char *}pen=@code{NULL}, @code{bool} sum=@code{false}, @code{float} zVal=@code{NAN})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}) and fills it down to @var{y} = Org.y. Parameter @var{sum} set to draw a lines one above another (like summation). Note, you can reach the same effect if call @code{y.CumSum("y");} before plot.
@end deftypemethod

@deftypemethod mglGraph @code{void} Area (@code{const mglData &}y, @code{const char *}pen=@code{NULL}, @code{bool} sum=@code{false}, @code{float} zVal=@code{NAN})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}) and fills it down to @var{y} = Org.y, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x]. Parameter @var{sum} set to draw a lines one above another (like summation). Note, you can reach the same effect if call @code{y.CumSum("y");} before plot.
@end deftypemethod

@deftypemethod mglGraph @code{void} Area2 (@code{const mglData &}a, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}) and fills it down to @var{y} = Org.y, where @var{x}=@var{a}(2*k,:), @var{y}=@var{a}(2*k+1,:), k \in 0 ... @var{a.ny}/2. This function is obsolete -- use Area() and SubData() functions instead.
@end deftypemethod
@deftypemethod mglGraph @code{void} Area3 (@code{const mglData &}a, @code{const char *}pen=@code{NULL})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space and fills it down to @var{z} = Org.z, where @var{x}=@var{a}(3*k,:), @var{y}=@var{a}(3*k+1,:), @var{z}=@var{a}(3*k+2,:), k \in 0 ... @var{a.ny}/3. This function is obsolete -- use Area() and SubData() functions instead.
@end deftypemethod

@c ==================================================================
@node Region, Bars, Area, 1D plotting
@subsection Region
@cindex Region

These functions fill area between 2 curves. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y1.nx=y2.nx} and all dimensions of arrays @var{y1} and @var{y2} must be equal too. String @var{pen} specifies the color (@pxref{Line styles}). By default (@code{pen=NULL}) color from palette is used (@pxref{Palette and colors}). See also @ref{Area}, @ref{Bars}, @ref{Stem}. @sref{Region sample}

@deftypemethod mglGraph @code{void} Region (@code{const mglData &}x, @code{const mglData &}y1, @code{const mglData &}y2, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN}, @code{bool} inside=@code{true})
The function fills area between curves @{@var{x}[i], @var{y}[i]@} and @{@var{x}[i], @var{y2}[i]@} at z=@var{zVal}.
@end deftypemethod

@deftypemethod mglGraph @code{void} Region (@code{const mglData &}y1, @code{const mglData &}y2, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN}, @code{bool} inside=@code{true})
The function fills area between curves @{@var{x}[i], @var{y}[i]@} and @{@var{x}[i], @var{y2}[i]@}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x] at z=@var{zVal}.
@end deftypemethod


@c ==================================================================
@node Bars, Barh, Region, 1D plotting
@subsection Bars
@cindex Bars

These functions draw vertical bars from points to axis plane. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Barh}, @ref{Area}, @ref{Stem}, @ref{Chart}, @ref{Default sizes}. @sref{Bars sample}

@deftypemethod mglGraph @code{void} Bars (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}pen=@code{NULL})
The function draws vertical bars from points @{@var{x}[i], @var{y}[i], @var{z}[i]@} down to @var{z} = Org.z.
@end deftypemethod

@deftypemethod mglGraph @code{void} Bars (@code{const mglData &}x, @code{const mglData &}y, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws vertical bars from points @{@var{x}[i], @var{y}[i]@} down to @var{y} = Org.y in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}).
@end deftypemethod

@deftypemethod mglGraph @code{void} Bars (@code{const mglData &}y, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws vertical bars from points @{@var{x}[i], @var{y}[i]@} down to @var{y} = Org.y in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}), where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@deftypemethod mglGraph @code{void} Bars2 (@code{const mglData &}a, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws vertical bars from points @{@var{x}[i], @var{y}[i]@} down to @var{y} = Org.y in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}), where @var{x}=@var{a}(2*k,:), @var{y}=@var{a}(2*k+1,:), k \in 0 ... @var{a.ny}/2. This function is obsolete -- use Bars() and SubData() functions instead.
@end deftypemethod
@deftypemethod mglGraph @code{void} Bars3 (@code{const mglData &}a, @code{const char *}pen=@code{NULL})
The function draws vertical bars from points @{@var{x}[i], @var{y}[i], @var{z}[i]@} down to @var{z} = Org.z, where @var{x}=@var{a}(3*k,:), @var{y}=@var{a}(3*k+1,:), @var{z}=@var{a}(3*k+2,:), k \in 0 ... @var{a.ny}/3. This function is obsolete -- use Bars() and SubData() functions instead.
@end deftypemethod

@c ==================================================================
@node Barh, Stem, Bars, 1D plotting
@subsection Barh
@cindex Barh

These functions draw horizontal bars from points to axis plane. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Barh}, @ref{Default sizes}. @sref{Barh sample}

@deftypemethod mglGraph @code{void} Barh (@code{const mglData &}y, @code{const mglData &}v, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws horizontal bars from points @{@var{v}[i], @var{y}[i]@} down to @var{x} = Org.x in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}).
@end deftypemethod

@deftypemethod mglGraph @code{void} Barh (@code{const mglData &}v, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws horizontal bars from points @{@var{v}[i], @var{y}[i]@} down to @var{x} = Org.x in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}), where @var{y}[i] values are equidistantly distributed in interval [@var{Min}.y, @var{Max}.y].
@end deftypemethod

@c ==================================================================
@node Stem, Step, Barh, 1D plotting
@subsection Stem
@cindex Stem

These functions draw vertical lines from points to axis plane. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Area}, @ref{Bars}, @ref{Plot}. @sref{Stem sample}

@deftypemethod mglGraph @code{void} Stem (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}pen=@code{NULL})
The function draws vertical lines from points @{@var{x}[i], @var{y}[i], @var{z}[i]@} down to @var{z} = Org.z.
@end deftypemethod

@deftypemethod mglGraph @code{void} Stem (@code{const mglData &}x, @code{const mglData &}y, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws vertical lines from points @{@var{x}[i], @var{y}[i]@} down to @var{y} = Org.y in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}).
@end deftypemethod

@deftypemethod mglGraph @code{void} Stem (@code{const mglData &}y, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws vertical lines from points @{@var{x}[i], @var{y}[i]@} down to @var{y} = Org.y in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}), where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@deftypemethod mglGraph @code{void} Stem2 (@code{const mglData &}a, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws vertical lines from points @{@var{x}[i], @var{y}[i]@} down to @var{y} = Org.y in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}), where @var{x}=@var{a}(2*k,:), @var{y}=@var{a}(2*k+1,:), k \in 0 ... @var{a.ny}/2. This function is obsolete -- use Stem() and SubData() functions instead.
@end deftypemethod
@deftypemethod mglGraph @code{void} Stem3 (@code{const mglData &}a, @code{const char *}pen=@code{NULL})
The function draws vertical lines from points @{@var{x}[i], @var{y}[i], @var{z}[i]@} down to @var{z} = Org.z, where @var{x}=@var{a}(3*k,:), @var{y}=@var{a}(3*k+1,:), @var{z}=@var{a}(3*k+2,:), k \in 0 ... @var{a.ny}/3. This function is obsolete -- use Stem() and SubData() functions instead.
@end deftypemethod

@c ==================================================================
@node Step, Torus, Stem, 1D plotting
@subsection Step
@cindex Step

These functions draw continuous stairs for points to axis plane. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Plot}, @ref{Stem}, @ref{Tile}, @ref{Boxs}. @sref{Step sample}

@deftypemethod mglGraph @code{void} Step (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}pen=@code{NULL})
The function draws continuous stairs for points @{@var{x}[i], @var{y}[i], @var{z}[i]@}.
@end deftypemethod

@deftypemethod mglGraph @code{void} Step (@code{const mglData &}x, @code{const mglData &}y, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws continuous stairs for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}).
@end deftypemethod

@deftypemethod mglGraph @code{void} Step (@code{const mglData &}y, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws continuous stairs for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}), where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@deftypemethod mglGraph @code{void} Step2 (@code{const mglData &}a, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws continuous stairs for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}), where @var{x}=@var{a}(2*k,:), @var{y}=@var{a}(2*k+1,:), k \in 0 ... @var{a.ny}/2. This function is obsolete -- use Step() and SubData() functions instead.
@end deftypemethod
@deftypemethod mglGraph @code{void} Step3 (@code{const mglData &}a, @code{const char *}pen=@code{NULL})
The function draws continuous stairs for points @{@var{x}[i], @var{y}[i], @var{z}[i]@}, where @var{x}=@var{a}(3*k,:), @var{y}=@var{a}(3*k+1,:), @var{z}=@var{a}(3*k+2,:), k \in 0 ... @var{a.ny}/3. This function is obsolete -- use Step() and SubData() functions instead.
@end deftypemethod

@c ==================================================================
@node Torus, Chart, Step, 1D plotting
@subsection Torus
@cindex Torus

These functions draw surface which is result of curve @{@var{r}, @var{z}@} rotation around @var{AxialDir} axis (@pxref{Other settings}). The sizes of 1st dimension @strong{must be equal} for all arrays @var{r.nx=z.nx}. String @var{pen} specifies the color (@pxref{Line styles}). By default (@code{pen=NULL}) color from palette is used (@pxref{Palette and colors}). See also @ref{Plot}, @ref{Axial}. @sref{Torus sample}

@deftypemethod mglGraph @code{void} Torus (@code{const mglData &}r, @code{const mglData &}z, @code{const char *}pen=@code{NULL})
The function draws surface which is result of curve @{@var{r}[i], @var{z}[i]@} rotation.
@end deftypemethod

@deftypemethod mglGraph @code{void} Torus (@code{const mglData &}z, @code{const char *}pen=@code{NULL})
The function draws surface which is result of curve @{@var{r}[i], @var{z}[i]@} rotation, where @var{r}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@deftypemethod mglGraph @code{void} Torus2 (@code{const mglData &}a, @code{const char *}pen=@code{NULL})
The function draws surface which is result of curve @{@var{x}[i], @var{y}[i]@} rotation, where @var{r}=@var{a}(2*k,:), @var{z}=@var{a}(2*k+1,:), k \in 0 ... @var{a.ny}/2. This function is obsolete -- use Torus() and SubData() functions instead.
@end deftypemethod

@c ==================================================================
@node Chart, Mark, Torus, 1D plotting
@subsection Chart
@cindex Chart

@deftypemethod mglGraph @code{void} Chart (@code{const mglData &}a, @code{const char *}col=@code{NULL})
The function draws colored stripes (boxes) for data in array @var{a}. The number of stripes is equal to the number of rows in @var{a} (equal to @var{a.ny}). The color of each next stripe is cyclically changed from colors specified in string @var{col} or in palette Pal (@pxref{Palette and colors}). Spaces in colors denote transparent ``color'', i.e. if @var{col} contain space(s) then corresponding stripe(s) are not drawn. The stripe width is proportional to value of element in @var{a}. Chart is plotted only for data with non-negative elements. If string @var{col} have symbol @samp{#} then black border lines are drawn. The most nice form the chart have in 3d (after rotation of coordinates) or in cylindrical coordinates (becomes so called Pie chart). @sref{Chart sample}
@end deftypemethod

@c ==================================================================
@node Mark, TextMark, Chart, 1D plotting
@subsection Mark
@cindex Mark

These functions draw marks with size @var{r}*@var{MarkSize} (@pxref{Default sizes}) at points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx=r.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). If you need to draw markers of the same size then you may use @ref{Plot} function. See also @ref{Plot}, @ref{TextMark}, @ref{Stem}, @ref{Error}. @sref{Mark sample}

@deftypemethod mglGraph @code{void} Mark (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}r, @code{const char *}pen=@code{NULL})
The function draws marks for points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space.
@end deftypemethod

@deftypemethod mglGraph @code{void} Mark (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}r, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws marks for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}).
@end deftypemethod

@deftypemethod mglGraph @code{void} Mark (@code{const mglData &}y, @code{const mglData &}r, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws marks for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}), where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@c ==================================================================
@node TextMark, Error, Mark, 1D plotting
@subsection TextMark
@cindex TextMark

These functions draw string @var{text} as marks with size proportional to @var{r}*@var{MarkSize} (@pxref{Default sizes}) at points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx=r.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Plot}, @ref{Mark}, @ref{Stem}. @sref{TextMark sample}

@deftypemethod mglGraph @code{void} TextMark (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}r, @code{const wchar_t *}text, @code{const char *}fnt=@code{NULL})
@deftypemethodx mglGraph @code{void} TextMark (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}r, @code{const char *}text, @code{const char *}fnt=@code{NULL})
The function draws textual marks for points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space.
@end deftypemethod

@deftypemethod mglGraph @code{void} TextMark (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}r, @code{const wchar_t *}text, @code{const char *}fnt=@code{NULL}, @code{float} zVal=@code{NAN})
@deftypemethodx mglGraph @code{void} TextMark (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}r, @code{const char *}text, @code{const char *}fnt=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws textual marks for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}).
@end deftypemethod

@deftypemethod mglGraph @code{void} TextMark (@code{const mglData &}y, @code{const mglData &}r, @code{const wchar_t *}text, @code{const char *}fnt=@code{NULL}, @code{float} zVal=@code{NAN})
@deftypemethodx mglGraph @code{void} TextMark (@code{const mglData &}y, @code{const mglData &}r, @code{const char *}text, @code{const char *}fnt=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws textual marks for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}), where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@deftypemethod mglGraph @code{void} TextMark (@code{const mglData &}y, @code{const wchar_t *}text, @code{const char *}fnt=@code{NULL}, @code{float} zVal=@code{NAN})
@deftypemethodx mglGraph @code{void} TextMark (@code{const mglData &}y, @code{const char *}text, @code{const char *}fnt=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws textual marks for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}), where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x]. The mark sizes @var{r}[i]=1 for all points.
@end deftypemethod

@c ==================================================================
@node Error, Tube, TextMark, 1D plotting
@subsection Error
@cindex Error

These functions draw error boxes at points @{@var{x}[i], @var{y}[i]@}  on plane @var{z} = @var{zVal} (by default @var{z}=@var{Min.z}). This can be useful, for example, in experimental points, or to show numeric error or some estimations and so on. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx=r.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Plot}. @sref{Error sample}

@deftypemethod mglGraph @code{void} Error (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ex, @code{const mglData &}ey, @code{const char *}pen=@code{NULL}, @code{float}zVal=@code{NAN})
Draws a error box @{@var{ex}, @var{ey}@} in point position @{@var{x}, @var{y}@}.
@end deftypemethod

@deftypemethod mglGraph @code{void} Error (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ey, @code{const wchar_t *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
Draws a error box @var{ey} (along only one direction) in point position @{@var{x}, @var{y}@}.
@end deftypemethod
@deftypemethod mglGraph @code{void} Error (@code{const mglData &}y, @code{const mglData &}ey, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
Draws a error box @var{ey} (along only one direction) in point position @{@var{x}, @var{y}@}, where @var{x} values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@c ==================================================================
@node Tube, , Error, 1D plotting
@subsection Tube
@cindex Tube

These functions draw the tube with variable radius @var{r}[i] along the curve between points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx=r.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Plot}. @sref{Tube sample}

@deftypemethod mglGraph @code{void} Tube (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}r, @code{const char *}pen=@code{NULL})
@deftypemethodx mglGraph @code{void} Tube (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{float} r, @code{const char *}pen=@code{NULL})
The function draws tube with radius @var{r} between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space.
@end deftypemethod

@deftypemethod mglGraph @code{void} Tube (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}r, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
@deftypemethodx mglGraph @code{void} Tube (@code{const mglData &}x, @code{const mglData &}y, @code{float} r, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws tube with radius @var{r} between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}).
@end deftypemethod

@deftypemethod mglGraph @code{void} Tube (@code{const mglData &}y, @code{const mglData &}r, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
@deftypemethodx mglGraph @code{void} Tube (@code{const mglData &}y, @code{float} r, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws tube with radius @var{r} between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}), where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@c ##################################################################
@node 2D plotting, 3D plotting, 1D plotting, MathGL core
@section 2D plotting

These functions perform plotting of 2D data. 2D means that data depend from 2 independent parameters like matrix @math{f(x_i,y_j), i=1...n, j=1...m}. There are 6 generally different types of data representations: simple mesh lines plot (Mesh), surface plot (Surf), surface plot by boxes (Boxs), surface plot by tiles (Tile), waterfall-like plot (Fall), belt plot (Belt), density plot (Dens), contour lines plot (Cont), solid contours plot (ContF) and its rotational figure (Axial). Cont, ContF and Axial functions have variants for automatic and manual selection of level values for contours. Also there are functions for plotting data grid lines according to the data format (Grid) for enhancing density or contour plots. Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@menu
* Mesh::                        
* Fall::                        
* Belt::                        
* Surf::                        
* Boxs::                        
* Tile::                        
* Dens::                        
* Cont::                        
* ContF::                       
* Axial::                       
* Grid::                        
@end menu

@c ==================================================================
@node Mesh, Fall, , 2D plotting
@subsection Mesh
@cindex Mesh

@deftypemethod mglGraph @code{void} Mesh (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{NULL})
The function draws mesh lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Mesh lines are plotted for each z slice of the data. See also @ref{Surf}, @ref{Fall}, NeshNum (@pxref{Other settings}), @ref{Cont}, @ref{Tens}. @sref{Mesh sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} Mesh (@code{const mglData &}z, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Fall, Belt, Mesh, 2D plotting
@subsection Fall
@cindex Fall

@deftypemethod mglGraph @code{void} Fall (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{NULL})
The function draws fall lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If @var{sch} contain @samp{x} then lines are drawn along x-direction else (by default) lines are drawn along y-direction. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Fall lines are plotted for each z slice of the data. See also @ref{Belt}, @ref{Mesh}, @ref{Tens}, NeshNum (@pxref{Other settings}). @sref{Fall sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} Fall (@code{const mglData &}z, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Belt, Surf, Fall, 2D plotting
@subsection Belt
@cindex Belt

@deftypemethod mglGraph @code{void} Belt (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{NULL})
The function draws belts for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. This plot can be used as 3d generalization of Plot (@pxref{Plot}). String @var{sch} sets the color scheme. Previous color scheme is used by default. If @var{sch} contain @samp{x} then belts are drawn along x-direction else (by default) belts are drawn along y-direction. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Belts are plotted for each z slice of the data. See also @ref{Fall}, @ref{Surf}, @ref{Plot}, NeshNum (@pxref{Other settings}). @sref{Belt sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} Belt (@code{const mglData &}z, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Surf, Boxs, Belt, 2D plotting
@subsection Surf
@cindex Surf

@deftypemethod mglGraph @code{void} Surf (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{NULL})
The function draws surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Mesh}, @ref{Dens}, @ref{Belt}, @ref{Tile}, @ref{Boxs}, @ref{SurfC}, @ref{SurfA}. @sref{Surf sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} Surf (@code{const mglData &}z, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Boxs, Tile, Surf, 2D plotting
@subsection Boxs
@cindex Boxs

@deftypemethod mglGraph @code{void} Boxs (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{NULL})
The function draws vertical boxes for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Surf}, @ref{Tile}, @ref{Step}. @sref{Boxs sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} Boxs (@code{const mglData &}z, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Tile, Dens, Boxs, 2D plotting
@subsection Tile
@cindex Tile

@deftypemethod mglGraph @code{void} Tile (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{NULL})
The function draws horizontal tiles for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. Such plot can be used as 3d generalization of Step (@pxref{Step}). String @var{sch} sets the color scheme. Previous color scheme is used by default. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Surf}, @ref{Boxs}, @ref{Step}, @ref{TileS}. @sref{Tile sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} Tile (@code{const mglData &}z, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Dens, Cont, Tile, 2D plotting
@subsection Dens
@cindex Dens

@deftypemethod mglGraph @code{void} Dens (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws density plot for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z} = @var{zVal}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Surf}, @ref{Cont}, @ref{ContF}, @ref{DensXYZ}. @sref{Dens sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} Dens (@code{const mglData &}z, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Cont, ContF, Dens, 2D plotting
@subsection Cont
@cindex Cont

@deftypemethod mglGraph @code{void} Cont (@code{const mglData &}v, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws contour lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z} = @var{zVal} (or for @var{z=v}[k] if @code{zVal==NAN}). Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Dens}, @ref{ContF}, @ref{Axial}, @ref{ContXYZ}. @sref{Cont sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} Cont (@code{const mglData &}v, @code{const mglData &}z, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod mglGraph @code{void} Cont (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{NULL}, @code{int} num=@code{7}, @code{float} zVal=@code{NAN})
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypemethod

@deftypemethod mglGraph @code{void} Cont (@code{const mglData &}z, @code{const char *}sch=@code{NULL}, @code{int} num=@code{7}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node ContF, Axial, Cont, 2D plotting
@subsection ContF
@cindex ContF

@deftypemethod mglGraph @code{void} ContF (@code{const mglData &}v, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws solid (or filled) contour lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z} = @var{zVal} (or for @var{z=v}[k] if @code{zVal==NAN}). Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Dens}, @ref{Cont}, @ref{Axial}, @ref{ContFXYZ}. @sref{ContF sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} ContF (@code{const mglData &}v, @code{const mglData &}z, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod mglGraph @code{void} ContF (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{NULL}, @code{int} num=@code{7}, @code{float} zVal=@code{NAN})
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypemethod

@deftypemethod mglGraph @code{void} ContF (@code{const mglData &}z, @code{const char *}sch=@code{NULL}, @code{int} num=@code{7}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Axial, Grid, ContF, 2D plotting
@subsection Axial
@cindex Axial

@deftypemethod mglGraph @code{void} Axial (@code{const mglData &}v, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{NULL})
The function draws surface which is result of contour plot rotation for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then wire plot is produced. If string contain symbols @samp{x}, @samp{y} or @samp{z} then rotation axis @var{AxialDir} (@pxref{Other settings}) will be set to specified direction. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Cont}, @ref{ContF}, @ref{Torus}, @ref{Surf3}. @sref{Axial sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} Axial (@code{const mglData &}v, @code{const mglData &}z, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod mglGraph @code{void} Axial (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{NULL}, @code{int} num=@code{3})
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypemethod

@deftypemethod mglGraph @code{void} Axial (@code{const mglData &}z, @code{const char *}sch=@code{NULL}, @code{int} num=@code{3})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Grid, , Axial, 2D plotting
@subsection Grid
@cindex Grid

@deftypemethod mglGraph @code{void} Grid (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws grid lines for density plot of surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z} = @var{zVal}. String @var{sch} sets the color scheme. Previous color scheme is used by default. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Grid is plotted for each z slice of the data. See also @ref{Dens}, @ref{Cont}, @ref{ContF}.
@end deftypemethod

@deftypemethod mglGraph @code{void} Grid (@code{const mglData &}z, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod


@c ##################################################################
@node 3D plotting, Dual plotting, 2D plotting, MathGL core
@section 3D plotting

These functions perform plotting of 3D data. 3D means that data depend from 3 independent parameters like matrix @math{f(x_i,y_j,z_k), i=1...n, j=1...m, k=1...l}. There are 4 generally different types of data representations: isosurface or surface of constant value (Surf3), density plot at slices (Dens3), contour lines plot at slices (Cont3), solid contours plot at slices (ContF3) and cloud-like plot (Cloud). Surf3, Cont3 and ContF3 functions have variants for automatic and manual selection of level values for surfaces/contours. Also there are functions for plotting data grid lines according to the data format (Grid3) for enhancing density or contour plots. Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@menu
* Surf3::                       
* Dens3::                       
* Cont3::                       
* ContF3::                      
* Grid3::                       
* Cloud::                       
* Beam::                        
@end menu

@c ==================================================================
@node Surf3, Dens3, , 3D plotting
@subsection Surf3
@cindex Surf3

@deftypemethod mglGraph @code{void} Surf3 (@code{float} val, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}stl=@code{NULL})
The function draws isosurface plot for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) at @var{a}(x,y,z)=@var{val}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). Note, that there is possibility of incorrect plotting due to uncertainty of cross-section defining if there are two or more isosurface intersections inside one cell. See also @ref{Cloud}, @ref{Dens3}, @ref{Surf3C}, @ref{Surf3A}, @ref{Axial}. @sref{Surf3 sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} Surf3 (@code{float} val, @code{const mglData &}a, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod mglGraph @code{void} Surf3 (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}stl=@code{NULL}, @code{int} num=@code{3})
Draws @var{num}-th uniformly distributed in range [@var{Cmin}, @var{Cmax}] isosurfaces for 3d data specified parametrically.
@end deftypemethod

@deftypemethod mglGraph @code{void} Surf3 (@code{const mglData &}a, @code{const char *}sch=@code{NULL}, @code{int} num=@code{3})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Dens3, Cont3, Surf3, 3D plotting
@subsection Dens3
@cindex Dens3
@cindex DensA

@deftypemethod mglGraph @code{void} Dens3 (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}stl=@code{NULL})
The function draws density plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Density is plotted at slice @var{sVal} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{stl} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). See also @ref{Cont3}, @ref{ContF3}, @ref{Dens}, @ref{Grid3}. @sref{Dens3 sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} Dens3 (@code{const mglData &}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod mglGraph @code{void} DensA (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}stl=@code{NULL})
Draws density plots at all central slices of the 3d data specified parametrically.
@end deftypemethod

@deftypemethod mglGraph @code{void} DensA (@code{const mglData &}a, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Cont3, ContF3, Dens3, 3D plotting
@subsection Cont3
@cindex Cont3
@cindex ContA

@deftypemethod mglGraph @code{void} Cont3 (@code{const mglData &}v, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}stl=@code{NULL})
The function draws contour plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Contours are plotted for values specified in array @var{v} at slice @var{sVal} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{stl} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). See also @ref{Dens3}, @ref{ContF3}, @ref{Cont}, @ref{Grid3}. @sref{Cont3 sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} Cont3 (@code{const mglData &}v, @code{const mglData &}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod mglGraph @code{void} Cont3 (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}stl=@code{NULL}, @code{int} num=@code{7})
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypemethod

@deftypemethod mglGraph @code{void} Cont3 (@code{const mglData &}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}sch=@code{NULL}, @code{int} num=@code{7})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod mglGraph @code{void} ContA (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}stl=@code{NULL}, @code{int} num=@code{7})
Draws contour plots at all central slices of the 3d data specified parametrically.
@end deftypemethod

@deftypemethod mglGraph @code{void} ContA (@code{const mglData &}a, @code{const char *}sch=@code{NULL}, @code{int} num=@code{7})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node ContF3, Grid3, Cont3, 3D plotting
@subsection ContF3
@cindex ContF3
@cindex ContFA

@deftypemethod mglGraph @code{void} ContF3 (@code{const mglData &}v, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}stl=@code{NULL})
The function draws solid (or filled) contour plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Contours are plotted for values specified in array @var{v} at slice @var{sVal} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{stl} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). See also @ref{Dens3}, @ref{Cont3}, @ref{ContF}, @ref{Grid3}. @sref{ContF3 sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} ContF3 (@code{const mglData &}v, @code{const mglData &}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod mglGraph @code{void} ContF3 (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}stl=@code{NULL}, @code{int} num=@code{7})
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypemethod

@deftypemethod mglGraph @code{void} ContF3 (@code{const mglData &}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}sch=@code{NULL}, @code{int} num=@code{7})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod mglGraph @code{void} ContFA (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}stl=@code{NULL}, @code{int} num=@code{7})
Draws contour plots at all central slices of the 3d data specified parametrically.
@end deftypemethod

@deftypemethod mglGraph @code{void} ContFA (@code{const mglData &}a, @code{const char *}sch=@code{NULL}, @code{int} num=@code{7})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Grid3, Cloud, ContF3, 3D plotting
@subsection Grid3
@cindex Grid3
@cindex GridA

@deftypemethod mglGraph @code{void} Grid3 (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}stl=@code{NULL})
The function draws grid for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Density is plotted at slice @var{sVal} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{stl} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). See also @ref{Cont3}, @ref{ContF3}, @ref{Dens3}, @ref{Grid}.
@end deftypemethod

@deftypemethod mglGraph @code{void} Grid3 (@code{const mglData &}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod mglGraph @code{void} GridA (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}stl=@code{NULL})
Draws grids at all central slices of the 3d data specified parametrically.
@end deftypemethod

@deftypemethod mglGraph @code{void} GridA (@code{const mglData &}a, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Cloud, Beam, Grid3, 3D plotting
@subsection Cloud
@cindex CloudP
@cindex CloudQ

@deftypemethod mglGraph @code{void} CloudQ (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}stl=@code{NULL}, @code{float} alpha=@code{1})
The function draws cloud plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). This plot is a set of cubes with color and transparency proportional to value of @var{a}. The resulting plot is like cloud -- low value is transparent but higher ones are not. The number of plotting cells depend on MeshNum (@pxref{Other settings}). String @var{sch} sets the color scheme. Previous color scheme is used by default. Parameter @var{alpha} changes the overall transparency of plot. The minor dimensions of arrays @var{x}, @var{y}, @var{z} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). See also @ref{Surf3}. @sref{CloudQ sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} CloudQ (@code{const mglData &}a, @code{const char *}stl=@code{NULL}, @code{float} alpha=@code{1})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod mglGraph @code{void} CloudP (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}stl=@code{NULL}, @code{float} alpha=@code{1})
The same as first one but the semi-transparent points are used instead of cubes. @sref{CloudP sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} CloudP (@code{const mglData &}a, @code{const char *}stl=@code{NULL}, @code{float} alpha=@code{1})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod


@c ==================================================================
@node Beam, , Cloud, 3D plotting
@subsection Beam
@cindex Beam

@deftypemethod mglGraph @code{void} Beam (@code{float} val, @code{const mglData &}tr, @code{const mglData &}g1, @code{const mglData &}g2, @code{const mglData &}a, @code{float} r, @code{const char *}stl=@code{NULL}, @code{int} flag=@code{0})
Draws the isosurface for 3d array @var{a} at constant values of @var{a}=@var{val}. This is special kind of plot for @var{a} specified in accompanied coordinates along curve @var{tr} with orts @var{g1}, @var{g2} and with transverse scale @var{r}. Variable @var{flag} is bitwise: @samp{0x1} - draw in accompanied (not laboratory) coordinates; @samp{0x2} - draw projection to @math{\rho-z} plane; @samp{0x4} - draw normalized in each slice field. The x-size of data arrays @var{tr}, @var{g1}, @var{g2} must be nx>2. The y-size of data arrays @var{tr}, @var{g1}, @var{g2} and z-size of the data array @var{a} must be equal. @xref{Surf3}.
@end deftypemethod

@deftypemethod mglGraph @code{void} Beam (@code{const mglData &}tr, @code{const mglData &}g1, @code{const mglData &}g2, @code{const mglData &}a, @code{float} r, @code{const char *}stl=@code{NULL}, @code{int} flag=@code{0}, @code{int} num=@code{3})
Draws @var{num}-th uniformly distributed in range [@var{Cmin}, @var{Cmax}] isosurfaces for 3d data specified parametrically.
@end deftypemethod



@c ##################################################################
@node Dual plotting, Vector fields, 3D plotting, MathGL core
@section Dual plotting

These plotting functions draw @emph{two matrix} simultaneously. There are 5 generally different types of data representations: surface or isosurface colored by other data (SurfC, Surf3C), surface or isosurface transpared by other data (SurfA, Surf3A), tiles with variable size (TileS), mapping diagram (Map), STFA diagram (STFA). Surf3A and Surf3C have variants for automatic and manual selection of level values for isosurfaces. Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@menu
* SurfC::                       
* Surf3C::                      
* SurfA::                       
* Surf3A::                      
* TileS::                       
* Map::                         
* STFA::                        
@end menu

@c ==================================================================
@node SurfC, Surf3C, , Dual plotting
@subsection SurfC
@cindex SurfC

@deftypemethod mglGraph @code{void} SurfC (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}c, @code{const char *}sch=@code{NULL})
The function draws surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} and color it by matrix @var{c}[i,j]. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. All dimensions of arrays @var{z} and @var{c} must be equal. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Surf}, @ref{SurfA}, @ref{Surf3C}. @sref{SurfC sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} SurfC (@code{const mglData &}z, @code{const mglData &}c, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod


@c ==================================================================
@node Surf3C, SurfA, SurfC, Dual plotting
@subsection Surf3C
@cindex Surf3C

@deftypemethod mglGraph @code{void} Surf3C (@code{float} val, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const mglData &}c, @code{const char *}stl=@code{NULL})
The function draws isosurface plot for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) at @var{a}(x,y,z)=@var{val}. It is mostly the same as Surf3() function but the color of isosurface depends on values of array @var{c}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. All dimensions of arrays @var{z} and @var{c} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). Note, that there is possibility of incorrect plotting due to uncertainty of cross-section defining if there are two or more isosurface intersections inside one cell. See also @ref{Surf3}, @ref{SurfC}, @ref{Surf3A}. @sref{Surf3C sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} Surf3C (@code{float} val, @code{const mglData &}a, @code{const mglData &}c, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod mglGraph @code{void} Surf3C (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const mglData &}c, @code{const char *}stl=@code{NULL}, @code{int} num=@code{3})
Draws @var{num}-th uniformly distributed in range [@var{Cmin}, @var{Cmax}] isosurfaces for 3d data specified parametrically.
@end deftypemethod

@deftypemethod mglGraph @code{void} Surf3C (@code{const mglData &}a, @code{const mglData &}c, @code{const char *}sch=@code{NULL}, @code{int} num=@code{3})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod


@c ==================================================================
@node SurfA, Surf3A, Surf3C, Dual plotting
@subsection SurfA
@cindex SurfA

@deftypemethod mglGraph @code{void} SurfA (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}c, @code{const char *}sch=@code{NULL})
The function draws surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} and transparent it by matrix @var{c}[i,j]. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. All dimensions of arrays @var{z} and @var{c} must be equal. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Surf}, @ref{SurfC}, @ref{Surf3A}, @ref{TileS}. @sref{SurfA sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} SurfA (@code{const mglData &}z, @code{const mglData &}c, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod


@c ==================================================================
@node Surf3A, TileS, SurfA, Dual plotting
@subsection Surf3A
@cindex Surf3A

@deftypemethod mglGraph @code{void} Surf3A (@code{float} val, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const mglData &}c, @code{const char *}stl=@code{NULL})
The function draws isosurface plot for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) at @var{a}(x,y,z)=@var{val}. It is mostly the same as Surf3() function but the transparency of isosurface depends on values of  @var{b} array. This allows one to remove the part of isosurface where @var{b} is negligibly small (useful for phase plotting of a beam or a pulse). String @var{sch} sets the color scheme. Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. All dimensions of arrays @var{z} and @var{c} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). Note, that there is possibility of incorrect plotting due to uncertainty of cross-section defining if there are two or more isosurface intersections inside one cell. See also @ref{Surf3}, @ref{SurfA}, @ref{Surf3C}. @sref{Surf3A sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} Surf3A (@code{float} val, @code{const mglData &}a, @code{const mglData &}c, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod mglGraph @code{void} Surf3A (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const mglData &}c, @code{const char *}stl=@code{NULL}, @code{int} num=@code{3})
Draws @var{num}-th uniformly distributed in range [@var{Cmin}, @var{Cmax}] isosurfaces for 3d data specified parametrically.
@end deftypemethod

@deftypemethod mglGraph @code{void} Surf3A (@code{const mglData &}a, @code{const mglData &}c, @code{const char *}sch=@code{NULL}, @code{int} num=@code{3})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node TileS, Map, Surf3A, Dual plotting
@subsection TileS
@cindex TileS

@deftypemethod mglGraph @code{void} TileS (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}r, @code{const char *}sch=@code{NULL})
The function draws horizontal tiles for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. It is mostly the same as Tile() but the size of tiles is determined by @var{r} array. This is some kind of ``transparency'' useful for exporting to EPS files. String @var{sch} sets the color scheme. Previous color scheme is used by default. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{SurfA}, @ref{Tile}. @sref{TileS sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} TileS (@code{const mglData &}z, @code{const mglData &}c, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Map, STFA, TileS, Dual plotting
@subsection Map
@cindex Map

@deftypemethod mglGraph @code{void} Map (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{NULL}, @code{int} ks=@code{0}, @code{bool} pnts=@code{true})
The function draws mapping plot for matrices @{@var{ax}, @var{ay} @} which parametrically depend on coordinates @var{x}, @var{y}. The previous position of the cell (point) is marked by color. Height is proportional to Jacobian(ax,ay). This plot is like Arnold diagram ???. If @code{pnts=false} then face is drawn otherwise the color ball at matrix knots are drawn. Parameter @var{ks} specifies the slice of matrices which will be used. String @var{sch} sets the color scheme. Previous color scheme is used by default. The size of @var{ax} and @var{ay} must be the same. The minor dimensions of arrays @var{x}, @var{y}, @var{ax} should be equal. Arrays @var{x}, @var{y} can be vectors (not matrix as @var{ax}). @xref{Color scheme}. @sref{Map sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} Map (@code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{NULL}, @code{int} ks=@code{0}, @code{bool} pnts=@code{true})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node STFA, , Map, Dual plotting
@subsection STFA
@cindex STFA

@deftypemethod mglGraph @code{void} STFA (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}re, @code{const mglData &}im, @code{int} dn, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
Draws spectrogram of complex array @var{re}+i*@code{im} for Fourier size of @var{dn} points at plane @var{z=zVal}. Parameter @var{dn} is arbitrary even integer. For example in 1D case, result is density plot of data @math{res[i,j]=|\sum_d^dn exp(I*j*d)*(re[i*dn+d]+I*im[i*dn+d])|/dn} with size @{int(nx/dn), dn, ny@}. At this array @var{re}, @var{im} parametrically depend on coordinates @var{x}, @var{y}. String @var{sch} sets the color scheme. Previous color scheme is used by default. The size of @var{re} and @var{im} must be the same. The minor dimensions of arrays @var{x}, @var{y}, @var{re} should be equal. Arrays @var{x}, @var{y} can be vectors (not matrix as @var{re}). @xref{Color scheme}.
@end deftypemethod

@deftypemethod mglGraph @code{void} STFA (@code{const mglData &}re, @code{const mglData &}im, @code{int} dn, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod


@c ##################################################################
@node Vector fields, Other plotting, Dual plotting, MathGL core
@section Vector fields

These functions perform plotting of 2D and 3D vector fields. There are 5 generally different types of vector fields representations: simple vector field (Vect, VectL), vector field with coloring (VectC), vector field by dew-drops (Dew), flow threads (Flow), flow pipes (Pipe). Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@menu
* Vect::                        
* VectL::                       
* VectC::                       
* Dew::                         
* Flow::                        
* Pipe::                        
@end menu

@c ==================================================================
@node Vect, VectL, , Vector fields
@subsection Vect
@cindex Vect

@deftypemethod mglGraph @code{void} Vect (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws plane vector field plot for the field @{@var{ax}, @var{ay}@} depending parametrically on coordinates @var{x}, @var{y} at level @var{z=zVal}. The length and color of arrows are proportional to @math{\sqrt@{ax^2+ay^2@}}. The number of arrows depend on @var{MeshNum} (@pxref{Other settings}). The color is specified by the string argument @var{sch}. Previous color scheme is used by default. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also @ref{VectL}, @ref{VectC}, @ref{Flow}, @ref{Dew}. @sref{Vect sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} Vect (@code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod mglGraph @code{void} Vect (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{NULL})
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the length and color of arrows is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. @sref{Vect 3D sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} Vect (@code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node VectL, VectC, Vect, Vector fields
@subsection VectL
@cindex VectL

@deftypemethod mglGraph @code{void} VectL (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws plane vector field plot for the field @{@var{ax}, @var{ay}@} depending parametrically on coordinates @var{x}, @var{y} at level @var{z=zVal}. The length of hachures is proportional to @math{\sqrt@{ax^2+ay^2@}}. The number of hachures depend on @var{MeshNum} (@pxref{Other settings}). Points are denote the start of hachures. The color is specified by the string argument @var{sch}. Previous color scheme is used by default. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also @ref{Vect}, @ref{VectC}, @ref{Flow}, @ref{Dew}. @sref{VectL sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} VectL (@code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod mglGraph @code{void} VectL (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{NULL})
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the length of hachures is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. @sref{VectL 3D sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} VectL (@code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node VectC, Dew, VectL, Vector fields
@subsection VectC
@cindex VectC

@deftypemethod mglGraph @code{void} VectC (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws plane vector field plot for the field @{@var{ax}, @var{ay}@} depending parametrically on coordinates @var{x}, @var{y} at level @var{z=zVal}. The color of hachures is proportional to @math{\sqrt@{ax^2+ay^2@}}. The number of hachures depend on @var{MeshNum} (@pxref{Other settings}). Points are denote the start of hachures. The color is specified by the string argument @var{sch}. Previous color scheme is used by default. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also @ref{Vect}, @ref{VectL}, @ref{Flow}, @ref{Dew}.  @sref{VectC sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} VectC (@code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod mglGraph @code{void} VectC (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{NULL})
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the color of hachures is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. @sref{VectC 3D sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} VectC (@code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Dew, Flow, VectC, Vector fields
@subsection Dew
@cindex Dew

@deftypemethod mglGraph @code{void} Dew (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws dew-drops for plane vector field @{@var{ax}, @var{ay}@} depending parametrically on coordinates @var{x}, @var{y} at level @var{z=zVal}. Note that this is very expensive plot in memory usage and creation time! The color of drops is proportional to @math{\sqrt@{ax^2+ay^2@}}. The number of drops depend on @var{MeshNum} (@pxref{Other settings}). The color is specified by the string argument @var{sch}. Previous color scheme is used by default. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also @ref{Vect}, @ref{VectC}. @sref{Dew sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} Dew (@code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod


@c ==================================================================
@node Flow, Pipe, Dew, Vector fields
@subsection Flow
@cindex Flow

@deftypemethod mglGraph @code{void} Flow (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{NULL}, @code{int} num=@code{5}, @code{bool} central=@code{true}, @code{float} zVal=@code{NAN})
The function draws flow threads for the plane vector field @{@var{ax}, @var{ay}@} parametrically depending on coordinates @var{x}, @var{y} at level z = @var{zVal}. Number of threads is proportional to @var{num}. Parameter @var{central} sets the thread start from center (if true) or only from edges (if false). The color of lines is proportional to @math{\sqrt@{ax^2+ay^2@}}. Warm color corresponds to normal flow (like attractor). Cold one corresponds to inverse flow (like source). String @var{sch} sets the color scheme. Previous color scheme is used by default. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also @ref{Pipe}, @ref{VectC}, @ref{Vect}. @sref{Flow sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} Flow (@code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{NULL}, @code{int} num=@code{5}, @code{bool} central=@code{true}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod mglGraph @code{void} Flow (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{NULL}, @code{int} num=@code{3}, @code{bool} central=@code{true})
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the color of line is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. @sref{Flow 3D sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} Flow (@code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{NULL}, @code{int} num=@code{3}, @code{bool} central=@code{true})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod


@c ==================================================================
@node Pipe, , Flow, Vector fields
@subsection Pipe
@cindex Pipe

@deftypemethod mglGraph @code{void} Pipe (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{NULL}, @code{float} r0=@code{0.05}, @code{int} num=@code{5}, @code{bool} central=@code{true}, @code{float} zVal=@code{NAN})
The function draws flow pipes for the plane vector field @{@var{ax}, @var{ay}@} parametrically depending on coordinates @var{x}, @var{y} at level z = @var{zVal}. Number of pipes is proportional to @var{num}. Parameter @var{central} sets the pipe start from center (if true) or only from edges (if false). The color of lines is proportional to @math{\sqrt@{ax^2+ay^2@}}. Warm color corresponds to normal flow (like attractor). Cold one corresponds to inverse flow (like source). String @var{sch} sets the color scheme. Previous color scheme is used by default. Parameter @var{r0} set the base pipe radius. If @var{r0}<0 then pipe radius is inverse proportional to amplitude. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also @ref{Pipe}, @ref{VectC}, @ref{Vect}. @sref{Pipe sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} Pipe (@code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{NULL}, @code{float} r0=@code{0.05}, @code{int} num=@code{5}, @code{bool} central=@code{true}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod mglGraph @code{void} Pipe (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{NULL}, @code{float} r0=@code{0.05}, @code{int} num=@code{3}, @code{bool} central=@code{true})
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the color of line is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. @sref{Pipe 3D sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} Pipe (@code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{NULL}, @code{float} r0=@code{0.05}, @code{int} num=@code{3}, @code{bool} central=@code{true})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod


@c ##################################################################
@node Other plotting, Nonlinear fitting, Vector fields, MathGL core
@section Other plotting

These functions perform miscelaneous plotting. There is unstructured data points plots (Dots), surface reconstruction (Crust), surfaces on the triangular mesh (TriPlot), textual formula plotting (Plots by formula), data plots at edges (Dens[XYZ], Cont[XYZ], ContF[XYZ]), simple plot (SimplePlot). Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@menu
* DensXYZ::                     
* ContXYZ::                     
* ContFXYZ::                    
* Dots::                        
* Crust::                       
* TriPlot::                     
* Plots by formula::            
* SimplePlot::                  
@end menu

@c ==================================================================
@node DensXYZ, ContXYZ, , Other plotting
@subsection DensXYZ
@cindex DensX
@cindex DensY
@cindex DensZ

These plotting functions draw density plot in x, y, or z plain. If @var{a} is a tensor (3-dimensional data) then interpolation to a given @var{sVal} is performed. These functions are useful for creating projections of the 3D data array to the bounding box. For example, code like
@example
gr->DensX(c.Sum("x"),"BbcyrR",-1);
gr->DensY(c.Sum("y"),0,1);
gr->DensZ(c.Sum("z"),0,-1);
@end example
will produce the following picture. See also @ref{ContXYZ}, @ref{ContFXYZ}, @ref{Dens}. @sref{Dens projection sample}

@deftypemethod mglGraph @code{void} DensX (@code{const mglData &}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN})
Draws density plot for data @var{a} at x = @var{sVal}.
@end deftypemethod

@deftypemethod mglGraph @code{void} DensY (@code{const mglData &}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN})
Draws density plot for data @var{a} at y = @var{sVal}.
@end deftypemethod

@deftypemethod mglGraph @code{void} DensZ (@code{const mglData &}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN})
Draws density plot for data @var{a} at z = @var{sVal}.
@end deftypemethod

@c ==================================================================
@node ContXYZ, ContFXYZ, DensXYZ, Other plotting
@subsection ContXYZ
@cindex ContX
@cindex ContY
@cindex ContZ

These plotting functions draw density plot in x, y, or z plain. If @var{a} is a tensor (3-dimensional data) then interpolation to a given @var{sVal} is performed. These functions are useful for creating projections of the 3D data array to the bounding box. For example, code like
@example
gr->ContX(c.Sum("x"),"BbcyrR",-1);
gr->ContY(c.Sum("y"),0,1);
gr->ContZ(c.Sum("z"),0,-1);
@end example
will produce the following picture. See also @ref{ContFXYZ}, @ref{DensXYZ}, @ref{Cont}. @sref{Cont projection sample}

@deftypemethod mglGraph @code{void} ContX (@code{const mglData &}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN}, @code{int} num=@code{7})
Draws @var{num}-th contour lines for data @var{a} at x = @var{sVal}.
@end deftypemethod

@deftypemethod mglGraph @code{void} ContY (@code{const mglData &}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN}, @code{int} num=@code{7})
Draws @var{num}-th contour lines for data @var{a} at y = @var{sVal}.
@end deftypemethod

@deftypemethod mglGraph @code{void} ContZ (@code{const mglData &}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN}, @code{int} num=@code{7})
Draws @var{num}-th contour lines for data @var{a} at z = @var{sVal}.
@end deftypemethod

@deftypemethod mglGraph @code{void} ContX (@code{const mglData &}v, @code{const mglData &}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN})
Draws contour lines for data @var{a}=@var{v}[i] at x = @var{sVal}.
@end deftypemethod

@deftypemethod mglGraph @code{void} ContY (@code{const mglData &}v, @code{const mglData &}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN})
Draws contour lines for data @var{a}=@var{v}[i] at y = @var{sVal}.
@end deftypemethod

@deftypemethod mglGraph @code{void} ContZ (@code{const mglData &}v, @code{const mglData &}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN})
Draws contour lines for data @var{a}=@var{v}[i] at z = @var{sVal}.
@end deftypemethod

@c ==================================================================
@node ContFXYZ, Dots, ContXYZ, Other plotting
@subsection ContFXYZ
@cindex ContFX
@cindex ContFY
@cindex ContFZ

These plotting functions draw density plot in x, y, or z plain. If @var{a} is a tensor (3-dimensional data) then interpolation to a given @var{sVal} is performed. These functions are useful for creating projections of the 3D data array to the bounding box. See also @ref{ContXYZ}, @ref{DensXYZ}, @ref{ContF}.

@deftypemethod mglGraph @code{void} ContFX (@code{const mglData &}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN}, @code{int} num=@code{7})
Draws @var{num}-th solid contours for data @var{a} at x = @var{sVal}.
@end deftypemethod

@deftypemethod mglGraph @code{void} ContFY (@code{const mglData &}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN}, @code{int} num=@code{7})
Draws @var{num}-th solid contours for data @var{a} at y = @var{sVal}.
@end deftypemethod

@deftypemethod mglGraph @code{void} ContFZ (@code{const mglData &}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN}, @code{int} num=@code{7})
Draws @var{num}-th solid contours for data @var{a} at z = @var{sVal}.
@end deftypemethod

@deftypemethod mglGraph @code{void} ContFX (@code{const mglData &}v, @code{const mglData &}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN})
Draws solid contours for data @var{a}=@var{v}[i] at x = @var{sVal}.
@end deftypemethod

@deftypemethod mglGraph @code{void} ContFY (@code{const mglData &}v, @code{const mglData &}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN})
Draws solid contours for data @var{a}=@var{v}[i] at y = @var{sVal}.
@end deftypemethod

@deftypemethod mglGraph @code{void} ContFZ (@code{const mglData &}v, @code{const mglData &}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN})
Draws solid contours for data @var{a}=@var{v}[i] at z = @var{sVal}.
@end deftypemethod

@c ==================================================================
@node Dots, Crust, ContFXYZ, Other plotting
@subsection Dots
@cindex Dots

@deftypemethod mglGraph @code{void} Dots (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{NULL})
@deftypemethodx mglGraph @code{void} Dots (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}sch=@code{NULL})
The function draws the arbitrary placed points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If array @var{a} is specified then it define the transparency of dots. Arrays @var{x}, @var{y}, @var{z}, @var{a} must have equal sizes. See also @ref{Crust}, @ref{Mark}, @ref{Plot}. @sref{Dots sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} Dots (@code{const mglData &}tr, @code{const char *}sch=@code{NULL})
The same as previous with @var{x=tr}(0,:), @var{y=tr}(1,:), @var{z=tr}(2,:) and if @var{tr}.nx>3 then @var{a=tr}(3,:).
@end deftypemethod

@c ==================================================================
@node Crust, TriPlot, Dots, Other plotting
@subsection Crust
@cindex Crust

@deftypemethod mglGraph @code{void} Crust (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{NULL}, @code{float} er=@code{0})
The function reconstruct and draws the surface for arbitrary placed points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. Parameter @var{er} set relative radius for (increase it for removing holes). String @var{sch} sets the color scheme. Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. Arrays @var{x}, @var{y}, @var{z} must have equal sizes. See also @ref{Dots}, @ref{TriPlot}. @sref{Crust sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} Crust (@code{const mglData &}tr, @code{const char *}sch=@code{NULL}, @code{float} er=@code{0})
The same as previous with @var{x=tr}(0,:), @var{y=tr}(1,:), @var{z=tr}(2,:).
@end deftypemethod

@c ==================================================================
@node TriPlot, Plots by formula,  Crust, Other plotting
@subsection TriPlot
@cindex TriPlot

@deftypemethod mglGraph @code{void} TriPlot (@code{const mglData &}id, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}c, @code{const char *}sch=@code{NULL})
@deftypemethodx mglGraph @code{void} TriPlot (@code{const mglData &}id, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{NULL})
The function draws the surface of triangles. Triangle vertexes are set by indexes @var{id} of data points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. First dimensions of @var{id} must be 3 or greater. Arrays @var{x}, @var{y}, @var{z} must have equal sizes. Parameter @var{c} set the colors of triangles (if @var{id}.ny=@var{c}.nx) or colors of vertexes (if @var{x}.nx=@var{c}.nx). See also @ref{Dots}, @ref{Crust}.
@end deftypemethod

@deftypemethod mglGraph @code{void} TriPlot (@code{const mglData &}id, @code{const mglData &}x, @code{const mglData &}y, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The same as previous with @var{z}[i]=@var{zVal}.
@end deftypemethod

@c ==================================================================
@node Plots by formula, SimplePlot, TriPlot, Other plotting
@subsection Plots by formula
@cindex Plot
@cindex Surf

These functions perform plotting of 1D or 2D functions specified by textual formula. You do not need to create the data arrays to plot it. The parameter @var{stl} set the line style (@pxref{Line styles}) for @code{Plot()} or color scheme (@pxref{Color scheme}) for @code{Surf()}. The parameter @var{n} set the minimal number of points along coordinate(s) for plots. At this time (v. 1.7) there is no adaptive increase of data points numbers but in future it will appear.

@deftypemethod mglGraph @code{void} Plot (@code{const char *}eqY, @code{const char *}stl=@code{NULL}, @code{float} zVal=@code{NAN}, @code{int} n=@code{100})
The function draws function @samp{eqY(x)} at plane z=@var{zVal} where @samp{x} variable is changed in range [@var{Min}.x, @var{Max}.x]. See also @ref{Plot}.
@end deftypemethod

@deftypemethod mglGraph @code{void} Plot (@code{const char *}eqX, @code{const char *}eqY, @code{const char *}eqZ, @code{const char *}stl=@code{NULL}, @code{float} zVal=@code{NAN}, @code{int} n=@code{100})
The function draws parametrical curve @{@samp{eqX(t)}, @samp{eqY(t)}, @samp{eqZ(t)}@} where @samp{t} variable is changed in range [0, 1]. See also @ref{Plot}.
@end deftypemethod

@deftypemethod mglGraph @code{void} Surf (@code{const char *}eqZ, @code{const char *}stl=@code{NULL}, @code{int} n=@code{100});
The function draws surface for function @samp{eqY(x,y)} where @samp{x}, @samp{y} variables are changed in range [@var{Min}, @var{Max}]. See also @ref{Surf}.
@end deftypemethod

@deftypemethod mglGraph @code{void} Surf (@code{const char *}eqX, @code{const char *}eqY, @code{const char *}eqZ, @code{const char *}stl=@code{NULL}, @code{int} n=@code{100})
The function draws parametrical surface @{@samp{eqX(u,v)}, @samp{eqY(u,v)}, @samp{eqZ(u,v)}@} where @samp{u}, @samp{v} variables are changed in range [0, 1]. See also @ref{Surf}.
@end deftypemethod

@c ==================================================================
@node SimplePlot, , Plots by formula, Other plotting
@subsection SimplePlot
@cindex SimplePlot

@deftypemethod mglGraph @code{void} SimplePlot (@code{const mglData &}a, @code{int} type=@code{0}, @code{const char *}stl=@code{NULL})
Plots the array @var{a} depending on it's dimensions and @var{type} parameter. String @var{stl} specifies the style of plotting. For 1d data: @code{type=0} -- @ref{Plot}, @code{type=1} -- @ref{Area}, @code{type=2} -- @ref{Step}, @code{type=3} -- @ref{Stem}, @code{type=4} -- @ref{Bars}. For 2d data: @code{type=0} -- @ref{Surf}, @code{type=1} -- @ref{Dens}, @code{type=2} -- @ref{Mesh}, @code{type=3} -- @ref{Cont}. For 3d data: @code{type=0} -- @ref{Surf3}, @code{type=1} -- @ref{Dens3}, @code{type=2} -- @ref{Cont3}, @code{type=2} -- @ref{Cloud}.
@end deftypemethod

@c ##################################################################
@node Nonlinear fitting, Frames/Animation, Other plotting, MathGL core
@section Nonlinear fitting
@cindex Fit
@cindex FitS
@cindex PutsFit
@cindex FitPnts
@cindex Fit2
@cindex Fit3

These functions fit data to formula. Fitting goal is to find formula parameters for the best fit the data points, i.e. to minimize the sum @math{\sum_i (f(x_i, y_i, z_i) - a_i)^2/s_i^2}. At this, approximation function @samp{f} can depend only on one argument @samp{x} (1D case), on two arguments @samp{x,y} (2D case) and on three arguments @samp{x,y,z} (3D case). The function @samp{f} also may depend on parameters. Normally the list of fitted parameters is specified by @var{var} string (like, @samp{abcd}). Usually user should supply initial values for fitted parameters by @var{ini} variable. But if he/she don't supply it then the zeros are used. Parameter @var{print}=@code{true} switch on printing the found coefficients to @var{Message} (@pxref{Error handling}).

Functions Fit() and FitS() do not draw the obtained data themselves. They fill the data @var{fit} by formula @samp{f} with found coefficients and return the @math{\chi^2} error of approximation. At this, the @samp{x,y,z} coordinates are equidistantly distributed in the interval @var{Min}--@var{Max}. Number of points in @var{fit} is selected as maximal value of @var{fit} size and the value of @var{FitPnts}. Note, that this functions use GSL library and do something only if MathGL was compiled with GSL support. @sref{Fitting sample}

@deftypemethod mglGraph @code{float} FitS (@code{mglData &}fit, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const mglData &}s, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx mglGraph @code{float} FitS (@code{mglData &}fit, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const mglData &}s, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{bool} print=@code{false})
Fit data along x-, y- and z-directions for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]).
@end deftypemethod

@deftypemethod mglGraph @code{float} FitS (@code{mglData &}fit, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}a, @code{const mglData &}s, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx mglGraph @code{float} FitS (@code{mglData &}fit, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}a, @code{const mglData &}s, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{bool} print=@code{false})
Fit data along x-, and y-directions for 2d array specified parametrically @var{a}[i,j](@var{x}[i,j], @var{y}[i,j]) for each data slice.
@end deftypemethod

@deftypemethod mglGraph @code{float} FitS (@code{mglData &}fit, @code{const mglData &}x, @code{const mglData &}a, @code{const mglData &}s, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx mglGraph @code{float} FitS (@code{mglData &}fit, @code{const mglData &}x, @code{const mglData &}a, @code{const mglData &}s, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{bool} print=@code{false})
Fit data along x-direction for 1d array specified parametrically @var{a}[i](@var{x}[i]) for each data slice.
@end deftypemethod

@deftypemethod mglGraph @code{float} FitS (@code{mglData &}fit, @code{const mglData &}a, @code{const mglData &}s, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx mglGraph @code{float} FitS (@code{mglData &}fit, @code{const mglData &}a, @code{const mglData &}s, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{bool} print=@code{false})
Fit data along x-direction for 1d array with @var{x} equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@deftypemethod mglGraph @code{float} Fit (@code{mglData &}fit, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx mglGraph @code{float} Fit (@code{mglData &}fit, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{bool} print=@code{false})
Fit data along x-, y- and z-directions for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) with @var{s}[i,j,k]=1.
@end deftypemethod

@deftypemethod mglGraph @code{float} Fit (@code{mglData &}fit, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx mglGraph @code{float} Fit (@code{mglData &}fit, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{bool} print=@code{false})
Fit data along x-, and y-directions for 2d array specified parametrically @var{a}[i,j](@var{x}[i,j], @var{y}[i,j]) with @var{s}[i,j]=1 for each data slice.
@end deftypemethod

@deftypemethod mglGraph @code{float} Fit (@code{mglData &}fit, @code{const mglData &}x, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx mglGraph @code{float} Fit (@code{mglData &}fit, @code{const mglData &}x, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{bool} print=@code{false})
Fit data along x-direction for 1d array specified parametrically @var{a}[i](@var{x}[i]) with @var{s}[i]=1 for each data slice.
@end deftypemethod

@deftypemethod mglGraph @code{float} Fit (@code{mglData &}fit, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx mglGraph @code{float} Fit (@code{mglData &}fit, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{bool} print=@code{false})
Fit data along x-direction for 1d array @var{a} with @var{s}=1 and @var{x} equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@deftypemethod mglGraph @code{float} Fit2 (@code{mglData &}fit, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx mglGraph @code{float} Fit2 (@code{mglData &}fit, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{bool} print=@code{false})
Fit data along x-, and y-directions for 2d array @var{a} with @var{s}=1 and @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod mglGraph @code{float} Fit3 (@code{mglData &}fit, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx mglGraph @code{float} Fit3 (@code{mglData &}fit, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{bool} print=@code{false})
Fit data along x-, y- and z-directions for 3d array @var{a} with @var{s}=1 and @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod mglGraph @code{void} PutsFit (@code{mglPoint} p, @code{const char *}prefix=@code{NULL}, @code{const char *}font=@code{NULL}, @code{float} size=@code{-1})
Print last fitted formula with found coefficients (as numbers) at position @var{p0}. The string @var{prefix} will be printed before formula. All other parameters are the same as in @ref{Text printing}.
@end deftypemethod

@deftypecv {General option} mglGraph @code{int} FitPnts
Minimal number of points for output array after nonlinear fitting.
@end deftypecv

@c ##################################################################
@node Frames/Animation, IDTF functions, Nonlinear fitting, MathGL core
@section Frames/Animation
@cindex NewFrame
@cindex EndFrame
@cindex GetNumFrame

These functions provide ability to create several pictures simultaneously. For most of cases it is useless but for widget classes (@pxref{Widget classes}) they can provide a way to show animation. Also you can write several frames into animated GIF file.

@deftypemethod mglGraph @code{int} NewFrame ()
Creates new frame. Function returns current frame id. This is not thread safe function in OpenGL mode! Use direct list creation in multi-threading drawing. The function @code{EndFrame()} @strong{must} be call after the  finishing of the frame drawing for each call of this function.
@end deftypemethod

@deftypemethod mglGraph @code{void} EndFrame ()
Finishes the frame drawing.
@end deftypemethod

@deftypemethod mglGraph @code{int} GetNumFrame ()
Gets the number of created frames.
@end deftypemethod

@deftypemethod mglGraph @code{void} ResetFrames ()
Reset frames counter (start it from zero).
@end deftypemethod

@deftypemethod mglGraph @code{void} StartGIF (@code{const char *}fname, @code{int} ms=@code{100})
Start writing frames into animated GIF file @var{fname}. Parameter @var{ms} set the delay between frames in milliseconds. You @strong{should not} change the picture size during writing the cinema. Use CloseGIF() to finalize writing. Note, that this function is disabled in OpenGL mode.
@end deftypemethod

@deftypemethod mglGraph @code{int} CloseGIF ()
Finish writing animated GIF and close connected pointers.
@end deftypemethod

@c ##################################################################
@node IDTF functions, , Frames/Animation, MathGL core
@section IDTF functions
@cindex NewFrame
@cindex EndFrame
@cindex GetNumFrame

These functions provide IDTF specific features. In all other cases they do nothing.

@deftypemethod mglGraph @code{void} VertexColor (@code{bool} enable)
Enables smooth color change.
@end deftypemethod

@deftypemethod mglGraph @code{void} Compression (@code{bool} enable)
Gives smaller files, but quality degrades.
@end deftypemethod

@deftypemethod mglGraph @code{void} StartGroup (const char *name)
Starts group definition. Groups contain objects and other groups, they are used to select a part of a model to zoom to or to make invizible or to make transparent and so on.
@end deftypemethod

@deftypemethod mglGraph @code{void} EndGroup ()
Ends group definition.
@end deftypemethod

