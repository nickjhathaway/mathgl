@c ------------------------------------------------------------------
@node Python interface, MGL interface, C interface, Top
@chapter Python interface
@cindex mglGraph

MathGL provide the interface to a set of languages via SWIG library. Some of these languages support classes. The typical example is Python -- which is denoted in the chapter title.

To use Python classes just execute @samp{import mathgl}. The simplest example will be:
@verbatim
import mathgl
a=mathgl.mglGraph()
a.Box()
a.WritePNG('test.png')
@end verbatim
Alternatively you can import all classes from @code{mathgl} module and easily access MathGL classes: 
@verbatim
from mathgl import *
a=mglGraph()
a.Box()
a.WritePNG('test.png')
@end verbatim
It become useful if you will create many @code{mglData} object, for example.

There are 2 classes in Python interface:
@itemize 
@item @code{mglGraph}
-- provide practically the same functionality as C++ class @code{mglGraph} (@pxref{MathGL core}). But it is not abstract class and it allows one to select at construction stage which plotter (ZB or PS and so on) will be used.
@item @code{mglData}
-- is absolutely the same class as C++ @code{mglData} (@pxref{mglData class}). But an additional feature to acess data values is added. You can use construction like this: @code{dat[i]=sth;} or @code{sth=dat[i]} at this flat representation of data is used (i.e., @var{i} can be in range 0...nx*nx*nz-1.
@c @item @code{mglParse} -- practically the same as C++ class @code{mglParse} (@pxref{mglParse class}).
@end itemize

There is main difference from C++ classes -- Python class @code{mglGraph} don't have variables (options). All corresponding features are moved to methods.
The core of MathGL Python class is @strong{mglGraph} class. It contains a lot of plotting functions for 1D, 2D and 3D plots. So most of sections is describe its methods. Its constructor have following arguments:

@defop Constructor {mglGraph (Python)} @code{} mglGraph (@code{int} kind=@code{0}, @code{int} width=@code{600}, @code{int} height=@code{400})
Create the instance of class mglGraph with specified sizes @var{width} and @var{height}. Parameter @var{type} may have following values: @samp{0} -- use @code{mglGraphZB} plotter (default), @samp{1} -- use @code{mglGraphPS} plotter, @samp{2} -- use @code{mglGraphGL} plotter, @samp{3} -- use @code{mglGraphIDTF} plotter.
@end defop

@menu
* Graphics setup (Python)::     
* Axis settings (Python)::      
* Transformation matrix (Python)::  
* Export to file (Python)::     
* Primitives drawing (Python)::  
* Text printing (Python)::      
* Axis and Colorbar (Python)::  
* Legend (Python)::             
* 1D plotting (Python)::        
* 2D plotting (Python)::        
* 3D plotting (Python)::        
* Dual plotting (Python)::      
* Vector fields (Python)::      
* Other plotting (Python)::     
* Nonlinear fitting (Python)::  
* Frames/Animation (Python)::   
@end menu

@c ##################################################################
@node Graphics setup (Python), Transformation matrix (Python), , Python interface
@section Graphics setup (Python)
@cindex MathGL setup

Functions in this group influences on overall graphics appearance. So all of them should be placed @emph{before} any actual plotting function calls.

@deftypemethod {mglGraph (Python)} @code{void} DefaultPlotParam ()
Restore initial values for all of parameters except described in @ref{Zooming (Python)}.
@end deftypemethod

@menu
* Transparency (Python)::       
* Lighting (Python)::           
* Fog (Python)::                
* Default sizes (Python)::      
* Zooming (Python)::            
* Cutting (Python)::            
* Font settings (Python)::      
* Palette and colors (Python)::  
* Other settings (Python)::     
@end menu

@c ==================================================================
@node Transparency (Python), Lighting (Python), , Graphics setup (Python)
@subsection Transparency (Python)
@cindex Alpha
@cindex AlphaDef
@cindex Transparent
@cindex TranspType

There are several functions and variables for setup transparency. The general function is @code{Alpha()} which switch on/off the transparency for overall plot. It influence only for graphics which created after @code{Alpha()} call. Variable @code{SetAlphaDef()} specify the default value of alpha-channel. You may switch off transparency of selected plot by variable @code{SetTransparent()}. Finally, variable @code{SetTranspType()} set the kind of transparency. @sref{Transparent surface sample}

@deftypemethod {mglGraph (Python)} @code{void} Alpha (@code{bool} enable)
Sets the transparency on/off. It is recommended to call this function before any plotting command. In any case it must be called before @code{Finish()} function if the last is used. Default value is transparency off. Unfortunately it switches the transparency on/off for all subplots. Use @code{SetTransparent(false)} in particular plot to disable its transparency.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetAlphaDef (@code{float} val)
Sets default value of alpha channel (transparency) for all plotting functions. Note, that OpenGL (mglGraphGL) has incorrect drawing for large values of alpha in case of several overlapping surfaces.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetTransparent (@code{bool} val)
Flag which temporary switches transparency on/off for the plot.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetTranspType (@code{int} type)
This variable set the transparency type. Normal transparency (@samp{0}) -- below things is less visible than upper ones. It does not look well in OpenGL mode (mglGraphGL) for several surfaces. Glass-like transparency (@samp{1}) -- below and upper things are commutable and just decrease intensity of light by RGB channel. Lamp-like transparency (@samp{2}) -- below and upper things are commutable and are the source of some additional light. I recommend to set @code{SetAlphaDef(0.3)} or less for lamp-like transparency.
@end deftypemethod

@c ==================================================================
@node Lighting (Python), Fog (Python), Transparency (Python), Graphics setup (Python)
@subsection Lighting (Python)
@cindex Light
@cindex Ambient

There are several functions for setup lighting. The general function is @code{Light(bool)} which switch on/off the lighting for overall plot. It influence only for graphics which created after @code{Light()} call. Generally MathGL support up to 10 independent light sources. But in OpenGL mode only 8 of light sources is used due to OpenGL limitations. The position, color, brightness of each light source can be set separately. By default only one light source is active. It is source number @code{0} with white color, located at top of the plot.

@deftypemethod {mglGraph (Python)} @code{void} Light (@code{bool} enable)
Sets the using of light on/off for overall plot. It is recommended to call this function before any plotting command. Default value is lightning off.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Light (@code{int} n, @code{bool} enable)
Switch on/off @var{n}-th light source separately.
@end deftypemethod

@deftypemethod mglGraph @code{void} AddLight (@code{int} n, @code{float} x, @code{float} y, @code{float} z, @code{char} c=@code{'w'})
The function adds a light source with identification @var{n} at position @{@var{x}, @var{y}, @var{z}@}. The color of light is defined by character @var{c} or by RGB values @{@var{r}, @var{g}, @var{b}@} (white by default). The brightness of light is @var{br} which must be in range [0,1]. Flag @var{infty}=@code{true} puts the source to infinite distance (for the faster drawing). It is recommended to call this function before any plotting command.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Ambient (@code{float} bright=@code{0.5})
Sets the brightness of ambient light. The value should be in range [0,1]. It is recommended to call this function before any plotting command.
@end deftypemethod

@c ==================================================================
@node Fog (Python), Default sizes (Python), Lighting (Python), Graphics setup (Python)
@subsection Fog (Python)
@cindex Fog

@deftypemethod {mglGraph (Python)} @code{void} Fog (@code{float} d, @code{float} dz=@code{0.25})
Function imitate a fog in the plot. Fog start from relative distance @var{dz} from view point and its density growths exponentially in depth. So that the fog influence is determined by law ~ 1-exp(-@emph{d*z}). Here @emph{z} is normalized to 1 depth of the plot. If value @var{d}=@code{0} then the fog is absent. @sref{Surface in fog sample}
@end deftypemethod

@c ==================================================================
@node Default sizes (Python), Zooming (Python), Fog (Python), Graphics setup (Python)
@subsection Default sizes (Python)
@cindex BarWidth
@cindex MarkSize
@cindex ArrowSize
@cindex BaseLineWidth
@cindex TickLen

These functions variables control the default (initial) values for most graphics parameters including sizes of markers, arrows, linewidth and so on. As any other settings these ones will influence only on plots created after the settings change.

@deftypemethod {mglGraph (Python)} @code{void} SetBarWidth ( @code{float} val)
Sets relative width of rectangles in Bars plot (@pxref{Bars}). Default value is @code{0.7}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetMarkSize (@code{float} val)
The size of marks for @ref{1D plotting}. Default value is @code{0.02}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetArrowSize (@code{float} val)
The size of arrows for @ref{1D plotting}, lines and curves (@pxref{Primitives drawing}). Default value is @code{0.03}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetBaseLineWidth (@code{float} val)
The variable define the base width for all lines. The value <1 is ignored. For values > 1 the real line width is result of multiplication of specified line width and the value of @var{BaseLineWidth}. Increase of this variables is actual for large bitmap pictures. Default value is @code{1}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetTickLen (@code{float} val)
The relative length of axis ticks. Default value is @code{0.1}. Note that subticks are @math{\sqrt@{2@}=1.41...} times smaller.
@end deftypemethod

@c ==================================================================
@node Zooming (Python), Cutting (Python), Default sizes (Python), Graphics setup (Python)
@subsection Zooming (Python)
@cindex PlotFactor
@cindex Zoom

These functions control the overall zooming of the picture (see Zoom()) or the sub-picture (see PlotFactor). Normally you can use these variables and functions for removing ``white'' spaces around a plot.

@deftypemethod {mglGraph (Python)} @code{void} SetPlotFactor (@code{float} val)
Sets the factor of plot size. It is not recommended to set it lower then 1.6. This is some anlogue of function Zoom() but applied not to overall image but for each InPlot. Use negative value to enable automatic @code{PlotFactor} selection.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Zoom (@code{float} x1, @code{float} y1, @code{float} x2, @code{float} y2)
Changes the scale of graphics that correspond to zoom in/out of the picture. After function call the current plot will be cleared and further the picture will contain plotting from its part [x1,x2]*[y1,y2]. Here picture coordinates @var{x1}, @var{x2}, @var{y1}, @var{y2} changes from 0 to 1. Attention! this settings can not be overwritten by any other functions. Use @code{Zoom(0,0,1,1)} to return default view.
@end deftypemethod

@c ==================================================================
@node Cutting (Python), Font settings (Python), Zooming (Python), Graphics setup (Python)
@subsection Cutting (Python)
@cindex Cut
@cindex CutMin
@cindex CutMax
@cindex CutOff

These functions set the condition when the points are excluded (cutted) from the drawing.

@deftypemethod {mglGraph (Python)} @code{void} SetCut (@code{bool} val)
Flag which determines how points outside bounding box are drawn. If it is @code{true} then points are excluded from plot (it is default) otherwise the points are projected to edges of bounding box.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetCutBox (@code{float} x1, @code{float} y1, @code{float} z1, @code{float} x2, @code{float} y2, @code{float} z2)
Lower and upper edge of the box in which never points are drawn. If both edges are the same (the variables are equal) then the cutting box is empty. @sref{CutMinMax sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} CutOff (@code{const char *}EqC)
Function set the cutting off condition by formula @var{EqC}. This condition determine will point be plotted or not. If value of formula is nonzero then point is omitted, otherwise it plotted. Set argument as @code{NULL} to disable cutting off condition. @sref{CutOff sample}
@end deftypemethod


@c ==================================================================
@node Font settings (Python), Palette and colors (Python), Cutting (Python), Graphics setup (Python)
@subsection Font settings (Python)
@cindex FontSize
@cindex FontDef
@cindex RotatedText
@cindex SetFont
@cindex GetFont

@deftypemethod {mglGraph (Python)} @code{void} SetFontSize (@code{float} val)
Sets the size of font for tick and axis labels. Default font size of axis labels is 1.4 times large than for tick labels.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetFontDef (@code{char *}fnt)
Sets the font specification (@pxref{Text printing (Python)}). Default is ``rC'' -- Roman font centering.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetRotatedText (@code{bool} val)
Sets to use or not text rotation along axis.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} LoadFont (@code{const char *}name, @code{const char *}path=@code{NULL})
Load font typeface from @var{path}/@var{name}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} CopyFont (@code{mglGraph *} from)
Copy font data from another @code{mglGraph} object.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} RestoreFont ()
Restore font data to default typeface.
@end deftypemethod

@c ==================================================================
@node Palette and colors (Python), Other settings (Python), Font settings (Python), Graphics setup (Python)
@subsection Pallete and colors (Python)
@cindex Pal
@cindex NumPal
@cindex SetPalette
@cindex SetScheme
@cindex SelectPen

@deftypemethod {mglGraph (Python)} @code{void} SetPalette (@code{const char *}@var{colors})
Sets the palette as selected colors. Default value is @code{"Hbgrcmyhlnqeup"} that corresponds to colors: dark gray @samp{H}, blue @samp{b}, green @samp{g}, red @samp{r}, cyan @samp{c}, magenta @samp{m}, yellow @samp{y}, gray @samp{h}, blue-green @samp{l}, sky-blue @samp{n}, orange @samp{q}, yellow-green @samp{e}, blue-violet @samp{u}, purple @samp{p}. The palette is used mostly in 1D plots (@pxref{1D plotting}) for curves which styles are not specified.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetPalColor (@code{int} n, @code{float} r, @code{float} g, @code{float} b)
Sets color for individual palette entry. Look at @code{mgl_set_palette()} function for simplified palette setting.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetPalNum (@code{int} num)
Sets the number of actual colors in palette. The value must be less then 100.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetScheme (@code{const char *}sch)
Set the color scheme for following plots. Usually this function is used internally. @xref{Color scheme}.
@end deftypemethod

@c ==================================================================
@node Other settings (Python), , Palette and colors (Python), Graphics setup (Python)
@subsection Other settings (Python)

@deftypemethod {mglGraph (Python)} @code{void} SetMeshNum (@code{int} val)
Sets approximate number of lines in Mesh(), Fall(), Grid() and also the number of hachures in Vect(), VectC(), Dew() and the number of cells in Cloud*(). By default (=0) it draws all lines/hachures/cells.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetAxialDir (@code{char} val)
Sets direction around which curve rotated in Axial() and Torus(). Default value is 'z'.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetDrawFace (@code{bool} val)
If set to @code{true} then it prevent faces drawing. It is useful for speeding up drawing (for example, during rotation and so on).
@end deftypemethod

@c ==================================================================
@node Axis settings (Python), Transformation matrix (Python), Graphics setup (Python), Python interface
@section Axis settings (Python)

These large set of functions control how the axis and ticks will be drawn. Note that there is 3-step transformation of data coordinates are performed. Firstly, coordinates are projected if @code{Cut=true} (@pxref{Cutting}), after it transformation formulas are applied, and finally the data was normalized in bounding box.

@menu
* Ranges (Python)::             
* Transformation (Python)::     
* Ticks (Python)::              
@end menu

@c ------------------------------------------------------------------
@node Ranges (Python), Transformation (Python), , Axis settings (Python)
@subsection Ranges (Python)
@cindex Axis
@cindex CAxis
@cindex XRange
@cindex YRange
@cindex ZRange
@cindex Min
@cindex Max
@cindex Cmin
@cindex Cmax
@cindex RecalcBorder
@cindex Org
@cindex AutoOrg
@cindex SetRanges
@cindex SetAutoRanges

@deftypemethod {mglGraph (Python)} @code{void} SetRanges (@code{float} x1, @code{float} x2, @code{float} y1, @code{float} y2, @code{float} z1=@code{0}, @code{float} z2=@code{0})
Sets maximal and minimal values for coordinate range (bounding box). If minimal and maximal values of the coordinate are the same then they are ignored. This function also sets @var{Cmin}=@code{Min.z} and @var{Cmax}=@code{Max.z}. This is default color range for 2d plots.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetCRange (@code{float} min, @code{float} max)
Sets values for color range. This values are used later for determining the color of the surface.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} XRange (@code{mglData} dat, @code{bool} add=@code{false})
Sets values of x-range as minimal and maximal values of data @var{a}. See also Axis().
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} YRange (@code{mglData} dat, @code{bool} add=@code{false})
Sets values of y-range as minimal and maximal values of data @var{a}. See also Axis().
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ZRange (@code{mglData} dat, @code{bool} add=@code{false})
Sets values of z-range as minimal and maximal values of data @var{a}. See also Axis().
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} CRange (@code{mglData} dat, @code{bool} add=@code{false})
Sets values of color range as minimal and maximal values of data @var{a}. See also CAxis().
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetOrigin (@code{float} x0, @code{float} y0, @code{float} z0)
Sets center of axis cross section. If one of values is NAN then MathGL library try to select optimal axis position.
@end deftypemethod

@deftypemethod mglGraph @code{void} SetAutoRanges (@code{float} x1, @code{float} x2, @code{float} y1=@code{0}, @code{float} y2=@code{0}, @code{float} z1=@code{0}, @code{float} z2=@code{0})
Sets ranges for automatic variables of plots. Function don't change the direction if minimal and maximal values are the same. For example, if y@var{y1}=@var{y2} then ranges along y-direction will not be changed (will be used previous one). Note that the automatic range become axis range after next call of [XYZ]Range() function(s).
@end deftypemethod

@c ------------------------------------------------------------------
@node Transformation (Python), Ticks (Python), Ranges (Python), Axis settings (Python)
@subsection Transformation (Python)
@cindex Axis
@cindex Ternary
@cindex fx
@cindex fy
@cindex fz

@deftypemethod {mglGraph (Python)} @code{void} SetFunc (@code{const char *}EqX, @code{const char *}EqY, @code{const char *}EqZ=@code{NULL})
Sets the transformation formulas for curvilinear coordinate. Each string should contain mathematical expression for real coordinate depending on internal coordinates x, y, z. For example, the cylindrical coordinates are introduced as @code{SetFunc("x*cos(y)", "x*sin(y)", "z");}. For removing of formulas the corresponding parameter should be @code{NULL}. Using transformation formulas will slightly slowing the program, i.e. @code{SetFunc(NULL, NULL, NULL)} is faster than @code{SetFunc("x", "y", "z")}. @xref{mglFormula class}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetCoor (@code{int} how)
Sets one of the predefined transformation formulas for curvilinear coordinate. Paramater @var{how} define the coordinates: @code{mglCartesian=0} -- Cartesian coordinates (no transformation); @code{mglPolar=1} -- Polar coordiantes @math{x_n=x*cos(y),y_n=x*sin(y), z_n=z}; @code{mglSpherical=2} -- Sperical coordinates @math{x_n=x*sin(y)*cos(z), y_n=x*sin(y)*sin(z), z_n=x*cos(y)}; @code{mglParabolic=3} -- Parabolic coordinates @math{x_n=x*y, y_n=(x*x-y*y)/2, z_n=z}; @code{mglParaboloidal=4} -- Paraboloidal coordinates @math{x_n=(x*x-y*y)*cos(z)/2, y_n=(x*x-y*y)*sin(z)/2, z_n=x*y}; @code{mglOblate=5} -- Oblate coordinates @math{x_n=cosh(x)*cos(y)*cos(z), y_n=cosh(x)*cos(y)*sin(z), z_n=sinh(x)*sin(y)}; @code{mglProlate=6} -- Prolate coordinates @math{x_n=sinh(x)*sin(y)*cos(z), y_n=sinh(x)*sin(y)*sin(z), z_n=cosh(x)*cos(y)}; @code{mglElliptic=7} -- Elliptic coordinates @math{x_n=cosh(x)*cos(y), y_n=sinh(x)*sin(y), z_n=z}; @code{mglToroidal=8} -- Toroidal coordinates @math{x_n=sinh(x)*cos(z)/(cosh(x)-cos(y)), y_n=sinh(x)*sin(z)/(cosh(x)-cos(y)), z_n=sin(y)/(cosh(x)-cos(y))}; @code{mglBispherical=9} -- Bispherical coordinates @math{x_n=sin(y)*cos(z)/(cosh(x)-cos(y)), y_n=sin(y)*sin(z)/(cosh(x)-cos(y)), z_n=sinh(x)/(cosh(x)-cos(y))}; @code{mglBipolar=10} -- Bipolar coordinates @math{x_n=sinh(x)/(cosh(x)-cos(y)), y_n=sin(y)/(cosh(x)-cos(y)), z_n=z}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Ternary (@code{bool} tern)
The function sets to draws Ternary plot. This special plot is for 3 dependent coordinates (components) @var{a}, @var{b}, @var{c} so that @var{a}+@var{b}+@var{c}=1. MathGL uses only 2 independent coordinates @var{a}=x and @var{b}=y since it is enough to plot everything. At this third coordinate z act as another parameter to produce contour lines, surfaces and so on. @sref{Ternary plot sample}
@end deftypemethod

@c ------------------------------------------------------------------
@node Ticks (Python), , Transformation (Python), Axis settings (Python)
@subsection Ticks (Python)

@cindex SetTicks
@cindex FactorPos
@cindex TuneTicks
@cindex TickStr
@cindex AdjustTicks

@deftypemethod {mglGraph (Python)} @code{void} AdjustTicks (@code{const char *}dir)
Set the ticks step, number of sub-ticks and initial ticks position to be the most human readable for the axis along direction(s) @var{dir}. Also set @var{TuneTicks}=@code{true}.
@end deftypemethod


@deftypemethod {mglGraph (Python)} @code{void} SetTicks (@code{char} dir, @code{float} d=@code{-5}, @code{int} ns=@code{0}, @code{float} org=@code{NAN})
Set the ticks step @var{d}, number of sub-ticks @var{ns} and initial ticks position @var{org} for the axis along direction @var{dir}. Variable @var{d} set step for axis ticks (if positive) or it's number on the axis range (if negative). Zero value set logarithmic ticks. If @var{org} value is NAN then value from @var{Org} is used.
@end deftypemethod

@deftypemethod mglGraph @code{void} SetTicksVal (@code{char} dir, @code{int} n, @code{float *}val, @code{char **}lbl)
@deftypemethodx mglGraph @code{void} SetTicksVal (@code{char} dir, @code{int} n, @code{float *}val, @code{wchar_t **}lbl)
Set the manual positions @var{val} and its labels @var{lbl} for @var{n}-th ticks along axis @var{dir}. The arrays @var{val} and @var{lbl} have to contain @var{n} elements. Use @code{SetTicks()} to restore automatic ticks.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetTickTemplX (@code{const char *}xtt)
@deftypemethodx {mglGraph (Python)} @code{void} SetTickTemplY (@code{const char *}ytt)
@deftypemethodx {mglGraph (Python)} @code{void} SetTickTemplZ (@code{const char *}ztt)
@deftypemethodx {mglGraph (Python)} @code{void} SetTickTemplC (@code{const char *}ctt)
@deftypemethodx {mglGraph (Python)} @code{void} SetTickTemplX (@code{const wchar_t *}xtt)
@deftypemethodx {mglGraph (Python)} @code{void} SetTickTemplY (@code{const wchar_t *}ytt)
@deftypemethodx {mglGraph (Python)} @code{void} SetTickTemplZ (@code{const wchar_t *}ztt)
@deftypemethodx {mglGraph (Python)} @code{void} SetTickTemplC (@code{const wchar_t *}ctt)
@deftypemethodx {mglGraph (Python)} @code{void} SetXTT (@code{const char *}xtt)
@deftypemethodx {mglGraph (Python)} @code{void} SetYTT (@code{const char *}ytt)
@deftypemethodx {mglGraph (Python)} @code{void} SetZTT (@code{const char *}ztt)
@deftypemethodx {mglGraph (Python)} @code{void} SetCTT (@code{const char *}ctt)
@deftypemethodx {mglGraph (Python)} @code{void} SetXTT (@code{const wchar_t *}xtt)
@deftypemethodx {mglGraph (Python)} @code{void} SetYTT (@code{const wchar_t *}ytt)
@deftypemethodx {mglGraph (Python)} @code{void} SetZTT (@code{const wchar_t *}ztt)
@deftypemethodx {mglGraph (Python)} @code{void} SetCTT (@code{const wchar_t *}ctt)
The template for x-,y-,z-axis ticks or colorbar ticks. It may contain TeX symbols also. If @var{xtt}, @var{ytt}, @var{ztt}, @var{ctt}=@code{NULL} then default template is used (in simplest case it is @samp{%.2g}) with automatic detaching of common multiplier or common component (see @var{TuneTicks}).
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetTuneTicks (@code{bool} tune, @code{float} factor_pos=@code{1.15})
Switch on/off ticks enhancing by factoring common multiplier (for small, like from 0.001 to 0.002, or large, like from 1000 to 2000, coordinate values) or common component (for narrow range, like from 0.999 to 1.000). Also set the position of common multiplier/component on the axis: =0 at minimal axis value, =1 at maximal axis value. Default value is 1.15.
@end deftypemethod


@c ##################################################################
@node Transformation matrix (Python), Export to file (Python), Axis settings (Python), Python interface
@section Transformation matrix (Python)
@cindex Aspect
@cindex Rotate
@cindex RotateN
@cindex SubPlot
@cindex InPlot
@cindex Identity
@cindex Perspective
@cindex RestoreM
@cindex View
@cindex ColumnPlot

These functions control how and where further plotting will be placed. There is a curtain order of calling of these functions for the better plot view. First one should be SubPlot() or InPlot() for specifying the place. After it a Rotate() and Aspect(). And finally any other plotting functions may be called. Alternatevely you can use ColumnPlot() for position plots in the column one by another without gap between plot axis (bounding boxes).

@deftypemethod {mglGraph (Python)} @code{void} SubPlot (@code{int} nx, @code{int} ny, @code{int} m, @code{float} dx=@code{0}, @code{float} dy=@code{0})
Puts further plotting in a @var{m}-th cell of @var{nx}*@var{ny} grid of the whole frame area. This function set off any aspects or rotations. So it should be used first for creating the subplot. From the aesthetical point of view it is not recommended to use this function with different matrices in the same frame. The position of the cell can be shifted from its default position by relative size @var{dx}, @var{dy}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} InPlot (@code{float} x1, @code{float} x2, @code{float} y1, @code{float} y2, @code{bool} rel=@code{false})
Puts further plotting in some region of the whole frame surface. This function allows one to create a plot in arbitrary place of the screen. The position is defined by rectangular coordinates [@var{x1}, @var{x2}]*[@var{y1}, @var{y2}]. The coordinates @var{x1}, @var{x2}, @var{y1}, @var{y2} are normalized to interval [0, 1]. If parameter @var{rel}=@code{true} then the relative position to current SubPlot() (or last InPlot() with @var{rel}=@code{false}) is used. This function set off any aspects or rotations. So it should be used first for creating subplot.
@end deftypemethod

@deftypemethod mglGraph @code{void} ColumnPlot (@code{int} num, @code{int} ind)
Puts further plotting in @var{ind}-th cell of column with @var{num} cells. The position is relative to previous SubPlot() call (or InPlot() with @var{rel}=@code{false}).
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Rotate (@code{float} TetX, @code{float} TetZ, @code{float} TetY=@code{0})
Rotates a further plotting relative to each axis (x, z, y) consecutively on angles @var{TetX}, @var{TetZ}, @var{TetY}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} RotateN (@code{float} Tet, @code{float} x, @code{float} y, @code{float} z)
Rotates a further plotting around vector @{x,y,z@}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Aspect (@code{float} Ax, @code{float} Ay, @code{float} Az)
Defines aspect ratio for the plot. The viewable axes will be related one to another as the ratio @var{Ax:Ay:Az}. For the best effect it should be used after Rotate() function.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Perspective (@code{float} a)
Add (switch on) the perspective to plot. The parameter @math{a ~ 1/z_@{eff@} \in [0,1)}. By default (@code{a=0}) the perspective is off.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Identity ()
Clears transformation matrix. This function clears all previous effects of Aspect(), SubPlot(), InPlot() or Rotate() functions. It is equivalent to the call of @code{InPlot(0,1,0,1)}.
@end deftypemethod


@c ##################################################################
@node Export to file (Python), Primitives drawing (Python), Transformation matrix (Python), Python interface
@section Export to file (Python)
@cindex WriteFrame
@cindex WritePNG
@cindex WritePNGSolid
@cindex WriteGIF
@cindex WriteIDTF
@cindex WriteSVG
@cindex WriteBMP
@cindex WriteEPS
@cindex WriteJPEG
@cindex SetSize
@cindex Flush
@cindex ShowImage
@cindex GetRGBA
@cindex GetRGB
@cindex GetBGRN
@cindex GetWidth
@cindex GetHeight

These functions export current view to a graphic file. The filename @var{fname} should have appropriate extension. Parameter @var{descr} gives the short description of the picture. Just now the transparency is supported in PNG and SVG files.

@deftypemethod mglGraph @code{void} WriteFrame (@code{const char *}fname=@code{NULL}, @code{const char *}descr=@code{NULL})
Exports current frame to a file @var{fname} which type is determined by the extension. Parameter @var{descr} adds description to file (can be @code{NULL}). If @var{fname}=@code{NULL} then the file @samp{frame####.jpg} is used, where @samp{####} is current frame id.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} WritePNG (@code{const char *}fname, @code{const char *}descr=@code{NULL})
Exports current frame to PNG file with transparent background. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. By default there are no description added. This function does nothing if NO_PNG is defined during compilation of MathGL library.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} WritePNGSolid (@code{const char *}fname, @code{const char *}descr=@code{NULL})
Exports current frame to PNG file with non-transparent background (usually white). Parameter @var{fname} specifies the file name, @var{descr} adds description to file. By default there are no description added. This function does nothing if NO_PNG is defined during compilation of MathGL library.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} WriteJPEG (@code{const char *}fname, @code{const char *}descr=@code{NULL})
Exports current frame to JPEG file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. By default there is no description added. This function does nothing if NO_JPEG is defined during compilation of MathGL library.
@end deftypemethod

@deftypemethod mglGraph @code{void} WriteGIF (@code{const char *}fname, @code{const char *}descr=@code{NULL})
Exports current frame to GIF file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. By default there is no description added.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} WriteBMP (@code{const char *}fname, @code{const char *}descr=@code{NULL})
Exports current frame to BMP file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. There is no compression used.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} WriteEPS (@code{const char *}fname, @code{const char *}descr=@code{NULL})
Exports current frame to EPS file. The vector representation is used if possible. So it is not recommended for the export of large data plot. It is better to use bitmap format (for example PNG or JPEG). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. By default there is no description added.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} WriteSVG (@code{const char *}fname, @code{const char *}descr=@code{NULL})
Exports current frame to SVG (Scalable Vector Graphics) file. The vector representation is used. In difference of EPS format, SVG format support transparency that allows to correctly draw half-transparent plot (like SurfA(), Surf3A(), CloudQ() or CloudP()). Note, the output file may be too large for graphic of large data array (especially for surfaces). It is better to use bitmap format (for example PNG or JPEG). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name).
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} WriteIDTF (@code{const char *}fname, @code{const char *}descr=@code{NULL})
Exports current frame to IDTF file. Later this file can be converted to U3D format. The vector representation is used. So, the output file may be too large for graphic of large data array (especially for surfaces). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name).
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ShowImage (@code{const char *}viewer=@code{"kuickshow"}, @code{bool} nowait=@code{False})
Displays the current picture using external program @var{viewer} for viewing. The function save the picture to temporary file and call @var{viewer} to display it. If @var{nowait}=@code{true} then the function return immediately (it will not wait while window will be closed).
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetSize (@code{int} width, @code{int} height)
Sets size of picture in pixels. This function @strong{must be} called before any other plotting because it completely remove picture contents.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Flush ()
Flushes the plotting commands to frame. This function may be useful if one wants to remove array before the finishing of the plot (i.e. before calling @code{Finish()}). Also call of this function separate the objects in mglGraphIDTF. Most of plots call this function internally.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{int} GetWidth ()
@deftypemethodx {mglGraph (Python)} @code{int} GetHeight ()
Gets width or height of the image.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} GetRGB (@code{char *}buf, @code{int} size)
Gets RGB bitmap of the current state of the image to the buffer @var{buf} of size @var{size}. Function do nothing if @var{size}<3*Width*Height. Format of each element of bits is: @{red, green, blue@}. Number of elements is Width*Height. Position of element @{i,j@} is [3*i + 3*Width*j].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} GetRGBA (@code{char *}buf, @code{int} size)
Gets RGBA bitmap of the current state of the image to the buffer @var{buf} of size @var{size}. Function do nothing if @var{size}<4*Width*Height. Format of each element of bits is: @{red, green, blue, alpha@}. Number of elements is Width*Height. Position of element @{i,j@} is [4*i + 4*Width*j].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} GetBGRN (@code{char *}buf, @code{int} size)
Gets RGB bitmap of the current state of the image to the buffer @var{buf} of size @var{size}. Function do nothing if @var{size}<4*Width*Height. Format of each element of bits is: @{blue, green, red, 255@}. Number of elements is Width*Height. Position of element @{i,j@} is [4*i + 4*Width*j]. This format is useful for some widget libraries like Qt.
@end deftypemethod


@c ##################################################################
@node Primitives drawing (Python), Text printing (Python), Export to file (Python), Python interface
@section Primitives drawing (Python)
@cindex Ball
@cindex Clf
@cindex Line
@cindex Curve
@cindex Glyph
@cindex Mark
@cindex Error
@cindex Face
@cindex FaceX
@cindex FaceY
@cindex FaceZ
@cindex Cone
@cindex Drop
@cindex Sphere

These functions draw some simple objects like line, point, sphere, drop, cone and so on.

@deftypemethod {mglGraph (Python)} @code{void} Clf (@code{float} r=@code{1}, @code{float} g=@code{1}, @code{float} b=@code{1})
Clear the picture and will it by color @{@var{r},@var{g},@var{b}@}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Ball (@code{float} x, @code{float} y, @code{float} z, @code{char *} col=@code{"r"})
Draws a point (ball) at position @var{p} with color @var{col}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Line (@code{float} x1, @code{float} y1, @code{float} z1, @code{float} x2, @code{float} y2, @code{float} z2, @code{char *}stl=@code{"B"}, @code{int}num=@code{2})
Draws a geodesic line (straight line in Cartesian coordinates) from point @{@var{x1},@var{y1},@var{z1}@} to @{@var{x2},@var{y2},@var{z2}@} using line style @var{stl}. Parameter @var{num} define the ``quality'' of the line. If @var{num}=@code{2} then the straight line will be drawn in all coordinate system (independently on transformation formulas (@pxref{Transformation}). Contrary, for large values (for example, =@code{100}) the geodesic line will be drawn in corresponding coordinate system (straight line in Cartesian coordinates, circle in polar coordinates and so on).
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Curve (@code{float} x1, @code{float} y1, @code{float} z1, @code{float} dx1, @code{float} dy1, @code{float} dz1, @code{float} x2, @code{float} y2, @code{float} z2, @code{float} dx2, @code{float} dy2, @code{float} dz2, @code{const char *}stl=@code{"B"}, @code{int} num=@code{100})
Draws Bezier-like curve from point @{@var{x1},@var{y1},@var{z1}@} to @{@var{x2},@var{y2},@var{z2}@} using line style @var{stl}. At this tangent is co-directed with @{@var{dx1},@var{dy1},@var{dz1}@}, @{@var{dx2},@var{dy2},@var{dz2}@} and proportional to its amplitude. Parameter @var{num} define the ``quality'' of the curve. If @var{num}=@code{2} then the straight line will be drawn in all coordinate system (independently on transformation formulas (@pxref{Transformation}). Contrary, for large values (for example, =@code{100}) the spline like Bezier curve will be drawn in corresponding coordinate system.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Face (@code{mglPoint} p1, @code{mglPoint} p2, @code{mglPoint} p3, @code{mglPoint} p4, @code{const char *}stl=@code{"w"}, @code{int} num=@code{2})
Draws the solid quadrangle (face) with vertexes @var{p1}, @var{p2}, @var{p3}, @var{p4} and with color(s) @var{stl}. At this colors can be the same for all vertexes or different if all 4 colors are specified for each vertex.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} FaceX (@code{float} x0, @code{float} y0, @code{float} z0, @code{float} wy, @code{float} wz, @code{const char *}stl=@code{"w"}, @code{float} dx=@code{0}, @code{float} dy=@code{0})
@deftypemethodx {mglGraph (Python)} @code{void} FaceY (@code{float} x0, @code{float} y0, @code{float} z0, @code{float} wx, @code{float} wz, @code{const char *}stl=@code{"w"}, @code{float} dx=@code{0}, @code{float} dy=@code{0})
@deftypemethodx {mglGraph (Python)} @code{void} FaceZ (@code{float} x0, @code{float} y0, @code{float} z0, @code{float} wx, @code{float} wy, @code{const char *}stl=@code{"w"}, @code{float} dx=@code{0}, @code{float} dy=@code{0})
Draws the solid rectangle (face) perpendicular to [x,y,z]-axis correspondingly at position @{@var{x0}, @var{y0}, @var{z0}@} with color @var{stl} and with widths @var{wx}, @var{wy}, @var{wz} along corresponding directions. At this colors can be the same for all vertexes or different if all 4 colors are specified for each vertex. Parameters @var{d1}!=0, @var{d2}!=0 set additional shift of the last vertex (i.e. to draw quadrangle).
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Sphere (@code{float} x0, @code{float} y0, @code{float} z0, @code{float} r, @code{const char *}stl=@code{"r"})
Draw the sphere with radius @var{r} and center at point @{@var{x0}, @var{y0}, @var{z0}@} and color @var{stl}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Drop (@code{float} x0, @code{float} y0, @code{float} z0, @code{float} dx, @code{float} dy, @code{float} dz, @code{float} r, @code{const char *}col="r", @code{float} shift=@code{1}, @code{float} ap=@code{1})
Draw the drop with radius @var{r} at point @var{p} elongated in direction @var{q} and with color @var{col}. Parameter @var{shift} set the degree of drop oblongness: @samp{0} is sphere, @samp{1} is maximally oblongness drop. Parameter @var{ap} set relative width of the drop (this is analogue of ``ellipticity'' for the sphere). @sref{Drops sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Cone (@code{float} x1, @code{float} y1, @code{float} z1, @code{float} x2, @code{float} y2, @code{float} z2, @code{float} r1, @code{float} r2=@code{-1}, @code{const char *}stl=@code{"B"}, @code{bool} edge=@code{false})
Draw tube (or truncated cone if @var{edge}=@code{false}) between points @{@var{x1},@var{y1},@var{z1}@}, @{@var{x2},@var{y2},@var{z2}@} with radius at the edges @var{r1}, @var{r2}. If @var{r2}<0 then it is suppsosed that @var{r2}=@var{r1}. The cone color is defined by string @var{stl}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Mark (@code{float} x, @code{float} y, @code{float} z, @code{char} mark)
Draws a marks of different type at position @{@var{x},@var{y},@var{z}@}.
@end deftypemethod

@c ##################################################################
@node Text printing (Python), Axis and Colorbar (Python), Primitives drawing (Python), Python interface
@section Text printing (Python)
@cindex Puts
@cindex Putsw
@cindex Text
@cindex Title

These functions draw the text. There are functions for drawing text in arbitrary place, in arbitrary direction and along arbitrary curve. The class mglFont (@pxref{mglFont class}) is used for low-level string parsing and printing. It can use arbitrary font-faces and parse many TeX commands. All these functions have 2 variant: for printing 8-bit text (@code{char *}) and for printing Unicode text (@code{wchar_t *}). In first case the conversion in current locale is used. So sometimes you need to specify it by @code{setlocale()} function. The size argument control the size of text: if positive it give the value, if negative it give the value relative to @var{FontSize}. The font type (STIX, arial, courier, times and so on) can be selected by function LoadFont(). @xref{Font settings (Python)}.

The font parameters are described by string. This string may contain several characters of font type (@samp{rbiwou}) and/or align (@samp{LRC}) specification. Also it may contain the text color @samp{wkrgbcymhRGBCYMHW} (@pxref{mglColor class}) after symbol @samp{:}. The font types are: @samp{r} -- roman font, @samp{i} -- italic style, @samp{b} -- bold style, @samp{w} -- wired style, @samp{o} -- over-lined text, @samp{u} -- underlined text. By default roman font is used. The align types are: @samp{L} -- align left (default), @samp{C} -- align center, @samp{R} -- align right. Also a parsing of the LaTeX-like syntax is provided (for detail @pxref{mglFont class}). For example, string @samp{iC:b} correspond to italic font style for centered text which printed by blue color.

@deftypemethod {mglGraph (Python)} @code{void} Puts (@code{float} x, @code{float} y, @code{float} z, @code{const char *}text, @code{const char *}font=@code{NULL}, @code{float} size=@code{-1}, @code{char} dir=@code{0})
@deftypemethodx {mglGraph (Python)} @code{void} Putsw (@code{float} x, @code{float} y, @code{float} z, @code{const wchar_t *}text, @code{const char *}font=@code{NULL}, @code{float} size=@code{-1}, @code{char} dir=@code{0})
The function plots the string @var{text} at position @{@var{x},@var{y},@var{z}@} with fonts specifying by the criteria @var{how}. The size of font is set by @var{size} parameter (default is @var{FontSize}). Parameter @var{dir} specifies the additional string align. The aligns are: @samp{x} -- align as x-label, @samp{y} -- align as y-label, @samp{z} -- align as z-label, @samp{i} -- align as x-label but inverse writing direction, @samp{t} -- no align (default), @samp{n} -- align in x-y plane.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Puts (@code{float} x, @code{float} y, @code{float} z, @code{float} dx, @code{float} dy, @code{float} dz, @code{const char *}text, @code{char}where=@code{'t'}, @code{float} size=@code{-1})
@deftypemethodx {mglGraph (Python)} @code{void} Putsw (@code{float} x, @code{float} y, @code{float} z, @code{float} dx, @code{float} dy, @code{float} dz, @code{const wchar_t *}text, @code{char}where=@code{'t'}, @code{float} size=@code{-1})
The function plots the string @var{text} at position @{@var{x},@var{y},@var{z}@} along direction @{@var{dx},@var{dy},@var{dz}@} with specified @var{size}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Title (@code{const char *}text, @code{const char *}font=@code{0}, @code{int} size=@code{-2})
@deftypemethodx {mglGraph (Python)} @code{void} Title (@code{const wchar_t *}text, @code{const char *}font=@code{0}, @code{int} size=@code{-2})
Print string @var{text} as title of the picture (at the top of the picture). Can be used at any place (even inside SubPlot()).
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Text (@code{mglData} y, @code{const char *}text, @code{const char *}font=@code{NULL}, float size=@code{-1})
@deftypemethodx {mglGraph (Python)} @code{void} Text (@code{mglData} y, @code{const wchar_t *}text, @code{const char *}font=@code{NULL}, float size=@code{-1})
@deftypemethodx {mglGraph (Python)} @code{void} Text (@code{mglData} x, @code{mglData} y, @code{const char *}text, @code{const char *}font=@code{NULL}, float size=@code{-1})
@deftypemethodx {mglGraph (Python)} @code{void} Text (@code{mglData} x, @code{mglData} y, @code{const wchar_t *}text, @code{const char *}font=@code{NULL}, float size=@code{-1})
@deftypemethodx {mglGraph (Python)} @code{void} Text (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{const char *}text, @code{const char *}font=@code{NULL}, float size=@code{-1})
@deftypemethodx {mglGraph (Python)} @code{void} Text (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{const wchar_t *}text, @code{const char *}font=@code{NULL}, float size=@code{-1})
The function draws @var{text} along the curve between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} by font style @var{font} and with size @var{size}. The string @var{font} may contain symbols @samp{t} for printing the text under the curve (default), or @samp{T} for printing the text above the curve. The sizes of 1st dimension must be equal for all arrays @var{x.nx=y.nx=z.nx}. If array @var{x} is not specified then its an automatic array is used with values equidistantly distributed in interval [@var{Min}.x, @var{Max}.x] (@pxref{Ranges (bounding box)}). @sref{Text sample}
@end deftypemethod

@c ##################################################################
@node Axis and Colorbar (Python), Legend (Python), Text printing (Python), Python interface
@section Axis and Colorbar (Python)
@cindex Axis
@cindex Box
@cindex Grid
@cindex Colorbar
@cindex Label

These functions draw the ``things for measuring'', like axis with ticks, colorbar with ticks, grid along axis, bounding box and labels for axis. For more information @pxref{Axis settings (Python)}.

@deftypemethod {mglGraph (Python)} @code{void} Axis (@code{const char *}dir=@code{"xyz"}, @code{bool} adjust=@code{false})
Draws axes with ticks (@pxref{Axis settings}) in directions determined by string parameter @var{dir}.If string contain the symbol @samp{_} then tick labels are not printed. Font for ticks labels is determined by @var{FontDef} (@pxref{Font settings (Python)}). Ticks will be adjusted if @var{adjust}=@code{true} (by call of @code{AdjustTicks()}).
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Colorbar (@code{const char *}sch=@code{NULL}, @code{int} where=@code{0})
Draws colorbar with color scheme @var{sch} (current scheme if @code{sch=NULL}) at edge of plot. Parameter @var{where} specifies the position of colorbar: @samp{0} - at right (default), @samp{1} - at left, @samp{2} - at top, @samp{3} - at bottom. @sref{Dens sample}
@end deftypemethod

@deftypemethod mglGraph @code{void} Colorbar (@code{const char *}sch, @code{int} where, @code{float} x, @code{float} y, @code{float} w, @code{float} h)
@deftypemethodx mglGraph @code{void} Colorbar (@code{int} where, @code{float} x, @code{float} y, @code{float} w, @code{float} h)
Draws colorbar with color scheme @var{sch} (current scheme if not specified) at arbitrary position of subplot @{@var{x}, @var{y}@} (supposed to be in range [0,1]). Parameter @var{where} specifies the position of colorbar labels: @samp{0} - at left, @samp{1} - at right, @samp{2} - at bottom, @samp{3} - at top. Parameters @var{w}, @var{h} set the relative width and height of the colorbar.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Grid (@code{const char *}dir=@code{"xyz"}, @code{const char *}pen=@code{"B-"})
Draws grid lines perpendicular to direction determined by string parameter @var{dir}. The step of grid lines is the same as tick step for an Axis(). The style of lines is determined by @var{pen} parameter (default value is dark blue solid line (@samp{B-}).
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Box (@code{const char *}col, @code{bool} ticks=@code{true})
Draws bounding box outside the plotting volume with color @var{col}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Label (@code{char} dir, @code{const char *}text, @code{int} pos=@code{+1}, @code{float} size=@code{-1.4}, @code{float} shift=@code{0})
Prints the label @var{text} for axis @var{dir}=@samp{x},@samp{y},@samp{z},@samp{t}  (here @samp{t} is ``ternary'' axis @math{t=1-x-y}). The position of label is determined by @var{pos} parameter. If @var{pos}=0 then label is printed at the center of axis. If @var{pos}>0 then label is printed at the maximum of axis. If @var{pos}<0 then label is printed at the minimum of axis. Parameter @var{size} determines the font size for the label. By default the font size is 1.4 times larger than the one for ticks @var{FontSize} (@pxref{Font settings (Python)}). @xref{Text printing}.
@end deftypemethod

@c ##################################################################
@node Legend (Python), 1D plotting (Python), Axis and Colorbar (Python), Python interface
@section Legend (Python)
@cindex Legend
@cindex AddLegend
@cindex ClearLegend

These functions draw legend to the graph (useful for @ref{1D plotting}). Legend entry is a pair of strings: one for style of the line, another one with description text (with included LaTeX parsing). The array of string may be used directly or by accumulating first to the internal arrays (by function AddLegend()) and further plotting it. The position of the legend can be selected automatic or manually. Parameters @var{font} and @var{size} specify the font style and size (@pxref{Font settings (Python)}). Parameter @var{llen} set the relative width of the line sample and the text indent. If line style string for entry is empty then the corresponding text is printed without indent. @sref{Legend sample}

@deftypemethod {mglGraph (Python)} @code{void} Legend (@code{int} where=@code{0x3}, @code{const char *}font=@code{"rL"}, @code{float} size=@code{-0.8}, @code{float} llen=@code{0.1})
Draws legend of accumulated legend entries by font @var{font} with @var{size}. Parameter @var{where} sets the position of the legend: @samp{0} is bottom left corner, @samp{1} is bottom right corner, @samp{2} is top left corner, @samp{3} is top right corner (is default).
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Legend (@code{float} x, @code{float} y, @code{const char *}font=@code{"rL"}, @code{float} size=@code{-0.8}, @code{float} llen=@code{0.1})
Draws legend of accumulated legend entries by font @var{font} with @var{size}. Position of legend is determined by parameter @var{x}, @var{y} which supposed to be normalized to interval [0,1].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} AddLegend (@code{const char *}text, @code{const char *}style)
@deftypemethodx {mglGraph (Python)} @code{void} AddLegend (@code{const wchar_t *}text, @code{const char *}style)
Adds string @var{text} to internal legend accumulator. The style of described line and mark is specified in string @var{style} (@pxref{Line styles}). Maximal number of entries is 100.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ClearLegend ()
Clears saved legend strings.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetLegendBox (@code{bool} enable)
Switch on/off drawing box near legend. By default (=@code{true}) box is drawn.
@end deftypemethod

@c ##################################################################
@node 1D plotting (Python), 2D plotting (Python), Legend (Python), Python interface
@section 1D plotting (Python)

These functions perform plotting of 1D data. 1D means that data depended from only 1 parameter like parametric curve @{x(i),y(i),z(i)@}, i=1...n. There are 5 generally different types of data representations: simple line plot (Plot), line plot with filling under it (Area), stairs plot (Step), bar plot (Bars, Barh) and vertical lines (Stem). Each type of plotting has similar interface. There are 3D version and two 2D versions. One of last requires single array. The parameters of line and marks are specified by the string argument. If the string parameter is NULL then solid line with color from palette Pal is used (@pxref{Palette and colors (Python)}). Also there are some special 1d plots having slightly different interface: surface of curve rotation (Torus), chart (Chart) and error boxes (Error), marks with variable size (Mark), tubes (Tube) and so on. @xref{Line styles}.


@menu
* Plot (Python)::               
* Tens (Python)::               
* Area (Python)::               
* Region (Python)::             
* Bars (Python)::               
* Barh (Python)::               
* Stem (Python)::               
* Step (Python)::               
* Torus (Python)::              
* Chart (Python)::              
* Mark (Python)::               
* TextMark (Python)::           
* Error (Python)::              
* Tube (Python)::               
@end menu


@c ==================================================================
@node Plot (Python), Area (Python), , 1D plotting (Python)
@subsection Plot (Python)
@cindex Plot

These functions draw continuous lines between points. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Area}, @ref{Step}, @ref{Stem}, @ref{Tube}, @ref{Mark}, @ref{Error}, @ref{Belt}, @ref{Tens}. @sref{Plot sample}

@deftypemethod {mglGraph (Python)} @code{void} Plot (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{const char *}pen=@code{NULL})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Plot (@code{mglData} x, @code{mglData} y, @code{const char *}pen=@code{NULL})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Plot (@code{mglData} y, @code{const char *}pen=@code{NULL})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@c ==================================================================
@node Tens (Python), Area (Python), Plot (Python), 1D plotting (Python)
@subsection Tens (Python)
@cindex Tens

These functions draw continuous lines between points with color defined by the special array (look like tension plot). The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color scheme (@pxref{Color scheme}) and style and/or width of line (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with current color scheme is used. See also @ref{Plot}, @ref{Mesh}, @ref{Fall}. @sref{Tens sample}

@deftypemethod {mglGraph (Python)} @code{void} Tens (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} c, @code{const char *}pen=@code{NULL})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space with color defined by @var{c}[i].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Tens (@code{mglData} x, @code{mglData} y, @code{mglData} c, @code{const char *}pen=@code{NULL})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z} with color defined by @var{c}[i].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Tens (@code{mglData} y, @code{mglData} c, @code{const char *}pen=@code{NULL})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z} with color defined by @var{c}[i], where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@c ==================================================================
@node Area (Python), Region (Python), Tens (Python), 1D plotting (Python)
@subsection Area (Python)
@cindex Area

These functions draw continuous lines between points and fills it to axis plane. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Plot}, @ref{Bars}, @ref{Stem}. @sref{Area sample}

@deftypemethod {mglGraph (Python)} @code{void} Area (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{const char *}pen=@code{NULL})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space and fills it down to @var{z} = Org.z.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Area (@code{mglData} x, @code{mglData} y, @code{const char *}pen=@code{NULL})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z} and fills it down to @var{y} = Org.y.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Area (@code{mglData} y, @code{const char *}pen=@code{NULL})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z} and fills it down to @var{y} = Org.y, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} AreaSum (@code{mglData} x, @code{mglData} y, @code{const char *}pen=@code{NULL})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z} and fills it down to @var{y} = Org.y. The lines are drawn one abover another (like summation). Note, you can reach the same effect if call @code{y.CumSum("y");} before @code{Area} plot.
@end deftypemethod

@c ==================================================================
@node Region (Python), Bars (Python), Area (Python), 1D plotting (Python)
@subsection Region (Python)
@cindex Region

These functions fill area between 2 curves. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y1.nx=y2.nx} and all dimensions of arrays @var{y1} and @var{y2} must be equal too. String @var{pen} specifies the color (@pxref{Line styles}). By default (@code{pen=NULL}) color from palette is used (@pxref{Palette and colors (Python)}). See also @ref{Area}, @ref{Bars}, @ref{Stem}. @sref{Region sample}

@deftypemethod {mglGraph (Python)} @code{void} Region (@code{mglData} x, @code{mglData} y1, @code{mglData} y2, @code{const char *}pen=@code{NULL}, @code{bool} inside=@code{true})
The function fills area between curves @{@var{x}[i], @var{y}[i]@} and @{@var{x}[i], @var{y2}[i]@}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Region (@code{mglData} y1, @code{mglData} y2, @code{const char *}pen=@code{NULL}, @code{bool} inside=@code{true})
The function fills area between curves @{@var{x}[i], @var{y}[i]@} and @{@var{x}[i], @var{y2}[i]@}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod


@c ==================================================================
@node Bars (Python), Barh (Python), Region (Python), 1D plotting (Python)
@subsection Bars (Python)
@cindex Bars

These functions draw vertical bars from points to axis plane. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Barh}, @ref{Area}, @ref{Stem}, @ref{Chart}, @ref{Default sizes}. @sref{Bars sample}

@deftypemethod {mglGraph (Python)} @code{void} Bars (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{const char *}pen=@code{NULL})
The function draws vertical bars from points @{@var{x}[i], @var{y}[i], @var{z}[i]@} down to @var{z} = Org.z.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Bars (@code{mglData} x, @code{mglData} y, @code{const char *}pen=@code{NULL})
The function draws vertical bars from points @{@var{x}[i], @var{y}[i]@} down to @var{y} = Org.y in plane @var{z}=@var{Min.z}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Bars (@code{mglData} y, @code{const char *}pen=@code{NULL})
The function draws vertical bars from points @{@var{x}[i], @var{y}[i]@} down to @var{y} = Org.y in plane @var{z}=@var{Min.z}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@c ==================================================================
@node Barh (Python), Stem (Python), Bars (Python), 1D plotting (Python)
@subsection Barh (Python)
@cindex Barh

These functions draw horizontal bars from points to axis plane. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Barh}, @ref{Default sizes}. @sref{Barh sample}

@deftypemethod {mglGraph (Python)} @code{void} Barh (@code{mglData} y, @code{mglData} v, @code{const char *}pen=@code{NULL})
The function draws horizontal bars from points @{@var{v}[i], @var{y}[i]@} down to @var{x} = Org.x in plane @var{z}=@var{Min.z}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Barh (@code{mglData} v, @code{const char *}pen=@code{NULL})
The function draws horizontal bars from points @{@var{v}[i], @var{y}[i]@} down to @var{x} = Org.x in plane @var{z}=@var{Min.z}, where @var{y}[i] values are equidistantly distributed in interval [@var{Min}.y, @var{Max}.y].
@end deftypemethod

@c ==================================================================
@node Stem (Python), Step (Python), Barh (Python), 1D plotting (Python)
@subsection Stem (Python)
@cindex Stem

These functions draw vertical lines from points to axis plane. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Area}, @ref{Bars}, @ref{Plot}. @sref{Stem sample}

@deftypemethod {mglGraph (Python)} @code{void} Stem (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{const char *}pen=@code{NULL})
The function draws vertical lines from points @{@var{x}[i], @var{y}[i], @var{z}[i]@} down to @var{z} = Org.z.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Stem (@code{mglData} x, @code{mglData} y, @code{const char *}pen=@code{NULL})
The function draws vertical lines from points @{@var{x}[i], @var{y}[i]@} down to @var{y} = Org.y in plane @var{z}=@var{Min.z}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Stem (@code{mglData} y, @code{const char *}pen=@code{NULL})
The function draws vertical lines from points @{@var{x}[i], @var{y}[i]@} down to @var{y} = Org.y in plane @var{z}=@var{Min.z}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@c ==================================================================
@node Step (Python), Torus (Python), Stem (Python), 1D plotting (Python)
@subsection Step (Python)
@cindex Step

These functions draw continuous stairs for points to axis plane. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Plot}, @ref{Stem}, @ref{Tile}, @ref{Boxs}. @sref{Step sample}

@deftypemethod {mglGraph (Python)} @code{void} Step (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{const char *}pen=@code{NULL})
The function draws continuous stairs for points @{@var{x}[i], @var{y}[i], @var{z}[i]@}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Step (@code{mglData} x, @code{mglData} y, @code{const char *}pen=@code{NULL})
The function draws continuous stairs for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Step (@code{mglData} y, @code{const char *}pen=@code{NULL})
The function draws continuous stairs for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@c ==================================================================
@node Torus (Python), Chart (Python), Step (Python), 1D plotting (Python)
@subsection Torus (Python)
@cindex Torus

These functions draw surface which is result of curve @{@var{r}, @var{z}@} rotation around @var{AxialDir} axis (@pxref{Other settings}). The sizes of 1st dimension @strong{must be equal} for all arrays @var{r.nx=z.nx}. String @var{pen} specifies the color (@pxref{Line styles}). By default (@code{pen=NULL}) color from palette is used (@pxref{Palette and colors}). See also @ref{Plot}, @ref{Axial}. @sref{Torus sample}

@deftypemethod {mglGraph (Python)} @code{void} Torus (@code{mglData} r, @code{mglData} z, @code{const char *}pen=@code{NULL})
The function draws surface which is result of curve @{@var{r}[i], @var{z}[i]@} rotation.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Torus (@code{mglData} z, @code{const char *}pen=@code{NULL})
The function draws surface which is result of curve @{@var{r}[i], @var{z}[i]@} rotation, where @var{r}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@c ==================================================================
@node Chart (Python), Mark (Python), Torus (Python), 1D plotting (Python)
@subsection Chart (Python)
@cindex Chart

@deftypemethod {mglGraph (Python)} @code{void} Chart (@code{mglData} a, @code{const char *}col=@code{NULL})
The function draws colored stripes (boxes) for data in array @var{a}. The number of stripes is equal to the number of rows in @var{a} (equal to @var{a.ny}). The color of each next stripe is cyclically changed from colors specified in string @var{col} or in palette Pal (@pxref{Palette and colors}). Spaces in colors denote transparent ``color'', i.e. if @var{col} contain space(s) then corresponding stripe(s) are not drawn. The stripe width is proportional to value of element in @var{a}. Chart is plotted only for data with non-negative elements. If string @var{col} have symbol @samp{#} then black border lines are drawn. The most nice form the chart have in 3d (after rotation of coordinates) or in cylindrical coordinates (becomes so called Pie chart). @sref{Chart sample}
@end deftypemethod

@c ==================================================================
@node Mark (Python), TextMark (Python), Chart (Python), 1D plotting (Python)
@subsection Mark (Python)
@cindex Mark

These functions draw marks with size @var{r}*@var{MarkSize} (@pxref{Default sizes}) at points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx=r.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). If you need to draw markers of the same size then you may use @ref{Plot} function. See also @ref{Plot}, @ref{TextMark}, @ref{Stem}, @ref{Error}. @sref{Mark sample}

@deftypemethod {mglGraph (Python)} @code{void} Mark (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} r, @code{const char *}pen=@code{NULL})
The function draws marks for points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Mark (@code{mglData} x, @code{mglData} y, @code{mglData} r, @code{const char *}pen=@code{NULL})
The function draws marks for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Mark (@code{mglData} y, @code{mglData} r, @code{const char *}pen=@code{NULL})
The function draws marks for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@c ==================================================================
@node TextMark (Python), Error (Python), Mark (Python), 1D plotting (Python)
@subsection TextMark (Python)
@cindex TextMark

These functions draw string @var{text} as marks with size proportional to @var{r}*@var{MarkSize} (@pxref{Default sizes}) at points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx=r.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Plot}, @ref{Mark}, @ref{Stem}. @sref{TextMark sample}

@deftypemethod {mglGraph (Python)} @code{void} TextMark (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} r, @code{const wchar_t *}text, @code{const char *}fnt=@code{NULL})
@deftypemethodx {mglGraph (Python)} @code{void} TextMark (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} r, @code{const char *}text, @code{const char *}fnt=@code{NULL})
The function draws textual marks for points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} TextMark (@code{mglData} x, @code{mglData} y, @code{mglData} r, @code{const wchar_t *}text, @code{const char *}fnt=@code{NULL})
@deftypemethodx {mglGraph (Python)} @code{void} TextMark (@code{mglData} x, @code{mglData} y, @code{mglData} r, @code{const char *}text, @code{const char *}fnt=@code{NULL})
The function draws textual marks for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} TextMark (@code{mglData} y, @code{mglData} r, @code{const wchar_t *}text, @code{const char *}fnt=@code{NULL})
@deftypemethodx {mglGraph (Python)} @code{void} TextMark (@code{mglData} y, @code{mglData} r, @code{const char *}text, @code{const char *}fnt=@code{NULL})
The function draws textual marks for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} TextMark (@code{mglData} y, @code{const wchar_t *}text, @code{const char *}fnt=@code{NULL})
@deftypemethodx {mglGraph (Python)} @code{void} TextMark (@code{mglData} y, @code{const char *}text, @code{const char *}fnt=@code{NULL})
The function draws textual marks for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x]. The mark sizes @var{r}[i]=1 for all points.
@end deftypemethod

@c ==================================================================
@node Error (Python), Tube (Python), TextMark (Python), 1D plotting (Python)
@subsection Error (Python)
@cindex Error

These functions draw error boxes at points @{@var{x}[i], @var{y}[i]@} on plane @var{z} = @var{Min.z}. This can be useful, for example, in experimental points, or to show numeric error or some estimations and so on. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx=r.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Plot}. @sref{Error sample}

@deftypemethod {mglGraph (Python)} @code{void} Error (@code{mglData} x, @code{mglData} y, @code{mglData} ex, @code{mglData} ey, @code{const char *}pen=@code{NULL})
Draws a error box @{@var{ex}, @var{ey}@} in point position @{@var{x}, @var{y}@}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Error (@code{mglData} x, @code{mglData} y, @code{mglData} ey, @code{const wchar_t *}pen=@code{NULL})
Draws a error box @var{ey} (along only one direction) in point position @{@var{x}, @var{y}@}.
@end deftypemethod
@deftypemethod {mglGraph (Python)} @code{void} Error (@code{mglData} y, @code{mglData} ey, @code{const char *}pen=@code{NULL})
Draws a error box @var{ey} (along only one direction) in point position @{@var{x}, @var{y}@}, where @var{x} values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@c ==================================================================
@node Tube (Python), , Error (Python), 1D plotting (Python)
@subsection Tube (Python)
@cindex Tube

These functions draw the tube with variable radius @var{r}[i] along the curve between points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx=r.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Plot}. @sref{Tube sample}

@deftypemethod {mglGraph (Python)} @code{void} Tube (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} r, @code{const char *}pen=@code{NULL})
@deftypemethodx {mglGraph (Python)} @code{void} Tube (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{float} r, @code{const char *}pen=@code{NULL})
The function draws tube with radius @var{r} between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Tube (@code{mglData} x, @code{mglData} y, @code{mglData} r, @code{const char *}pen=@code{NULL})
@deftypemethodx {mglGraph (Python)} @code{void} Tube (@code{mglData} x, @code{mglData} y, @code{float} r, @code{const char *}pen=@code{NULL})
The function draws tube with radius @var{r} between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Tube (@code{mglData} y, @code{mglData} r, @code{const char *}pen=@code{NULL})
@deftypemethodx {mglGraph (Python)} @code{void} Tube (@code{mglData} y, @code{float} r, @code{const char *}pen=@code{NULL})
The function draws tube with radius @var{r} between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@c ##################################################################
@node 2D plotting (Python), 3D plotting (Python), 1D plotting (Python), Python interface
@section 2D plotting (Python)

These functions perform plotting of 2D data. 2D means that data depend from 2 independent parameters like matrix @math{f(x_i,y_j), i=1...n, j=1...m}. There are 6 generally different types of data representations: simple mesh lines plot (Mesh), surface plot (Surf), surface plot by boxes (Boxs), surface plot by tiles (Tile), waterfall-like plot (Fall), belt plot (Belt), density plot (Dens), contour lines plot (Cont), solid contours plot (ContF) and its rotational figure (Axial). Cont, ContF and Axial functions have variants for automatic and manual selection of level values for contours. Also there are functions for plotting data grid lines according to the data format (Grid) for enhancing density or contour plots. Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@menu
* Mesh (Python)::               
* Fall (Python)::               
* Belt (Python)::               
* Surf (Python)::               
* Boxs (Python)::               
* Tile (Python)::               
* Dens (Python)::               
* Cont (Python)::               
* ContF (Python)::              
* Axial (Python)::              
* Grid (Python)::               
@end menu

@c ==================================================================
@node Mesh (Python), Fall (Python), , 2D plotting (Python)
@subsection Mesh (Python)
@cindex Mesh

@deftypemethod {mglGraph (Python)} @code{void} Mesh (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{const char *}sch=@code{NULL})
The function draws mesh lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Mesh lines are plotted for each z slice of the data. See also @ref{Surf}, @ref{Fall}, NeshNum (@pxref{Other settings}), @ref{Cont}, @ref{Tens}. @sref{Mesh sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Mesh (@code{mglData} z, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Fall (Python), Belt (Python), Mesh (Python), 2D plotting (Python)
@subsection Fall (Python)
@cindex Fall

@deftypemethod {mglGraph (Python)} @code{void} Fall (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{const char *}sch=@code{NULL})
The function draws fall lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If @var{sch} contain @samp{x} then lines are drawn along x-direction else (by default) lines are drawn along y-direction. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Fall lines are plotted for each z slice of the data. See also @ref{Belt}, @ref{Mesh}, @ref{Tens}, NeshNum (@pxref{Other settings}). @sref{Fall sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Fall (@code{mglData} z, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Belt (Python), Surf (Python), Fall (Python), 2D plotting (Python)
@subsection Belt (Python)
@cindex Belt

@deftypemethod {mglGraph (Python)} @code{void} Belt (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{const char *}sch=@code{NULL})
The function draws belts for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. This plot can be used as 3d generalization of Plot (@pxref{Plot}). String @var{sch} sets the color scheme. Previous color scheme is used by default. If @var{sch} contain @samp{x} then belts are drawn along x-direction else (by default) belts are drawn along y-direction. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Belts are plotted for each z slice of the data. See also @ref{Fall}, @ref{Surf}, @ref{Plot}, NeshNum (@pxref{Other settings}). @sref{Belt sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Belt (@code{mglData} z, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Surf (Python), Boxs (Python), Belt (Python), 2D plotting (Python)
@subsection Surf (Python)
@cindex Surf

@deftypemethod {mglGraph (Python)} @code{void} Surf (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{const char *}sch=@code{NULL})
The function draws surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Mesh}, @ref{Dens}, @ref{Belt}, @ref{Tile}, @ref{Boxs}, @ref{SurfC}, @ref{SurfA}. @sref{Surf sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Surf (@code{mglData} z, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Boxs (Python), Tile (Python), Surf (Python), 2D plotting (Python)
@subsection Boxs (Python)
@cindex Boxs

@deftypemethod {mglGraph (Python)} @code{void} Boxs (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{const char *}sch=@code{NULL})
The function draws vertical boxes for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Surf}, @ref{Tile}, @ref{Step}. @sref{Boxs sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Boxs (@code{mglData} z, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Tile (Python), Dens (Python), Boxs (Python), 2D plotting (Python)
@subsection Tile (Python)
@cindex Tile

@deftypemethod {mglGraph (Python)} @code{void} Tile (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{const char *}sch=@code{NULL})
The function draws horizontal tiles for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. Such plot can be used as 3d generalization of Step (@pxref{Step}). String @var{sch} sets the color scheme. Previous color scheme is used by default. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Surf}, @ref{Boxs}, @ref{Step}, @ref{TileS}. @sref{Tile sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Tile (@code{mglData} z, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Dens (Python), Cont (Python), Tile (Python), 2D plotting (Python)
@subsection Dens (Python)
@cindex Dens

@deftypemethod {mglGraph (Python)} @code{void} Dens (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws density plot for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z} = @var{zVal}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Surf}, @ref{Cont}, @ref{ContF}, @ref{DensXYZ}. @sref{Dens sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Dens (@code{mglData} z, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Cont (Python), ContF (Python), Dens (Python), 2D plotting (Python)
@subsection Cont (Python)
@cindex Cont

@deftypemethod {mglGraph (Python)} @code{void} Cont (@code{mglData} v, @code{mglData} x, @code{mglData} y, @code{mglData} z, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws contour lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z} = @var{zVal} (or for @var{z=v}[k] if @code{zVal==NAN}). Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Dens}, @ref{ContF}, @ref{Axial}, @ref{ContXYZ}. @sref{Cont sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Cont (@code{mglData} v, @code{mglData} z, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Cont (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{const char *}sch=@code{NULL}, @code{int} num=@code{7}, @code{float} zVal=@code{NAN})
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Cont (@code{mglData} z, @code{const char *}sch=@code{NULL}, @code{int} num=@code{7}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node ContF (Python), Axial (Python), Cont (Python), 2D plotting (Python)
@subsection ContF (Python)
@cindex ContF

@deftypemethod {mglGraph (Python)} @code{void} ContF (@code{mglData} v, @code{mglData} x, @code{mglData} y, @code{mglData} z, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws solid (or filled) contour lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z} = @var{zVal} (or for @var{z=v}[k] if @code{zVal==NAN}). Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Dens}, @ref{Cont}, @ref{Axial}, @ref{ContFXYZ}. @sref{ContF sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContF (@code{mglData} v, @code{mglData} z, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContF (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{const char *}sch=@code{NULL}, @code{int} num=@code{7}, @code{float} zVal=@code{NAN})
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContF (@code{mglData} z, @code{const char *}sch=@code{NULL}, @code{int} num=@code{7}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Axial (Python), Grid (Python), ContF (Python), 2D plotting (Python)
@subsection Axial (Python)
@cindex Axial

@deftypemethod {mglGraph (Python)} @code{void} Axial (@code{mglData} v, @code{mglData} x, @code{mglData} y, @code{mglData} z, @code{const char *}sch=@code{NULL})
The function draws surface which is result of contour plot rotation for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then wire plot is produced. If string contain symbols @samp{x}, @samp{y} or @samp{z} then rotation axis @var{AxialDir} (@pxref{Other settings}) will be set to specified direction. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Cont}, @ref{ContF}, @ref{Torus}, @ref{Surf3}. @sref{Axial sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Axial (@code{mglData} v, @code{mglData} z, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Axial (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{const char *}sch=@code{NULL}, @code{int} num=@code{3})
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Axial (@code{mglData} z, @code{const char *}sch=@code{NULL}, @code{int} num=@code{3})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Grid (Python), , Axial (Python), 2D plotting (Python)
@subsection Grid (Python)
@cindex Grid

@deftypemethod {mglGraph (Python)} @code{void} Grid (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws grid lines for density plot of surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z} = @var{zVal}. String @var{sch} sets the color scheme. Previous color scheme is used by default. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Grid is plotted for each z slice of the data. See also @ref{Dens}, @ref{Cont}, @ref{ContF}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Grid (@code{mglData} z, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod


@c ##################################################################
@node 3D plotting (Python), Dual plotting (Python), 2D plotting (Python), Python interface
@section 3D plotting (Python)

These functions perform plotting of 3D data. 3D means that data depend from 3 independent parameters like matrix @math{f(x_i,y_j,z_k), i=1...n, j=1...m, k=1...l}. There are 4 generally different types of data representations: isosurface or surface of constant value (Surf3), density plot at slices (Dens3), contour lines plot at slices (Cont3), solid contours plot at slices (ContF3) and cloud-like plot (Cloud). Surf3, Cont3 and ContF3 functions have variants for automatic and manual selection of level values for surfaces/contours. Also there are functions for plotting data grid lines according to the data format (Grid3) for enhancing density or contour plots. Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@menu
* Surf3 (Python)::              
* Dens3 (Python)::              
* Cont3 (Python)::              
* ContF3 (Python)::             
* Grid3 (Python)::              
* Cloud (Python)::              
* Beam (Python)::               
@end menu

@c ==================================================================
@node Surf3 (Python), Dens3 (Python), , 3D plotting (Python)
@subsection Surf3 (Python)
@cindex Surf3

@deftypemethod {mglGraph (Python)} @code{void} Surf3 (@code{float} val, @code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} a, @code{const char *}stl=@code{NULL})
The function draws isosurface plot for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) at @var{a}(x,y,z)=@var{val}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). Note, that there is possibility of incorrect plotting due to uncertainty of cross-section defining if there are two or more isosurface intersections inside one cell. See also @ref{Cloud}, @ref{Dens3}, @ref{Surf3C}, @ref{Surf3A}, @ref{Axial}. @sref{Surf3 sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Surf3 (@code{float} val, @code{mglData} a, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Surf3 (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} a, @code{const char *}stl=@code{NULL}, @code{int} num=@code{3})
Draws @var{num}-th uniformly distributed in range [@var{Cmin}, @var{Cmax}] isosurfaces for 3d data specified parametrically.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Surf3 (@code{mglData} a, @code{const char *}sch=@code{NULL}, @code{int} num=@code{3})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Dens3 (Python), Cont3 (Python), Surf3 (Python), 3D plotting (Python)
@subsection Dens3 (Python)
@cindex Dens3
@cindex DensA

@deftypemethod {mglGraph (Python)} @code{void} Dens3 (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}stl=@code{NULL})
The function draws density plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Density is plotted at slice @var{sVal} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{stl} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). See also @ref{Cont3}, @ref{ContF3}, @ref{Dens}, @ref{Grid3}. @sref{Dens3 sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Dens3 (@code{mglData} a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} DensA (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} a, @code{const char *}stl=@code{NULL})
Draws density plots at all central slices of the 3d data specified parametrically.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} DensA (@code{mglData} a, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Cont3 (Python), ContF3 (Python), Dens3 (Python), 3D plotting (Python)
@subsection Cont3 (Python)
@cindex Cont3
@cindex ContA

@deftypemethod {mglGraph (Python)} @code{void} Cont3 (@code{mglData} v, @code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}stl=@code{NULL})
The function draws contour plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Contours are plotted for values specified in array @var{v} at slice @var{sVal} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{stl} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). See also @ref{Dens3}, @ref{ContF3}, @ref{Cont}, @ref{Grid3}. @sref{Cont3 sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Cont3 (@code{mglData} v, @code{mglData} a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Cont3 (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}stl=@code{NULL}, @code{int} num=@code{7})
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Cont3 (@code{mglData} a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}sch=@code{NULL}, @code{int} num=@code{7})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContA (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} a, @code{const char *}stl=@code{NULL}, @code{int} num=@code{7})
Draws contour plots at all central slices of the 3d data specified parametrically.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContA (@code{mglData} a, @code{const char *}sch=@code{NULL}, @code{int} num=@code{7})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node ContF3 (Python), Grid3 (Python), Cont3 (Python), 3D plotting (Python)
@subsection ContF3 (Python)
@cindex ContF3
@cindex ContFA

@deftypemethod {mglGraph (Python)} @code{void} ContF3 (@code{mglData} v, @code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}stl=@code{NULL})
The function draws solid (or filled) contour plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Contours are plotted for values specified in array @var{v} at slice @var{sVal} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{stl} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). See also @ref{Dens3}, @ref{Cont3}, @ref{ContF}, @ref{Grid3}. @sref{ContF3 sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContF3 (@code{mglData} v, @code{mglData} a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContF3 (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}stl=@code{NULL}, @code{int} num=@code{7})
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContF3 (@code{mglData} a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}sch=@code{NULL}, @code{int} num=@code{7})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContFA (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} a, @code{const char *}stl=@code{NULL}, @code{int} num=@code{7})
Draws contour plots at all central slices of the 3d data specified parametrically.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContFA (@code{mglData} a, @code{const char *}sch=@code{NULL}, @code{int} num=@code{7})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Grid3 (Python), Cloud (Python), ContF3 (Python), 3D plotting (Python)
@subsection Grid3 (Python)
@cindex Grid3
@cindex GridA

@deftypemethod {mglGraph (Python)} @code{void} Grid3 (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}stl=@code{NULL})
The function draws grid for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Density is plotted at slice @var{sVal} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{stl} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). See also @ref{Cont3}, @ref{ContF3}, @ref{Dens3}, @ref{Grid}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Grid3 (@code{mglData} a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} GridA (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} a, @code{const char *}stl=@code{NULL})
Draws grids at all central slices of the 3d data specified parametrically.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} GridA (@code{mglData} a, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Cloud (Python), Beam (Python), Grid3 (Python), 3D plotting (Python)
@subsection Cloud (Python)
@cindex CloudP
@cindex CloudQ

@deftypemethod {mglGraph (Python)} @code{void} Cloud (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} a, @code{const char *}stl=@code{NULL}, @code{float} alpha=@code{1})
The function draws cloud plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). This plot is a set of cubes with color and transparency proportional to value of @var{a}. The resulting plot is like cloud -- low value is transparent but higher ones are not. The number of plotting cells depend on MeshNum (@pxref{Other settings}). String @var{sch} sets the color scheme. Previous color scheme is used by default. Parameter @var{alpha} changes the overall transparency of plot. The minor dimensions of arrays @var{x}, @var{y}, @var{z} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). See also @ref{Surf3}. @sref{CloudQ sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Cloud (@code{mglData} a, @code{const char *}stl=@code{NULL}, @code{float} alpha=@code{1})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Beam (Python), , Cloud (Python), 3D plotting (Python)
@subsection Beam (Python)
@cindex Beam

@deftypemethod {mglGraph (Python)} @code{void} Beam (@code{float} val, @code{mglData} tr, @code{mglData} g1, @code{mglData} g2, @code{mglData} a, @code{float} r, @code{const char *}stl=@code{NULL}, @code{int} flag=@code{0})
Draws the isosurface for 3d array @var{a} at constant values of @var{a}=@var{val}. This is special kind of plot for @var{a} specified in accompanied coordinates along curve @var{tr} with orts @var{g1}, @var{g2} and with transverse scale @var{r}. Variable @var{flag} is bitwise: @samp{0x1} - draw in accompanied (not laboratory) coordinates; @samp{0x2} - draw projection to @math{\rho-z} plane; @samp{0x4} - draw normalized in each slice field. The x-size of data arrays @var{tr}, @var{g1}, @var{g2} must be nx>2. The y-size of data arrays @var{tr}, @var{g1}, @var{g2} and z-size of the data array @var{a} must be equal. @xref{Surf3}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Beam (@code{mglData} tr, @code{mglData} g1, @code{mglData} g2, @code{mglData} a, @code{float} r, @code{const char *}stl=@code{NULL}, @code{int} flag=@code{0}, @code{int} num=@code{3})
Draws @var{num}-th uniformly distributed in range [@var{Cmin}, @var{Cmax}] isosurfaces for 3d data specified parametrically.
@end deftypemethod



@c ##################################################################
@node Dual plotting (Python), Vector fields (Python), 3D plotting (Python), Python interface
@section Dual plotting (Python)

These plotting functions draw @emph{two matrix} simultaneously. There are 5 generally different types of data representations: surface or isosurface colored by other data (SurfC, Surf3C), surface or isosurface transpared by other data (SurfA, Surf3A), tiles with variable size (TileS), mapping diagram (Map), STFA diagram (STFA). Surf3A and Surf3C have variants for automatic and manual selection of level values for isosurfaces. Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@menu
* SurfC (Python)::              
* Surf3C (Python)::             
* SurfA (Python)::              
* Surf3A (Python)::             
* TileS (Python)::              
* Map (Python)::                
* STFA (Python)::               
@end menu

@c ==================================================================
@node SurfC (Python), Surf3C (Python), , Dual plotting (Python)
@subsection SurfC (Python)
@cindex SurfC

@deftypemethod {mglGraph (Python)} @code{void} SurfC (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} c, @code{const char *}sch=@code{NULL})
The function draws surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} and color it by matrix @var{c}[i,j]. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. All dimensions of arrays @var{z} and @var{c} must be equal. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Surf}, @ref{SurfA}, @ref{Surf3C}. @sref{SurfC sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SurfC (@code{mglData} z, @code{mglData} c, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod


@c ==================================================================
@node Surf3C (Python), SurfA (Python), SurfC (Python), Dual plotting (Python)
@subsection Surf3C (Python)
@cindex Surf3C

@deftypemethod {mglGraph (Python)} @code{void} Surf3C (@code{float} val, @code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} a, @code{mglData} c, @code{const char *}stl=@code{NULL})
The function draws isosurface plot for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) at @var{a}(x,y,z)=@var{val}. It is mostly the same as Surf3() function but the color of isosurface depends on values of array @var{c}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. All dimensions of arrays @var{z} and @var{c} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). Note, that there is possibility of incorrect plotting due to uncertainty of cross-section defining if there are two or more isosurface intersections inside one cell. See also @ref{Surf3}, @ref{SurfC}, @ref{Surf3A}. @sref{Surf3C sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Surf3C (@code{float} val, @code{mglData} a, @code{mglData} c, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Surf3C (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} a, @code{mglData} c, @code{const char *}stl=@code{NULL}, @code{int} num=@code{3})
Draws @var{num}-th uniformly distributed in range [@var{Cmin}, @var{Cmax}] isosurfaces for 3d data specified parametrically.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Surf3C (@code{mglData} a, @code{mglData} c, @code{const char *}sch=@code{NULL}, @code{int} num=@code{3})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod


@c ==================================================================
@node SurfA (Python), Surf3A (Python), Surf3C (Python), Dual plotting (Python)
@subsection SurfA (Python)
@cindex SurfA

@deftypemethod {mglGraph (Python)} @code{void} SurfA (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} c, @code{const char *}sch=@code{NULL})
The function draws surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} and transparent it by matrix @var{c}[i,j]. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. All dimensions of arrays @var{z} and @var{c} must be equal. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Surf}, @ref{SurfC}, @ref{Surf3A}, @ref{TileS}. @sref{SurfA sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SurfA (@code{mglData} z, @code{mglData} c, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod


@c ==================================================================
@node Surf3A (Python), TileS (Python), SurfA (Python), Dual plotting (Python)
@subsection Surf3A (Python)
@cindex Surf3A

@deftypemethod {mglGraph (Python)} @code{void} Surf3A (@code{float} val, @code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} a, @code{mglData} c, @code{const char *}stl=@code{NULL})
The function draws isosurface plot for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) at @var{a}(x,y,z)=@var{val}. It is mostly the same as Surf3() function but the transparency of isosurface depends on values of @var{b} array. This allows one to remove the part of isosurface where @var{b} is negligibly small (useful for phase plotting of a beam or a pulse). String @var{sch} sets the color scheme. Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. All dimensions of arrays @var{z} and @var{c} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). Note, that there is possibility of incorrect plotting due to uncertainty of cross-section defining if there are two or more isosurface intersections inside one cell. See also @ref{Surf3}, @ref{SurfA}, @ref{Surf3C}. @sref{Surf3A sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Surf3A (@code{float} val, @code{mglData} a, @code{mglData} c, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Surf3A (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} a, @code{mglData} c, @code{const char *}stl=@code{NULL}, @code{int} num=@code{3})
Draws @var{num}-th uniformly distributed in range [@var{Cmin}, @var{Cmax}] isosurfaces for 3d data specified parametrically.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Surf3A (@code{mglData} a, @code{mglData} c, @code{const char *}sch=@code{NULL}, @code{int} num=@code{3})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node TileS (Python), Map (Python), Surf3A (Python), Dual plotting (Python)
@subsection TileS (Python)
@cindex TileS

@deftypemethod {mglGraph (Python)} @code{void} TileS (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} r, @code{const char *}sch=@code{NULL})
The function draws horizontal tiles for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. It is mostly the same as Tile() but the size of tiles is determined by @var{r} array. This is some kind of ``transparency'' useful for exporting to EPS files. String @var{sch} sets the color scheme. Previous color scheme is used by default. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{SurfA}, @ref{Tile}. @sref{TileS sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} TileS (@code{mglData} z, @code{mglData} c, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Map (Python), STFA (Python), TileS (Python), Dual plotting (Python)
@subsection Map (Python)
@cindex Map

@deftypemethod {mglGraph (Python)} @code{void} Map (@code{mglData} x, @code{mglData} y, @code{mglData} ax, @code{mglData} ay, @code{const char *}sch=@code{NULL}, @code{int} ks=@code{0}, @code{bool} pnts=@code{true})
The function draws mapping plot for matrices @{@var{ax}, @var{ay} @} which parametrically depend on coordinates @var{x}, @var{y}. The previous position of the cell (point) is marked by color. Height is proportional to Jacobian(ax,ay). This plot is like Arnold diagram ???. If @code{pnts=false} then face is drawn otherwise the color ball at matrix knots are drawn. Parameter @var{ks} specifies the slice of matrices which will be used. String @var{sch} sets the color scheme. Previous color scheme is used by default. The size of @var{ax} and @var{ay} must be the same. The minor dimensions of arrays @var{x}, @var{y}, @var{ax} should be equal. Arrays @var{x}, @var{y} can be vectors (not matrix as @var{ax}). @xref{Color scheme}. @sref{Map sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Map (@code{mglData} ax, @code{mglData} ay, @code{const char *}sch=@code{NULL}, @code{int} ks=@code{0}, @code{bool} pnts=@code{true})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node STFA (Python), , Map (Python), Dual plotting (Python)
@subsection STFA (Python)
@cindex STFA

@deftypemethod {mglGraph (Python)} @code{void} STFA (@code{mglData} x, @code{mglData} y, @code{mglData} re, @code{mglData} im, @code{int} dn, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
Draws spectrogram of complex array @var{re}+i*@code{im} for Fourier size of @var{dn} points at plane @var{z=zVal}. Parameter @var{dn} is arbitrary even integer. For example in 1D case, result is density plot of data @math{res[i,j]=|\sum_d^dn exp(I*j*d)*(re[i*dn+d]+I*im[i*dn+d])|/dn} with size @{int(nx/dn), dn, ny@}. At this array @var{re}, @var{im} parametrically depend on coordinates @var{x}, @var{y}. String @var{sch} sets the color scheme. Previous color scheme is used by default. The size of @var{re} and @var{im} must be the same. The minor dimensions of arrays @var{x}, @var{y}, @var{re} should be equal. Arrays @var{x}, @var{y} can be vectors (not matrix as @var{re}). @xref{Color scheme}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} STFA (@code{mglData} re, @code{mglData} im, @code{int} dn, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod


@c ##################################################################
@node Vector fields (Python), Other plotting (Python), Dual plotting (Python), Python interface
@section Vector fields (Python)

These functions perform plotting of 2D and 3D vector fields. There are 5 generally different types of vector fields representations: simple vector field (Vect), vector field with coloring (VectC), vector field by dew-drops (Dew), flow threads (Flow), flow pipes (Pipe). Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@menu
* Vect (Python)::               
* VectC (Python)::              
* Dew (Python)::                
* Flow (Python)::               
* Pipe (Python)::               
@end menu

@c ==================================================================
@node Vect (Python), VectC (Python), , Vector fields (Python)
@subsection Vect (Python)
@cindex Vect

@deftypemethod {mglGraph (Python)} @code{void} Vect (@code{mglData} x, @code{mglData} y, @code{mglData} ax, @code{mglData} ay, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN}, @code{int} flag=@code{0})
The function draws plane vector field plot for the field @{@var{ax}, @var{ay}@} depending parametrically on coordinates @var{x}, @var{y} at level @var{z=zVal}. The length of hachures is proportional to @math{\sqrt@{ax^2+ay^2@}}. The number of hachures depend on @var{MeshNum} (@pxref{Other settings}). The color is specified by the string argument @var{sch}. Previous color scheme is used by default. Parameter @var{flag} setup the hachures (arrows). It is compination of vlaues: @code{MGL_VEC_COL} for drawing bi-color arrow, @code{MGL_VEC_LEN} for drawing fixed length arrows, @code{MGL_VEC_DOT} for drawing hachures with dots instead of arrows, @code{MGL_VEC_END} for drawing arrows to the cell point, @code{MGL_VEC_MID} for drawing arrows with center at cell point. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also @ref{VectC}, @ref{Flow}, @ref{Dew}. @sref{Vect sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Vect (@code{mglData} ax, @code{mglData} ay, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN}, @code{int} flag=@code{0})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Vect (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} ax, @code{mglData} ay, @code{mglData} az, @code{const char *}sch=@code{NULL}, @code{int} flag=@code{0})
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the length of hachures is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. @sref{Vect 3D sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Vect (@code{mglData} ax, @code{mglData} ay, @code{mglData} az, @code{const char *}sch=@code{NULL}, @code{int} flag=@code{0})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node VectC (Python), Dew (Python), Vect (Python), Vector fields (Python)
@subsection VectC (Python)
@cindex VectC

@deftypemethod {mglGraph (Python)} @code{void} VectC (@code{mglData} x, @code{mglData} y, @code{mglData} ax, @code{mglData} ay, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws plane vector field plot for the field @{@var{ax}, @var{ay}@} depending parametrically on coordinates @var{x}, @var{y} at level @var{z=zVal}. The color of hachures is proportional to @math{\sqrt@{ax^2+ay^2@}}. The number of hachures depend on @var{MeshNum} (@pxref{Other settings}). The color is specified by the string argument @var{sch}. Previous color scheme is used by default. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also @ref{Vect}, @ref{Flow}, @ref{Dew}. @sref{VectC sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} VectC (@code{mglData} ax, @code{mglData} ay, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} VectC (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} ax, @code{mglData} ay, @code{mglData} az, @code{const char *}sch=@code{NULL})
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the color of hachures is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. @sref{VectC 3D sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} VectC (@code{mglData} ax, @code{mglData} ay, @code{mglData} az, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Dew (Python), Flow (Python), VectC (Python), Vector fields (Python)
@subsection Dew (Python)
@cindex Dew

@deftypemethod {mglGraph (Python)} @code{void} Dew (@code{mglData} x, @code{mglData} y, @code{mglData} ax, @code{mglData} ay, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws dew-drops for plane vector field @{@var{ax}, @var{ay}@} depending parametrically on coordinates @var{x}, @var{y} at level @var{z=zVal}. Note that this is very expensive plot in memory usage and creation time! The color of drops is proportional to @math{\sqrt@{ax^2+ay^2@}}. The number of drops depend on @var{MeshNum} (@pxref{Other settings}). The color is specified by the string argument @var{sch}. Previous color scheme is used by default. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also @ref{Vect}, @ref{VectC}. @sref{Dew sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Dew (@code{mglData} ax, @code{mglData} ay, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod


@c ==================================================================
@node Flow (Python), Pipe (Python), Dew (Python), Vector fields (Python)
@subsection Flow (Python)
@cindex Flow

@deftypemethod {mglGraph (Python)} @code{void} Flow (@code{mglData} x, @code{mglData} y, @code{mglData} ax, @code{mglData} ay, @code{const char *}sch=@code{NULL}, @code{int} num=@code{5}, @code{bool} central=@code{true}, @code{float} zVal=@code{NAN})
The function draws flow threads for the plane vector field @{@var{ax}, @var{ay}@} parametrically depending on coordinates @var{x}, @var{y} at level z = @var{zVal}. Number of threads is proportional to @var{num}. Parameter @var{central} sets the thread start from center (if true) or only from edges (if false). The color of lines is proportional to @math{\sqrt@{ax^2+ay^2@}}. Warm color corresponds to normal flow (like attractor). Cold one corresponds to inverse flow (like source). String @var{sch} sets the color scheme. Previous color scheme is used by default. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also @ref{Pipe}, @ref{VectC}, @ref{Vect}. @sref{Flow sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Flow (@code{mglData} ax, @code{mglData} ay, @code{const char *}sch=@code{NULL}, @code{int} num=@code{5}, @code{bool} central=@code{true}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Flow (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} ax, @code{mglData} ay, @code{mglData} az, @code{const char *}sch=@code{NULL}, @code{int} num=@code{3}, @code{bool} central=@code{true})
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the color of line is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. @sref{Flow 3D sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Flow (@code{mglData} ax, @code{mglData} ay, @code{mglData} az, @code{const char *}sch=@code{NULL}, @code{int} num=@code{3}, @code{bool} central=@code{true})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod


@deftypemethod {mglGraph (Python)} @code{void} Flow (@code{float} x0, @code{float} y0, @code{float} z0, @code{mglData} x, @code{mglData} y, @code{mglData} ax, @code{mglData} ay, @code{const char *}sch=@code{NULL})
The function draws flow threads for the plane vector field @{@var{ax}, @var{ay}@} parametrically depending on coordinates @var{x}, @var{y} from point @{@var{x0}, @var{y0}@} at level z = @var{z0}. The color of lines is proportional to @math{\sqrt@{ax^2+ay^2@}}. Warm color corresponds to normal flow (like attractor). Cold one corresponds to inverse flow (like source). String @var{sch} sets the color scheme. Previous color scheme is used by default. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also @ref{Pipe}, @ref{VectC}, @ref{Vect}. @sref{Flow sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Flow (@code{float} x0, @code{float} y0, @code{float} z0, @code{mglData} ax, @code{mglData} ay, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Flow (@code{float} x0, @code{float} y0, @code{float} z0, @code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} ax, @code{mglData} ay, @code{mglData} az, @code{const char *}sch=@code{NULL})
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the color of line is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. @sref{Flow 3D sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Flow (@code{float} x0, @code{float} y0, @code{float} z0, @code{mglData} ax, @code{mglData} ay, @code{mglData} az, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Pipe (Python), , Flow (Python), Vector fields (Python)
@subsection Pipe (Python)
@cindex Pipe

@deftypemethod {mglGraph (Python)} @code{void} Pipe (@code{mglData} x, @code{mglData} y, @code{mglData} ax, @code{mglData} ay, @code{const char *}sch=@code{NULL}, @code{float} r0=@code{0.05}, @code{int} num=@code{5}, @code{bool} central=@code{true}, @code{float} zVal=@code{NAN})
The function draws flow pipes for the plane vector field @{@var{ax}, @var{ay}@} parametrically depending on coordinates @var{x}, @var{y} at level z = @var{zVal}. Number of pipes is proportional to @var{num}. Parameter @var{central} sets the pipe start from center (if true) or only from edges (if false). The color of lines is proportional to @math{\sqrt@{ax^2+ay^2@}}. Warm color corresponds to normal flow (like attractor). Cold one corresponds to inverse flow (like source). String @var{sch} sets the color scheme. Previous color scheme is used by default. Parameter @var{r0} set the base pipe radius. If @var{r0}<0 then pipe radius is inverse proportional to amplitude. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also @ref{Pipe}, @ref{VectC}, @ref{Vect}. @sref{Pipe sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Pipe (@code{mglData} ax, @code{mglData} ay, @code{const char *}sch=@code{NULL}, @code{float} r0=@code{0.05}, @code{int} num=@code{5}, @code{bool} central=@code{true}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Pipe (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} ax, @code{mglData} ay, @code{mglData} az, @code{const char *}sch=@code{NULL}, @code{float} r0=@code{0.05}, @code{int} num=@code{3}, @code{bool} central=@code{true})
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the color of line is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. @sref{Pipe 3D sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Pipe (@code{mglData} ax, @code{mglData} ay, @code{mglData} az, @code{const char *}sch=@code{NULL}, @code{float} r0=@code{0.05}, @code{int} num=@code{3}, @code{bool} central=@code{true})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod


@c ##################################################################
@node Other plotting (Python), Nonlinear fitting (Python), Vector fields (Python), Python interface
@section Other plotting (Python)

These functions perform miscelaneous plotting. There is unstructured data points plots (Dots), surface reconstruction (Crust), surfaces on the triangular mesh (TriPlot), textual formula plotting (Plots by formula), data plots at edges (Dens[XYZ], Cont[XYZ], ContF[XYZ]), simple plot (SimplePlot). Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@menu
* DensXYZ (Python)::            
* ContXYZ (Python)::            
* ContFXYZ (Python)::           
* Dots (Python)::               
* Crust (Python)::              
* TriPlot (Python)::            
* Plots by formula (Python)::   
* SimplePlot (Python)::         
@end menu

@c ==================================================================
@node DensXYZ (Python), ContXYZ (Python), , Other plotting (Python)
@subsection DensXYZ (Python)
@cindex DensX
@cindex DensY
@cindex DensZ

These plotting functions draw density plot in x, y, or z plain. If @var{a} is a tensor (3-dimensional data) then interpolation to a given @var{sVal} is performed. These functions are useful for creating projections of the 3D data array to the bounding box. See also @ref{ContXYZ}, @ref{ContFXYZ}, @ref{Dens}. @sref{Dens projection sample}

@deftypemethod {mglGraph (Python)} @code{void} DensX (@code{mglData} a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN})
Draws density plot for data @var{a} at x = @var{sVal}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} DensY (@code{mglData} a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN})
Draws density plot for data @var{a} at y = @var{sVal}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} DensZ (@code{mglData} a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN})
Draws density plot for data @var{a} at z = @var{sVal}.
@end deftypemethod

@c ==================================================================
@node ContXYZ (Python), ContFXYZ (Python), DensXYZ (Python), Other plotting (Python)
@subsection ContXYZ (Python)
@cindex ContX
@cindex ContY
@cindex ContZ

These plotting functions draw density plot in x, y, or z plain. If @var{a} is a tensor (3-dimensional data) then interpolation to a given @var{sVal} is performed. These functions are useful for creating projections of the 3D data array to the bounding box. See also @ref{ContFXYZ}, @ref{DensXYZ}, @ref{Cont}. @sref{Cont projection sample}

@deftypemethod {mglGraph (Python)} @code{void} ContX (@code{mglData} a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN}, @code{int} num=@code{7})
Draws @var{num}-th contour lines for data @var{a} at x = @var{sVal}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContY (@code{mglData} a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN}, @code{int} num=@code{7})
Draws @var{num}-th contour lines for data @var{a} at y = @var{sVal}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContZ (@code{mglData} a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN}, @code{int} num=@code{7})
Draws @var{num}-th contour lines for data @var{a} at z = @var{sVal}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContX (@code{mglData} v, @code{mglData} a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN})
Draws contour lines for data @var{a}=@var{v}[i] at x = @var{sVal}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContY (@code{mglData} v, @code{mglData} a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN})
Draws contour lines for data @var{a}=@var{v}[i] at y = @var{sVal}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContZ (@code{mglData} v, @code{mglData} a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN})
Draws contour lines for data @var{a}=@var{v}[i] at z = @var{sVal}.
@end deftypemethod

@c ==================================================================
@node ContFXYZ (Python), Dots (Python), ContXYZ (Python), Other plotting (Python)
@subsection ContFXYZ (Python)
@cindex ContFX
@cindex ContFY
@cindex ContFZ

These plotting functions draw density plot in x, y, or z plain. If @var{a} is a tensor (3-dimensional data) then interpolation to a given @var{sVal} is performed. These functions are useful for creating projections of the 3D data array to the bounding box. See also @ref{ContXYZ}, @ref{DensXYZ}, @ref{ContF}.

@deftypemethod {mglGraph (Python)} @code{void} ContFX (@code{mglData} a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN}, @code{int} num=@code{7})
Draws @var{num}-th solid contours for data @var{a} at x = @var{sVal}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContFY (@code{mglData} a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN}, @code{int} num=@code{7})
Draws @var{num}-th solid contours for data @var{a} at y = @var{sVal}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContFZ (@code{mglData} a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN}, @code{int} num=@code{7})
Draws @var{num}-th solid contours for data @var{a} at z = @var{sVal}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContFX (@code{mglData} v, @code{mglData} a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN})
Draws solid contours for data @var{a}=@var{v}[i] at x = @var{sVal}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContFY (@code{mglData} v, @code{mglData} a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN})
Draws solid contours for data @var{a}=@var{v}[i] at y = @var{sVal}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContFZ (@code{mglData} v, @code{mglData} a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN})
Draws solid contours for data @var{a}=@var{v}[i] at z = @var{sVal}.
@end deftypemethod

@c ==================================================================
@node Dots (Python), Crust (Python), ContFXYZ (Python), Other plotting (Python)
@subsection Dots (Python)
@cindex Dots

@deftypemethod {mglGraph (Python)} @code{void} Dots (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{const char *}sch=@code{NULL})
@deftypemethodx {mglGraph (Python)} @code{void} Dots (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} a, @code{const char *}sch=@code{NULL})
The function draws the arbitrary placed points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If array @var{a} is specified then it define the transparency of dots. Arrays @var{x}, @var{y}, @var{z}, @var{a} must have equal sizes. See also @ref{Crust}, @ref{Mark}, @ref{Plot}. @sref{Dots sample}
@end deftypemethod

@c ==================================================================
@node Crust (Python), TriPlot (Python), Dots (Python), Other plotting (Python)
@subsection Crust (Python)
@cindex Crust

@deftypemethod {mglGraph (Python)} @code{void} Crust (@code{mglData} x, @code{mglData} y, @code{mglData} z, @code{const char *}sch=@code{NULL}, @code{float} er=@code{0})
The function reconstruct and draws the surface for arbitrary placed points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. Parameter @var{er} set relative radius for (increase it for removing holes). String @var{sch} sets the color scheme. Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. Arrays @var{x}, @var{y}, @var{z} must have equal sizes. See also @ref{Dots}, @ref{TriPlot}. @sref{Crust sample}
@end deftypemethod

@c ==================================================================
@node TriPlot (Python), Plots by formula (Python), Crust (Python), Other plotting (Python)
@subsection TriPlot (Python)
@cindex TriPlot

@deftypemethod mglGraph @code{void} TriPlot (@code{const mglData &}id, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}c, @code{const char *}sch=@code{NULL})
@deftypemethodx mglGraph @code{void} TriPlot (@code{const mglData &}id, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{NULL})
The function draws the surface of triangles. Triangle vertexes are set by indexes @var{id} of data points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. First dimensions of @var{id} must be 3 or greater. Arrays @var{x}, @var{y}, @var{z} must have equal sizes. Parameter @var{c} set the colors of triangles (if @var{id}.ny=@var{c}.nx) or colors of vertexes (if @var{x}.nx=@var{c}.nx). See also @ref{Dots}, @ref{Crust}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} TriPlot (@code{mglData} id, @code{mglData} x, @code{mglData} y, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The same as previous with @var{z}[i]=@var{zVal}.
@end deftypemethod

@c ==================================================================
@node Plots by formula (Python), SimplePlot (Python), TriPlot (Python), Other plotting (Python)
@subsection Plots by formula (Python)
@cindex Plot
@cindex Surf

These functions perform plotting of 1D or 2D functions specified by textual formula. You do not need to create the data arrays to plot it. The parameter @var{stl} set the line style (@pxref{Line styles}) for @code{Plot()} or color scheme (@pxref{Color scheme}) for @code{Surf()}. The parameter @var{n} set the minimal number of points along coordinate(s) for plots. At this time (v. 1.7) there is no adaptive increase of data points numbers but in future it will appear.

@deftypemethod {mglGraph (Python)} @code{void} Plot (@code{const char *}eqY, @code{const char *}stl=@code{NULL}, @code{float} zVal=@code{NAN}, @code{int} n=@code{100})
The function draws function @samp{eqY(x)} at plane z=@var{zVal} where @samp{x} variable is changed in range [@var{Min}.x, @var{Max}.x]. See also @ref{Plot}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Plot (@code{const char *}eqX, @code{const char *}eqY, @code{const char *}eqZ, @code{const char *}stl=@code{NULL}, @code{float} zVal=@code{NAN}, @code{int} n=@code{100})
The function draws parametrical curve @{@samp{eqX(t)}, @samp{eqY(t)}, @samp{eqZ(t)}@} where @samp{t} variable is changed in range [0, 1]. See also @ref{Plot}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Surf (@code{const char *}eqZ, @code{const char *}stl=@code{NULL}, @code{int} n=@code{100});
The function draws surface for function @samp{eqY(x,y)} where @samp{x}, @samp{y} variables are changed in range [@var{Min}, @var{Max}]. See also @ref{Surf}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Surf (@code{const char *}eqX, @code{const char *}eqY, @code{const char *}eqZ, @code{const char *}stl=@code{NULL}, @code{int} n=@code{100})
The function draws parametrical surface @{@samp{eqX(u,v)}, @samp{eqY(u,v)}, @samp{eqZ(u,v)}@} where @samp{u}, @samp{v} variables are changed in range [0, 1]. See also @ref{Surf}.
@end deftypemethod

@c ==================================================================
@node SimplePlot (Python), , Plots by formula (Python), Other plotting (Python)
@subsection SimplePlot (Python)
@cindex SimplePlot

@deftypemethod {mglGraph (Python)} @code{void} SimplePlot (@code{mglData} a, @code{int} type=@code{0}, @code{const char *}stl=@code{NULL})
Plots the array @var{a} depending on it's dimensions and @var{type} parameter. String @var{stl} specifies the style of plotting. For 1d data: @code{type=0} -- @ref{Plot}, @code{type=1} -- @ref{Area}, @code{type=2} -- @ref{Step}, @code{type=3} -- @ref{Stem}, @code{type=4} -- @ref{Bars}. For 2d data: @code{type=0} -- @ref{Surf}, @code{type=1} -- @ref{Dens}, @code{type=2} -- @ref{Mesh}, @code{type=3} -- @ref{Cont}. For 3d data: @code{type=0} -- @ref{Surf3}, @code{type=1} -- @ref{Dens3}, @code{type=2} -- @ref{Cont3}, @code{type=2} -- @ref{Cloud}.
@end deftypemethod

@c ##################################################################
@node Nonlinear fitting (Python), Frames/Animation (Python), Other plotting (Python), Python interface
@section Nonlinear fitting (Python)
@cindex Fit
@cindex FitS
@cindex PutsFit
@cindex FitPnts
@cindex Fit2
@cindex Fit3

These functions fit data to formula. Fitting goal is to find formula parameters for the best fit the data points, i.e. to minimize the sum @math{\sum_i (f(x_i, y_i, z_i) - a_i)^2/s_i^2}. At this, approximation function @samp{f} can depend only on one argument @samp{x} (1D case), on two arguments @samp{x,y} (2D case) and on three arguments @samp{x,y,z} (3D case). The function @samp{f} also may depend on parameters. Normally the list of fitted parameters is specified by @var{var} string (like, @samp{abcd}). Usually user should supply initial values for fitted parameters by @var{ini} variable. But if he/she don't supply it then the zeros are used. Parameter @var{print}=@code{true} switch on printing the found coefficients to @var{Message} (@pxref{Error handling}).

Functions Fit() and FitS() do not draw the obtained data themselves. They fill the data @var{fit} by formula @samp{f} with found coefficients and return the @math{\chi^2} error of approximation. At this, the @samp{x,y,z} coordinates are equidistantly distributed in the interval @var{Min}--@var{Max}. Number of points in @var{fit} is selected as maximal value of @var{fit} size and the value of @var{FitPnts}. Note, that this functions use GSL library and do something only if MathGL was compiled with GSL support. @sref{Fitting sample}

@deftypemethod {mglGraph (Python)} @code{float} FitS (@code{mglData} fit, @code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} a, @code{mglData} s, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx {mglGraph (Python)} @code{float} FitS (@code{mglData} fit, @code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} a, @code{mglData} s, @code{const char *}func, @code{const char *}var, @code{mglData} ini, @code{bool} print=@code{false})
Fit data along x-, y- and z-directions for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]).
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{float} FitS (@code{mglData} fit, @code{mglData} x, @code{mglData} y, @code{mglData} a, @code{mglData} s, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx {mglGraph (Python)} @code{float} FitS (@code{mglData} fit, @code{mglData} x, @code{mglData} y, @code{mglData} a, @code{mglData} s, @code{const char *}func, @code{const char *}var, @code{mglData} ini, @code{bool} print=@code{false})
Fit data along x-, and y-directions for 2d array specified parametrically @var{a}[i,j](@var{x}[i,j], @var{y}[i,j]) for each data slice.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{float} FitS (@code{mglData} fit, @code{mglData} x, @code{mglData} a, @code{mglData} s, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx {mglGraph (Python)} @code{float} FitS (@code{mglData} fit, @code{mglData} x, @code{mglData} a, @code{mglData} s, @code{const char *}func, @code{const char *}var, @code{mglData} ini, @code{bool} print=@code{false})
Fit data along x-direction for 1d array specified parametrically @var{a}[i](@var{x}[i]) for each data slice.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{float} FitS (@code{mglData} fit, @code{mglData} a, @code{mglData} s, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx {mglGraph (Python)} @code{float} FitS (@code{mglData} fit, @code{mglData} a, @code{mglData} s, @code{const char *}func, @code{const char *}var, @code{mglData} ini, @code{bool} print=@code{false})
Fit data along x-direction for 1d array with @var{x} equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{float} Fit (@code{mglData} fit, @code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} a, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx {mglGraph (Python)} @code{float} Fit (@code{mglData} fit, @code{mglData} x, @code{mglData} y, @code{mglData} z, @code{mglData} a, @code{const char *}func, @code{const char *}var, @code{mglData} ini, @code{bool} print=@code{false})
Fit data along x-, y- and z-directions for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) with @var{s}[i,j,k]=1.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{float} Fit (@code{mglData} fit, @code{mglData} x, @code{mglData} y, @code{mglData} a, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx {mglGraph (Python)} @code{float} Fit (@code{mglData} fit, @code{mglData} x, @code{mglData} y, @code{mglData} a, @code{const char *}func, @code{const char *}var, @code{mglData} ini, @code{bool} print=@code{false})
Fit data along x-, and y-directions for 2d array specified parametrically @var{a}[i,j](@var{x}[i,j], @var{y}[i,j]) with @var{s}[i,j]=1 for each data slice.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{float} Fit (@code{mglData} fit, @code{mglData} x, @code{mglData} a, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx {mglGraph (Python)} @code{float} Fit (@code{mglData} fit, @code{mglData} x, @code{mglData} a, @code{const char *}func, @code{const char *}var, @code{mglData} ini, @code{bool} print=@code{false})
Fit data along x-direction for 1d array specified parametrically @var{a}[i](@var{x}[i]) with @var{s}[i]=1 for each data slice.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{float} Fit (@code{mglData} fit, @code{mglData} a, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx {mglGraph (Python)} @code{float} Fit (@code{mglData} fit, @code{mglData} a, @code{const char *}func, @code{const char *}var, @code{mglData} ini, @code{bool} print=@code{false})
Fit data along x-direction for 1d array @var{a} with @var{s}=1 and @var{x} equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{float} Fit2 (@code{mglData} fit, @code{mglData} a, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx {mglGraph (Python)} @code{float} Fit2 (@code{mglData} fit, @code{mglData} a, @code{const char *}func, @code{const char *}var, @code{mglData} ini, @code{bool} print=@code{false})
Fit data along x-, and y-directions for 2d array @var{a} with @var{s}=1 and @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{float} Fit3 (@code{mglData} fit, @code{mglData} a, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx {mglGraph (Python)} @code{float} Fit3 (@code{mglData} fit, @code{mglData} a, @code{const char *}func, @code{const char *}var, @code{mglData} ini, @code{bool} print=@code{false})
Fit data along x-, y- and z-directions for 3d array @var{a} with @var{s}=1 and @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} PutsFit (@code{mglPoint} p, @code{const char *}prefix=@code{NULL}, @code{const char *}font=@code{NULL}, @code{float} size=@code{-1})
Print last fitted formula with found coefficients (as numbers) at position @var{p0}. The string @var{prefix} will be printed before formula. All other parameters are the same as in @ref{Text printing}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} @code{int} FitPnts
Minimal number of points for output array after nonlinear fitting.
@end deftypemethod

@c ##################################################################
@node Frames/Animation (Python), , Nonlinear fitting (Python), Python interface
@section Frames/Animation (Python)
@cindex NewFrame
@cindex EndFrame
@cindex GetNumFrame

These functions provide ability to create several pictures simultaneously. Later, you can write several frames into animated GIF file.

@deftypemethod mglGraph @code{int} NewFrame ()
Creates new frame. Function returns current frame id. The function @code{EndFrame()} @strong{must} be call after the  finishing of the frame drawing for each call of this function.
@end deftypemethod

@deftypemethod mglGraph @code{void} EndFrame ()
Finishes the frame drawing.
@end deftypemethod

@deftypemethod mglGraph @code{int} GetNumFrame ()
Gets the number of created frames.
@end deftypemethod

@deftypemethod mglGraph @code{void} ResetFrames ()
Reset frames counter (start it from zero).
@end deftypemethod

@deftypemethod mglGraph @code{void} StartGIF (@code{const char *}fname, @code{int} ms=@code{100})
Start writing frames into animated GIF file @var{fname}. Parameter @var{ms} set the delay between frames in milliseconds. You @strong{should not} change the picture size during writing the cinema. Use CloseGIF() to finalize writing. Note, that this function is disabled in OpenGL mode.
@end deftypemethod

@deftypemethod mglGraph @code{int} CloseGIF ()
Finish writing animated GIF and close connected pointers.
@end deftypemethod
