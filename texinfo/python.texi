@c ------------------------------------------------------------------
@node Python interface, MGL interface, C interface, Interfaces
@section Python interface
@cindex mglGraph

MathGL provide the interface to a set of languages via SWIG library. Some of these languages support classes. The typical example is Python -- which is denoted in the chapter title.

To use Python classes just execute @samp{import mathgl}. The simplest example will be:
@verbatim
import mathgl
a=mathgl.mglGraph()
a.Box()
a.WritePNG('test.png')
@end verbatim
Alternatively you can import all classes from @code{mathgl} module and easely access MathGL classes: 
@verbatim
from mathgl import *
a=mglGraph()
a.Box()
a.WritePNG('test.png')
@end verbatim
It become aloud if you will create many @code{mglData} object.

There are 3 classes in Python interface:
@itemize 
@item @code{mglGraph}
-- the class provide practically the same functionality as C++ class @code{mglGraph} (@pxref{MathGL core}). But it is not abstract class and it allows one to select which plotter (ZB or PS and so on) will be used.
@item @code{mglData}
-- practically the same class as C++ class @code{mglData} (@pxref{mglData class}).
@c @item @code{mglParse} -- prectically the same as C++ class @code{mglParse} (@pxref{mglParse class}).
@end itemize
There is main difference from C++ classes -- MathGL Python classes don't have variables (options). All corresponding features are moved to methods.
The core of MathGL Python classes is @strong{mglGraph} class. It contains a lot of plotting functions for 1D, 2D and 3D plots. So most of subsections is describe its methods. Its constructor have following arguments:

@defop Constructor {mglGraph (Python)} @code{} mglGraph (@code{int} kind=@code{0}, @code{int} width=@code{600}, @code{int} height=@code{400})
Create the instance of class mglGraph with specified sizes @var{width} and @var{height}. Parameter @var{type} may have following values: @samp{0} -- use @code{mglGraphZB} plotter (default), @samp{1} -- use @code{mglGraphPS} plotter, @samp{2} -- use @code{mglGraphGL} plotter, @samp{3} -- use @code{mglGraphIDTF} plotter.
@end defop

@menu
* Graphics setup (Python)::     
* Axis settings (Python)::      
* Transformation matrix (Python)::  
* Export to file (Python)::     
* Primitives drawing (Python)::  
* Text printing (Python)::      
* Axis and Colorbar (Python)::  
* Legend (Python)::             
* 1D plotting (Python)::        
* 2D plotting (Python)::        
* 3D plotting (Python)::        
* Dual plotting (Python)::      
* Vector fields (Python)::      
* Other plotting (Python)::     
* Nonlinear fitting (Python)::  
* Data import (Python)::        
* Data filling (Python)::       
* Rearrange data (Python)::     
* File I/O (Python)::           
* Make another data (Python)::  
* Functions on direction (Python)::  
* Interpolation (Python)::      
* Informational functions (Python)::  
@end menu

@c ##################################################################
@node Graphics setup (Python), Transformation matrix (Python), , Python interface
@subsection Graphics setup (Python)
@cindex MathGL setup

Functions in this group influences on overall graphics appearance. So all of them should be placed @emph{before} any actual plotting function calls.

@deftypemethod {mglGraph (Python)} @code{void} DefaultPlotParam ()
Restore initial values for all of parameters except described in @ref{Zooming (Python)}.
@end deftypemethod

@menu
* Transparency (Python)::       
* Lighting (Python)::           
* Fog (Python)::                
* Default sizes (Python)::      
* Zooming (Python)::            
* Cutting (Python)::            
* Font settings (Python)::      
* Palette and colors (Python)::  
* Other settings (Python)::     
@end menu

@c ==================================================================
@node Transparency (Python), Lighting (Python), , Graphics setup (Python)
@subsubsection Transparency (Python)
@cindex Alpha
@cindex AlphaDef
@cindex Transparent
@cindex TranspType

There are several functions and variables for setup transparency. The general function is @code{Alpha()} which switch on/off the transparency for overall plot. It influence only for graphics which created after @code{Alpha()} call (with one exeption, mglGraphGL). Variable @code{SetAlphaDef()} specify the default value of alpha-channel. You may switch off transparency of selected plot by variable @code{SetTransparent()}. Finally, variable @code{SetTranspType()} set the kind of transparency. @sref{Transparent surface sample}

@deftypemethod {mglGraph (Python)} @code{void} Alpha (@code{bool} enable)
Sets the transparency on/off. It is recommended to call this function before any plotting command. In any case it must be called before  @code{Finish()} function if the last is used. Default value is transparency off. Unfortunately it switches the transparency on/off for all subplots. Use @code{SetTransparent(false)} in particular plot to disable its transparency.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetAlphaDef (@code{float} val)
Sets default value of alpha channel (transparency) for all plotting functions. Note, that OpenGL (mglGraphGL) has incorrect drawing for large values of alpha in case of several overlapping surfaces.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetTransparent (@code{bool} val)
Flag which temporary switches transparency on/off for the plot.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetTranspType (@code{int} type)
This variable set the transparency type. Normal transparency (@samp{0}) -- below things is less visible than upper ones. It does not look well in OpenGL mode (mglGraphGL) for several surfaces. Glass-like transparency (@samp{1}) -- below and upper things are commutable and just decrease intensity of light by RGB channel. Lamp-like transparency (@samp{2}) -- below and upper things are commutable and are the source of some additional light. I recommend to set @code{SetAlphaDef(0.3)} or less for lamp-like transparency.
@end deftypemethod

@c ==================================================================
@node Lighting (Python), Fog (Python), Transparency (Python), Graphics setup (Python)
@subsubsection Lighting (Python)
@cindex Light
@cindex Ambient

There are several functions for setup lighting. The general function is @code{Light(bool)} which switch on/off the lighting for overall plot. It influence only for graphics which created after @code{Light()} call (with one exeption, mglGraphGL). Generally MathGL support up to 10 independend light sources. But in OpenGL mode only 8 of light sources is used due to OpenGL limitations. The position, color, brightness of each light source can be set separately. By default only one light source is active. It is source number @code{0} with white color, located at top of the plot.

@deftypemethod {mglGraph (Python)} @code{void} Light (@code{bool} enable)
Sets the using of light on/off for overall plot. It is recommended to call this function before any plotting command. Default value is lightning off.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Light (@code{int} n, @code{bool} enable)
Switch on/off @var{n}-th light source separately.
@end deftypemethod

@deftypemethod mglGraph @code{void} Light (@code{int} n, @code{float} x, @code{float} y, @code{float} z, @code{char} c=@code{'w'})
The function adds a light source with identification @var{n} at position @{@var{x}, @var{y}, @var{z}@}. The color of light is defined by character @var{c} or by RGB values @{@var{r}, @var{g}, @var{b}@} (white by default). The brightness of light is @var{br} which must be in range [0,1]. Flag @var{infty}=@code{true} puts the source to infinite distance (for the faster drawing). It is recommended to call this function before any plotting command.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Ambient (@code{float} bright=@code{0.5})
Sets the brightness of ambient light. The value should be in range [0,1]. It is recommended to call this function before any plotting command.
@end deftypemethod

@c ==================================================================
@node Fog (Python), Default sizes (Python), Lighting (Python), Graphics setup (Python)
@subsubsection Fog (Python)
@cindex Fog

@deftypemethod {mglGraph (Python)} @code{void} Fog (@code{float} d, @code{float} dz=@code{0.25})
Function imitate a fog in the plot. Fog start from relative distance @var{dz} from view point and its density growths exponentially in depth. So that the fog influence is determined by law ~ 1-exp(-@emph{d*z}). Here @emph{z} is normalized to 1 depth of the plot. If value @var{d}=@code{0} then the fog is absent. @sref{Surface in fog sample}
@end deftypemethod

@c ==================================================================
@node Default sizes (Python), Zooming (Python), Fog (Python), Graphics setup (Python)
@subsubsection Default sizes (Python)
@cindex BarWidth
@cindex MarkSize
@cindex ArrowSize
@cindex BaseLineWidth

These functions variables control the default (initial) values for most graphics parameters including sizes of markers, arrows, linewidth and so on. As any other settings these ones will influence only on plots created after the settings change.

@deftypemethod {mglGraph (Python)} @code{void} SetBarWidth ( @code{float} val)
Sets relative width of rectangles in Bars plot (@pxref{Bars}). Default value is @code{0.7}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetMarkSize (@code{float} val)
The size of marks for @ref{1D plotting}. Default value is @code{0.02}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetArrowSize (@code{float} val)
The size of arrows for @ref{1D plotting}, lines and curves (@pxref{Primitives drawing}). Default value is @code{0.03}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetBaseLineWidth (@code{float} val)
The variable define the base width for all lines. The value <1 is ignored. For values > 1 the real line width is result of multiplication of specified line width and the value of @var{BaseLineWidth}. Increase of this variables is actual for large bitmap pictures. Default value is @code{1}.
@end deftypemethod

@c ==================================================================
@node Zooming (Python), Cutting (Python), Default sizes (Python), Graphics setup (Python)
@subsubsection Zooming (Python)
@cindex PlotFactor
@cindex Zoom

These functions control the overall zooming of the picture (see Zoom()) or the sub-picture (see PlotFactor). Normally you can use these variables and functions for removing ``white'' spaces around a plot.

@deftypemethod {mglGraph (Python)} @code{void} SetPlotFactor (@code{float} val)
Sets the factor of plot size. It is not recommended to set it lower then 1.6. This is some anlogue of function Zoom() but applied not to overall image but for each InPlot. Use negative value to enable automatic @code{PlotFactor} selection.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Zoom (@code{float} x1, @code{float} y1, @code{float} x2, @code{float} y2)
Changes the scale of graphics that correspond to zoom in/out of the picture. After function call the current plot will be cleared and further the picture will contain plotting from its part [x1,x2]*[y1,y2]. Here picture coordinates @var{x1}, @var{x2}, @var{y1}, @var{y2} changes from 0 to 1. Attention! this settings can not be overwritten by any other functions. Use @code{Zoom(0,0,1,1)} to return default view.
@end deftypemethod

@c ==================================================================
@node Cutting (Python), Font settings (Python), Zooming (Python), Graphics setup (Python)
@subsubsection Cutting (Python)
@cindex Cut
@cindex CutMin
@cindex CutMax
@cindex CutOff

These functions set the condition when the points are excluded (cutted) from the drawing.

@deftypemethod {mglGraph (Python)} @code{void} SetCut (@code{bool} val)
Flag which determines how points outside bounding box are drawn. If it is @code{true} then points are excluded from plot (it is default) otherwise the points are projected to edges of bounding box.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetCutBox (@code{float} x1, @code{float} y1, @code{float} z1, @code{float} x2, @code{float} y2, @code{float} z2)
Lower and upper edge of the box in which never points are drawn. If both edges are the same (the variables are equal) then the cutting box is empty. @sref{CutMinMax sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} CutOff (@code{const char *}EqC)
Function set the cutting off condition by formula @var{EqC}. This condition determine will point be plotted or not. If value of formula is nonzero then point is omitted, otherwise it plotted. Set argument as @code{NULL} to disable cutting off condition. @sref{CutOff sample}
@end deftypemethod


@c ==================================================================
@node Font settings (Python), Palette and colors (Python), Cutting (Python), Graphics setup (Python)
@subsubsection Font settings (Python)
@cindex FontSize
@cindex FontDef
@cindex RotatedText
@cindex SetFont
@cindex GetFont

@deftypemethod {mglGraph (Python)} @code{void} SetFontSize (@code{float} val)
Sets the size of font for tick and axis labels. Default font size of axis labels is 1.4 times large than for tick labels.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetFontDef (@code{char *}fnt)
Sets the font specification (@pxref{Text printing (Python)}). Default is ``rC'' -- Roman font centering.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetRotatedText (@code{bool} val)
Sets to use or not text rotation along axis.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} LoadFont (@code{const char *}name, @code{const char *}path=@code{NULL})
Load font typeface from @var{path}/@var{name}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} CopyFont (@code{mglGraph *} from)
Copy font data from another @code{mglGraph} object.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} RestoreFont ()
Restore font data to default typeface.
@end deftypemethod

@c ==================================================================
@node Palette and colors (Python), Other settings (Python), Font settings (Python), Graphics setup (Python)
@subsubsection Pallete and colors (Python)
@cindex Pal
@cindex NumPal
@cindex SetPalette
@cindex SetScheme
@cindex SelectPen

@deftypemethod {mglGraph (Python)} @code{void} SetPalette (@code{const char *}@var{colors})
Sets the palette as selected colors. Deafult value is @code{"Hbgrcmyhlnqeup"} that corresponds to colors: dark gray @samp{H}, blue @samp{b}, green @samp{g}, red @samp{r}, cyan @samp{c}, magenta @samp{m}, yellow @samp{y}, gray @samp{h}, blue-green @samp{l}, sky-blue @samp{n}, orange @samp{q}, yellow-green @samp{e}, blue-violet @samp{u}, purple @samp{p}. The palette is used mostly in 1D plots (@pxref{1D plotting}) for curves which styles are not specified.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetPalColor (@code{int} n, @code{float} r, @code{float} g, @code{float} b)
Sets color for individual palette entry. Look at @code{mgl_set_palette()} function for simplified palette setting.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetPalNum (@code{int} num)
Sets the number of actual colors in palette. The value must be less then 100.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetScheme (@code{const char *}sch)
Set the color scheme for following plots. Usually this function is used internaly. @xref{Color scheme}.
@end deftypemethod

@c ==================================================================
@node Other settings (Python), , Palette and colors (Python), Graphics setup (Python)
@subsubsection Other settings (Python)

@deftypemethod {mglGraph (Python)} @code{void} SetMeshNum (@code{int} val)
Sets approximate number of lines in Mesh(), Fall(), Grid() and also the number of hachures in Vect(), VectC(), Dew() and the number of cells in Cloud*(). By default (=0) it draws all lines/hachures/cells.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetAxialDir (@code{char} val)
Sets direction around which curve rotated in Axial() and Torus(). Default value is 'z'.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetDrawFace (@code{bool} val)
If set to @code{true} then it prevent faces drawing. It is useful for speeding up drawing (for example, during rotation and so on).
@end deftypemethod

@c ==================================================================
@node Axis settings (Python), Transformation matrix (Python), Graphics setup (Python), Python interface
@subsection Axis settings (Python)

These large set of functions control how the axis and ticks will be drawn. Note that there is 3-step transformation of data coordinates are performed. Firstly, coordinates are projected if @code{Cut=true} (@pxref{Cutting}), after it transformation formulas are applied, and finally the data was normalized in bounding box.

@menu
* Ranges (Python)::             
* Transformation (Python)::     
* Ticks (Python)::              
@end menu

@c ------------------------------------------------------------------
@node Ranges (Python), Transformation (Python), , Axis settings (Python)
@subsubsection Ranges (Python)
@cindex Axis
@cindex CAxis
@cindex XRange
@cindex YRange
@cindex ZRange
@cindex Min
@cindex Max
@cindex Cmin
@cindex Cmax
@cindex RecalcBorder
@cindex Org
@cindex AutoOrg

@deftypemethod {mglGraph (Python)} @code{void} SetRanges (@code{float} x1, @code{float} x2, @code{float} y1, @code{float} y2, @code{float} z1=@code{0}, @code{float} z2=@code{0})
Sets maximal and minimal values for coordinate range (bounding box). If minimal and maximal values of the coordinate are the same then they are ignored. This function also sets @var{Cmin}=@code{Min.z} and @var{Cmax}=@code{Max.z}. This is default color range for 2d plots.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetCRange (@code{float} min, @code{float} max)
Sets values for color range. This values are used later for determining the color of the surface.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} XRange (@code{mglData *} dat, @code{bool} add=@code{false})
Sets values of x-range as minimal and maximal values of data @var{a}. See also Axis().
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} YRange (@code{mglData *} dat, @code{bool} add=@code{false})
Sets values of y-range as minimal and maximal values of data @var{a}. See also Axis().
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ZRange (@code{mglData *} dat, @code{bool} add=@code{false})
Sets values of z-range as minimal and maximal values of data @var{a}. See also Axis().
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} CRange (@code{mglData *} dat, @code{bool} add=@code{false})
Sets values of color range as minimal and maximal values of data @var{a}. See also CAxis().
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetOrigin (@code{float} x0, @code{float} y0, @code{float} z0)
Sets center of axis cross section. If one of values is NAN then MathGL library try to select optimal axis position.
@end deftypemethod

@c ------------------------------------------------------------------
@node Transformation (Python), Ticks (Python), Ranges (Python), Axis settings (Python)
@subsubsection Transformation (Python)
@cindex Axis
@cindex Ternary
@cindex fx
@cindex fy
@cindex fz

@deftypemethod {mglGraph (Python)} @code{void} SetFunc (@code{const char *}EqX=@code{NULL}, @code{const char *}EqY=@code{NULL}, @code{const char *}EqZ=@code{NULL})
Sets the transformation formulas for curvilinear coordinate. Each string should contain mathematical expression for real coordinate depending on internal coordinates x, y, z. For example, the cylindrical coordinates are introduced as @code{SetFunc("x*cos(y)", "x*sin(y)", "z");}. For removing of formulas the corresponding parameter should be @code{NULL}. Using transformation formulas will slightly slowing the program, i.e. @code{SetFunc(NULL, NULL, NULL)} is faster than @code{SetFunc("x", "y", "z")}. @xref{mglFormula class}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Ternary (@code{bool} tern)
The function sets to draws Ternary plot. This special plot is for 3 dependent coordinates (components) @var{a}, @var{b}, @var{c} so that @var{a}+@var{b}+@var{c}=1. MathGL uses only 2 independent coordinates @var{a}=x and @var{b}=y since it is enough to plot everything. At this third coordinate z act as another parameter to produce contour lines, surfaces and so on. @sref{Ternary plot sample}
@end deftypemethod

@c ------------------------------------------------------------------
@node Ticks (Python), , Transformation (Python), Axis settings (Python)
@subsubsection Ticks (Python)

@cindex SetTicks
@cindex FactorPos
@cindex TuneTicks
@cindex TickStr

@deftypemethod {mglGraph (Python)} @code{void} SetTicks (@code{char} dir, @code{float} d=@code{-5}, @code{int} ns=@code{0}, @code{float} org=@code{NAN})
Set the ticks step @var{d}, number of subticks @var{ns} and initial ticks position @var{org} for the axis along direction @var{dir}. Variable @var{d} set step for axis ticks (if positive) or it's number on the axis range (if negative). Zero value set logarithmic ticks. If @var{org} value is NAN then value from @var{Org} is used.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetTickTemplX (@code{const wchar_t *}xtt)
@deftypemethodx {mglGraph (Python)} @code{void} SetTickTemplY (@code{const wchar_t *}ytt)
@deftypemethodx {mglGraph (Python)} @code{void} SetTickTemplZ (@code{const wchar_t *}ztt)
@deftypemethodx {mglGraph (Python)} @code{void} SetTickTemplC (@code{const wchar_t *}ctt)
The template for x-,y-,z-axis ticks or colorvar ticks. It may contain TeX symbols also. If @var{xtt}, @var{ytt}, @var{ztt}, @var{ctt}=@code{NULL} then default template is used (in simplest case it is @samp{%.2g}) with automatic detaching of common multiplier or common component (see @var{TuneTicks}).
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetTuneTicks (@code{bool} tune, @code{float} factor_pos=@code{1.15})
Switch on/off ticks enhancing by factoring common multiplier (for small, like from 0.001 to 0.002, or large, like from 1000 to 2000, coordinate values) or common component (for narrow range, like from 0.999 to 1.000). Also set the position of common multiplier/component on the axis: =0 at minimal axis value, =1 at maximal axis value. Default value is 1.15.
@end deftypemethod


@c ##################################################################
@node Transformation matrix (Python), Export to file (Python), Axis settings (Python), Python interface
@subsection Transformation matrix (Python)
@cindex Aspect
@cindex Rotate
@cindex RotateN
@cindex SubPlot
@cindex InPlot
@cindex Identity
@cindex Perspective
@cindex RestoreM
@cindex View

These functions control how and where further plotting will be placed. There is a curtain order of calling of these functions for the better plot view. First one should be SubPlot() or InPlot() for specifying the place. After it a Rotate() and Aspect(). And finally any other plotting functions may be called.

@deftypemethod {mglGraph (Python)} @code{void} SubPlot (@code{int} nx, @code{int} ny, @code{int} m, @code{float} dx=@code{0}, @code{float} dy=@code{0})
Puts further plotting in a @var{m}-th cell of @var{nx}*@var{ny} grid of the whole frame area. This function set off any aspects or rotations. So it should be used first for creating the subplot. From the aesthetical point of view it is not recommended to use this function with different matrices in the same frame. The position of the cell can be shifted from its default position by relative size @var{dx}, @var{dy}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} InPlot (@code{float} x1, @code{float} x2, @code{float} y1, @code{float} y2)
Puts further plotting in some region of the whole frame surface. This function allows one to create a plot in arbitrary place of the screen. The position is defined by rectangular coordinates [@var{x1}, @var{x2}]*[@var{y1}, @var{y2}]. The coordinates @var{x1}, @var{x2}, @var{y1}, @var{y2} are normalized to interval [0, 1]. This function set off any aspects or rotations. So it should be used first for creating subplot.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Rotate (@code{float} TetX, @code{float} TetZ, @code{float} TetY=@code{0})
Rotates a further plotting relative to each axis (x, z, y) consecutively on angles @var{TetX}, @var{TetZ}, @var{TetY}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} RotateN (@code{float} Tet, @code{float} x, @code{float} y, @code{float} z)
Rotates a further plotting around vector @{x,y,z@}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Aspect (@code{float} Ax, @code{float} Ay, @code{float} Az)
Defines aspect ratio for the plot. The viewable axes will be related one to another as the ratio @var{Ax:Ay:Az}. For the best effect it should be used after Rotate() function.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Perspective (@code{float} a)
Add (switch on) the perspective to plot. The parameter @math{a ~ 1/z_@{eff@} \in [0,1)}. By default (@code{a=0}) the perspective is off.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Identity ()
Clears transformation matrix. This function clears all previous effects of Aspect(), SubPlot(), InPlot() or Rotate() functions. It is equivalent to the call of  @code{InPlot(0,1,0,1)}.
@end deftypemethod


@c ##################################################################
@node Export to file (Python), Primitives drawing (Python), Transformation matrix (Python), Python interface
@subsection Export to file (Python)
@cindex WritePNG
@cindex WriteSVG
@cindex WriteBMP
@cindex WriteEPS
@cindex WriteTIFF
@cindex WriteJPEG
@cindex WriteIDTF
@cindex SetSize
@cindex Flush
@cindex Finish

These functions export current view to a graphic file. The filename @var{fname} should have appropriate extension. Parameter @var{descr} gives the short description of the picture. Just now the compression of TIFF files and transparency in EPS files are not supported.

@deftypemethod {mglGraph (Python)} @code{void} WritePNG (@code{const char *}fname, @code{const char *}descr=@code{NULL})
Exports current frame to PNG file with transparent background. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. By default there are no description added. This function does nothing if NO_PNG is defined during compilation of MathGL library.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} WritePNGSolid (@code{const char *}fname, @code{const char *}descr=@code{NULL})
Exports current frame to PNG file with non-transparent background (usually white). Parameter @var{fname} specifies the file name, @var{descr} adds description to file. By default there are no description added. This function does nothing if NO_PNG is defined during compilation of MathGL library.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} WriteJPEG (@code{const char *}fname, @code{const char *}descr=@code{NULL})
Exports current frame to JPEG file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. By default there is no description added. This function does nothing if NO_JPEG is defined during compilation of MathGL library.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} WriteBMP (@code{const char *}fname, @code{const char *}descr=@code{NULL})
Exports current frame to BMP file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. There is no compression used.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} WriteTIFF (@code{const char *}fname, @code{const char *}descr=@code{NULL}, @code{int} compr=@code{NULL})
Exports current frame to TIFF file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file, @var{compr} gives compression type. By default there are no description added and no compression used. This function does nothing if NO_TIFF is defined during compilation of MathGL library.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} WriteEPS (@code{const char *}fname, @code{const char *}descr=@code{NULL})
Exports current frame to EPS file. The vector representation is used if possible. So it is not recommended for the export of large data plot. It is better to use bitmap format (for example PNG or JPEG). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. By default there is no description added.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} WriteSVG (@code{const char *}fname, @code{const char *}descr=@code{NULL})
Exports current frame to SVG (Scalable Vector Graphics) file. The vector representation is used. In difference of EPS format, SVG format support transparency that allows to correctly draw half-transparent plot (like SurfA(), Surf3A(), CloudQ() or CloudP()). Note, the output file may be too large for graphic of large data array (especially for surfaces). It is better to use bitmap format (for example PNG or JPEG). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name).
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} WriteIDTF (@code{const char *}fname, @code{const char *}descr=@code{NULL})
Exports current frame to IDTF file. Later this file can be converted to U3D format. The vector representation is used. So, the output file may be too large for graphic of large data array (especially for surfaces). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name).
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SetSize (@code{int} width, @code{int} height)
Sets size of picture in pixels. This function @strong{must be} called before any other plotting because it completely remove picture contents.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Flush ()
Flushes the plotting commands to frame. This function may be useful if one wants to remove array before the finishing of the plot (i.e. before calling @code{Finish()}). Also call of this function separate the objects in mglGraphIDTF. Most of plots call this function internally.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{int} GetWidth ()
@deftypemethodx {mglGraph (Python)} @code{int} GetHeight ()
Gets width or height of the image.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{const char *} GetRGB ()
Gets RGB bitmap of the current state of the image. Format of each element of bits is: @{red, green, blue@}. Number of elements is Width*Height. Position of element @{i,j@} is [3*i + 3*Width*j].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{const char *} GetRGBA ()
Gets RGBA bitmap of the current state of the image. Format of each element of bits is: @{red, green, blue, alpha@}. Number of elements is Width*Height. Position of element @{i,j@} is [4*i + 4*Width*j].
@end deftypemethod


@c ##################################################################
@node Primitives drawing (Python), Text printing (Python), Export to file (Python), Python interface
@subsection Primitives drawing (Python)
@cindex Ball
@cindex Clf
@cindex Line
@cindex Curve
@cindex Glyph
@cindex Mark
@cindex Error
@cindex Face
@cindex FaceX
@cindex FaceY
@cindex FaceZ
@cindex Cone
@cindex Drop
@cindex Sphere

These functions draw some simple objects like line, point, sphere, drop, cone and so on.

@deftypemethod {mglGraph (Python)} @code{void} Clf (@code{float} r=@code{1}, @code{float} g=@code{1}, @code{float} b=@code{1})
Clear the picture and will it by color @{@var{r},@var{g},@var{b}@}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Ball (@code{float} x, @code{float} y, @code{float} z, @code{char *} col=@code{"r"})
Draws a point (ball) at position @var{p} with color @var{col}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Line (@code{float} x1, @code{float} y1, @code{float} z1, @code{float} x2, @code{float} y2, @code{float} z2, @code{char *}stl=@code{"B"}, @code{int}num=@code{2})
Draws a geodesic line (strightline in Cartesian coordinates) from point @{@var{x1},@var{y1},@var{z1}@} to @{@var{x2},@var{y2},@var{z2}@} using line style @var{stl}. Parameter @var{num} define the ``quality'' of the line. If @var{num}=@code{2} then the stright line will be drawn in all coordinate system (independently on transformation formulas (@pxref{Transformation}). Contrary, for large values (for example, =@code{100}) the geodesic line will be drawn in corresponding coordiante system (stright line in Cartesian coordinates, circle in polar coordinates and so on).
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Curve (@code{float} x1, @code{float} y1, @code{float} z1, @code{float} dx1, @code{float} dy1, @code{float} dz1, @code{float} x2, @code{float} y2, @code{float} z2, @code{float} dx2, @code{float} dy2, @code{float} dz2, @code{const char *}stl=@code{"B"}, @code{int} num=@code{100})
Draws Bezier-like curve from point @{@var{x1},@var{y1},@var{z1}@} to @{@var{x2},@var{y2},@var{z2}@} using line style @var{stl}. At this tangent is codirected with @{@var{dx1},@var{dy1},@var{dz1}@}, @{@var{dx2},@var{dy2},@var{dz2}@} and proportional to its amplitude. Parameter @var{num} define the ``quality'' of the curve. If @var{num}=@code{2} then the stright line will be drawn in all coordinate system (independently on transformation formulas (@pxref{Transformation}). Contrary, for large values (for example, =@code{100}) the spline like Bezier curve will be drawn in corresponding coordiante system.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Face (@code{mglPoint} p1, @code{mglPoint} p2, @code{mglPoint} p3, @code{mglPoint} p4, @code{const char *}stl=@code{"w"}, @code{int} num=@code{2})
Draws the solid quadrangle (face) with vertexes @var{p1}, @var{p2}, @var{p3}, @var{p4} and with color(s) @var{stl}. At this colors can be the same for all vertexes or different if all 4 colors are specified for each vertex.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} FaceX (@code{float} x0, @code{float} y0, @code{float} z0, @code{float} wy, @code{float} wz, @code{const char *}stl=@code{"w"}, @code{float} dx=@code{0}, @code{float} dy=@code{0})
@deftypemethodx {mglGraph (Python)} @code{void} FaceY (@code{float} x0, @code{float} y0, @code{float} z0, @code{float} wx, @code{float} wz, @code{const char *}stl=@code{"w"}, @code{float} dx=@code{0}, @code{float} dy=@code{0})
@deftypemethodx {mglGraph (Python)} @code{void} FaceZ (@code{float} x0, @code{float} y0, @code{float} z0, @code{float} wx, @code{float} wy, @code{const char *}stl=@code{"w"}, @code{float} dx=@code{0}, @code{float} dy=@code{0})
Draws the solid rectangle (face) perpendicular to [x,y,z]-axis correspondingly at position @{@var{x0}, @var{y0}, @var{z0}@} with color @var{stl} and with widths @var{wx}, @var{wy}, @var{wz} along corresponding directions. At this colors can be the same for all vertexes or different if all 4 colors are specified for each vertex. Parameters @var{d1}!=0, @var{d2}!=0 set additional shift of the last vertex (i.e. to draw quadrangle).
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Sphere (@code{float} x0, @code{float} y0, @code{float} z0, @code{float} r, @code{const char *}stl=@code{"r"})
Draw the spehere with radius @var{r} and center at point @{@var{x0}, @var{y0}, @var{z0}@} and color @var{stl}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Drop (@code{float} x0, @code{float} y0, @code{float} z0, @code{float} dx, @code{float} dy, @code{float} dz, @code{float} r, @code{const char *}col="r", @code{float} shift=@code{1}, @code{float} ap=@code{1})
Draw the drop with radius @var{r} at point @var{p} elongated in direction @var{q} and with color @var{col}. Parameter @var{shift} set the degree of drop oblongness: @samp{0} is sphere, @samp{1} is maximally oblongness drop. Parameter @var{ap} set relative width of the drop (this is analogue of ``ellipticity'' for the sphere). @sref{Drops sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Cone (@code{float} x1, @code{float} y1, @code{float} z1, @code{float} x2, @code{float} y2, @code{float} z2, @code{float} r1, @code{float} r2=@code{-1}, @code{const char *}stl=@code{"B"}, @code{bool} edge=@code{false})
Draw tube (or truncated cone if @var{edge}=@code{false}) between points @{@var{x1},@var{y1},@var{z1}@}, @{@var{x2},@var{y2},@var{z2}@} with radiuses at the edges @var{r1}, @var{r2}. If @var{r2}<0 then it is suppsosed that @var{r2}=@var{r1}. The cone color is defined by string @var{stl}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Mark (@code{float} x, @code{float} y, @code{float} z, @code{char} mark)
Draws a marks of different type at position @{@var{x},@var{y},@var{z}@}.
@end deftypemethod

@c ##################################################################
@node Text printing (Python), Axis and Colorbar (Python), Primitives drawing (Python), Python interface
@subsection Text printing (Python)
@cindex Puts
@cindex Putsw
@cindex Text
@cindex Title

These functions draw the text. There are functions for drawing text in arbitrary place, in arbitrary direction and along arbitrary curve. The class mglFont (@pxref{mglFont class}) is used for low-level string parsing and printing. It can use arbitrary fontfaces and parse many TeX commands. All these functions have 2 variant: for printing 8-bit text (@code{char *}) and for printing Unicode text (@code{wchar_t *}). In first case the conversion in current locale is used. So sometimes you need to specify it by @code{setlocale()} function. The size argument control the size of text: if positive it give the value, if negative it give the value relative to @var{FontSize}. The font type (STIX, arial, courier, times and so on) can be selected by function LoadFont(). @xref{Font settings (Python)}.

The font parameters are described by string. This string may contain several characters of font type (@samp{rbiwou}) and/or align (@samp{LRC}) specification. Also it may contain the text color @samp{wkrgbcymhRGBCYMHW} (@pxref{mglColor class}) after symbol @samp{:}. The font types are: @samp{r} -- roman font, @samp{i} -- italic style, @samp{b} -- bold style, @samp{w} -- wired style, @samp{o} -- overlined text, @samp{u} -- underlined text. By default roman font is used. The align types are: @samp{L} -- align left (default), @samp{C} -- align center, @samp{R} -- align right. Also a parsing of the LaTeX-like syntax is provided (for detail @pxref{mglFont class}). For example, string @samp{iC:b} correspond to italic font style for centered text which printed by blue color.

@deftypemethod {mglGraph (Python)} @code{void} Puts (@code{float} x, @code{float} y, @code{float} z, @code{const char *}text, @code{const char *}font=@code{NULL}, @code{float} size=@code{-1}, @code{char} dir=@code{0})
@deftypemethodx {mglGraph (Python)} @code{void} Putsw (@code{float} x, @code{float} y, @code{float} z, @code{const wchar_t *}text, @code{const char *}font=@code{NULL}, @code{float} size=@code{-1}, @code{char} dir=@code{0})
The function plots the string @var{text} at position @{@var{x},@var{y},@var{z}@} with fonts specifying by the criteria @var{how}. The size of font is set by @var{size} parameter (default is @var{FontSize}). Parameter @var{dir} specifies the additional string align. The aligns are: @samp{x} -- align as x-label, @samp{y} -- align as y-label, @samp{z} -- align as z-label, @samp{i} -- align as x-label but inverse writing direction, @samp{t} -- no align (default), @samp{n} -- align in x-y plane.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Puts (@code{float} x, @code{float} y, @code{float} z, @code{float} dx, @code{float} dy, @code{float} dz, @code{const char *}text, @code{char}where=@code{'t'}, @code{float} size=@code{-1})
@deftypemethodx {mglGraph (Python)} @code{void} Putsw (@code{float} x, @code{float} y, @code{float} z, @code{float} dx, @code{float} dy, @code{float} dz, @code{const wchar_t *}text, @code{char}where=@code{'t'}, @code{float} size=@code{-1})
The function plots the string @var{text} at position @{@var{x},@var{y},@var{z}@} along direction @{@var{dx},@var{dy},@var{dz}@} with specified @var{size}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Title (@code{const char *}text, @code{const char *}font=@code{0})
@deftypemethodx {mglGraph (Python)} @code{void} Title (@code{const wchar_t *}text, @code{const char *}font=@code{0})
Print string @var{text} as title of the picture (at the top of the picture). Can be used at any place (even inside SubPlot()).
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Text (@code{mglData *}y, @code{const char *}text, @code{const char *}font=@code{NULL}, float size=@code{-1})
@deftypemethodx {mglGraph (Python)} @code{void} Text (@code{mglData *}y, @code{const wchar_t *}text, @code{const char *}font=@code{NULL}, float size=@code{-1})
@deftypemethodx {mglGraph (Python)} @code{void} Text (@code{mglData *}x, @code{mglData *}y, @code{const char *}text, @code{const char *}font=@code{NULL}, float size=@code{-1})
@deftypemethodx {mglGraph (Python)} @code{void} Text (@code{mglData *}x, @code{mglData *}y, @code{const wchar_t *}text, @code{const char *}font=@code{NULL}, float size=@code{-1})
@deftypemethodx {mglGraph (Python)} @code{void} Text (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{const char *}text, @code{const char *}font=@code{NULL}, float size=@code{-1})
@deftypemethodx {mglGraph (Python)} @code{void} Text (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{const wchar_t *}text, @code{const char *}font=@code{NULL}, float size=@code{-1})
The function draws @var{text} along the curve between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} by font style @var{font} and with size @var{size}. The string @var{font} may contain symbols @samp{t} for printing the text under the curve (default), or @samp{T} for printing the text above the curve. The sizes of 1st dimension must be equal for all arrays @var{x.nx=y.nx=z.nx}. If array @var{x} is not specified then its an automatic array is used with values equidistantly distributed in interval [@var{Min}.x, @var{Max}.x] (@pxref{Ranges (bounding box)}). @sref{Text sample}
@end deftypemethod

@c ##################################################################
@node Axis and Colorbar (Python), Legend (Python), Text printing (Python), Python interface
@subsection Axis and Colorbar (Python)
@cindex Axis
@cindex Box
@cindex Grid
@cindex Colorbar
@cindex Label

These functions draw the ``things for measuring'', like axis with ticks, colorbar with ticks, grid along axis, bounding box and labels for axis. For more information @pxref{Axis settings (Python)}.

@deftypemethod {mglGraph (Python)} @code{void} Axis (@code{const char *}dir=@code{"xyz"})
Draws axes with ticks (@pxref{Axis settings}) in directions determined by string parameter @var{dir}.If string contain the symbol @samp{_} then tick labels are not printed. Font for ticks labels is determined by @var{FontDef} (@pxref{Font settings}).
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Colorbar (@code{const char *}sch=@code{NULL}, @code{int} where=@code{0})
Draws colorbar with color scheme @var{sch} (current scheme if @code{sch=NULL}) at edge of plot. Parameter @var{where} specifies the position of colorbar: @samp{0} - at right (default), @samp{1} - at left, @samp{2} - at top, @samp{3} - at bottom. @sref{Dens sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Grid (@code{const char *}dir=@code{"xyz"}, @code{const char *}pen=@code{"B-"})
Draws grid lines perpendicular to direction determined by string parameter @var{dir}. The step of grid lines is the same as tick step for an Axis(). The style of lines is determined by @var{pen} parameter (default value is dark blue solid line (@samp{B-}).
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Box (@code{const char *}col, @code{bool} ticks=@code{true})
Draws bounding box outside the plotting volume with color @var{col}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Label (@code{char} dir, @code{const char *}text, @code{int} pos=@code{+1}, @code{float} size=@code{-1.4}, @code{float} shift=@code{0})
Prints the label @var{text} for axis @var{dir}. The position of label is determined by @var{pos} parameter. If @var{pos}=0 then label is printed at the center of axis. If @var{pos}>0 then label is printed at the maximum of axis. If @var{pos}<0 then label is printed at the minimum of axis. Parameter @var{size} determines the font size for the label. By default the font size is 1.4 times larger than the one for ticks @var{FontSize} (@pxref{Font settings}). @xref{Text printing}.
@end deftypemethod

@c ##################################################################
@node Legend (Python), 1D plotting (Python), Axis and Colorbar (Python), Python interface
@subsection Legend (Python)
@cindex Legend
@cindex AddLegend
@cindex ClearLegend

These functions draw legend to the graph (useful for @ref{1D plotting}). Legend entry is a pair of strings: one for style of the line, another one with description text (with included LaTeX parsing). The array of string may be used directly or by accumulating first to the internal arrays (by function AddLegend()) and further plotting it. The position of the legend can be selected automatic or manually. Parameters @var{font} and @var{size} specify the font style and size (@pxref{Font settings (Python)}). Parameter @var{llen} set the relative width of the line sample and the text indent. If line style string for entry is empty then the corresponding text is printed without indent. @sref{Legend sample}

@deftypemethod {mglGraph (Python)} @code{void} Legend (@code{int} where=@code{0x3}, @code{const char *}font=@code{"rL"}, @code{float} size=@code{-0.8}, @code{float} llen=@code{0.1})
Draws legend of accumulated legend entries by font @var{font} with @var{size}. Parameter @var{where} sets the position of the legend: @samp{0} is bottom left corner, @samp{1} is bottom right corner, @samp{2} is top left corner, @samp{3} is top right corner (is default).
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Legend (@code{float} x, @code{float} y, @code{const char *}font=@code{"rL"}, @code{float} size=@code{-0.8}, @code{float} llen=@code{0.1})
Draws legend of accumulated legend entries by font @var{font} with @var{size}. Position of legend is determined by parameter @var{x}, @var{y} which supposed to be normalized to interval [0,1].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} AddLegend (@code{const char *}text, @code{const char *}style)
@deftypemethodx {mglGraph (Python)} @code{void} AddLegend (@code{const wchar_t *}text, @code{const char *}style)
Adds string @var{text} to internal legend accumulator. The style of described line and mark is specified in string @var{style} (@pxref{Line styles}). Maximal number of entries is 100.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ClearLegend ()
Clears saved legend strings.
@end deftypemethod

@c ##################################################################
@node 1D plotting (Python), 2D plotting (Python), Legend (Python), Python interface
@subsection 1D plotting (Python)

These functions perform plotting of 1D data. 1D means that data depended from only 1 parameter like parametric curve @{x(i),y(i),z(i)@}, i=1...n. There are 5 generally different types of data representations: simple line plot (Plot), line plot with filling under it (Area), stairs plot (Step), bar plot (Bars, Barh) and vertical lines (Stem). Each type of plotting has similar interface. There are 3D version and two 2D versions. One of last requires single array. The parameters of line and marks are specified by the string argument. If the string parameter is NULL then solid line with color from palette Pal is used (@pxref{Palette and colors (Python)}). Also there are some special 1d plots having slightly different interface: surface of curve rotation (Torus), chart (Chart) and error boxes (Error), marks with variable size (Mark), tubes (Tube) and so on. @xref{Line styles}.


@menu
* Plot (Python)::               
* Area (Python)::               
* Region (Python)::             
* Bars (Python)::               
* Barh (Python)::               
* Stem (Python)::               
* Step (Python)::               
* Torus (Python)::              
* Chart (Python)::              
* Mark (Python)::               
* TextMark (Python)::           
* Error (Python)::              
* Tube (Python)::               
@end menu


@c ==================================================================
@node Plot (Python), Area (Python), , 1D plotting (Python)
@subsubsection Plot (Python)
@cindex Plot

These functions draw continuous lines between points. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Area}, @ref{Step}, @ref{Stem}, @ref{Tube}, @ref{Mark}, @ref{Error}, @ref{Belt}. @sref{Plot sample}

@deftypemethod {mglGraph (Python)} @code{void} Plot (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{const char *}pen=@code{NULL})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Plot (@code{mglData *}x, @code{mglData *}y, @code{const char *}pen=@code{NULL})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Plot (@code{mglData *}y, @code{const char *}pen=@code{NULL})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@c ==================================================================
@node Area (Python), Region (Python), Plot (Python), 1D plotting (Python)
@subsubsection Area (Python)
@cindex Area

These functions draw continuous lines between points and fills it to axis plane. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Plot}, @ref{Bars}, @ref{Stem}. @sref{Area sample}

@deftypemethod {mglGraph (Python)} @code{void} Area (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{const char *}pen=@code{NULL})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space and fills it down to @var{z} = Org.z.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Area (@code{mglData *}x, @code{mglData *}y, @code{const char *}pen=@code{NULL})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z} and fills it down to @var{y} = Org.y.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Area (@code{mglData *}y, @code{const char *}pen=@code{NULL})
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z} and fills it down to @var{y} = Org.y, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@c ==================================================================
@node Region (Python), Bars (Python), Area (Python), 1D plotting (Python)
@subsubsection Region (Python)
@cindex Region

These functions fill area between 2 curves. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y1.nx=y2.nx} and all dimensions of arrays @var{y1} and @var{y2} must be equal too. String @var{pen} specifies the color (@pxref{Line styles}). By default (@code{pen=NULL}) color from palette is used (@pxref{Palette and colors (Python)}). See also @ref{Area}, @ref{Bars}, @ref{Stem}. @sref{Region sample}

@deftypemethod {mglGraph (Python)} @code{void} Region (@code{mglData *}x, @code{mglData *}y1, @code{mglData *}y2, @code{const char *}pen=@code{NULL}, @code{bool} inside=@code{true})
The function fills area between curves @{@var{x}[i], @var{y}[i]@} and @{@var{x}[i], @var{y2}[i]@}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Region (@code{mglData *}y1, @code{mglData *}y2, @code{const char *}pen=@code{NULL}, @code{bool} inside=@code{true})
The function fills area between curves @{@var{x}[i], @var{y}[i]@} and @{@var{x}[i], @var{y2}[i]@}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod


@c ==================================================================
@node Bars (Python), Barh (Python), Region (Python), 1D plotting (Python)
@subsubsection Bars (Python)
@cindex Bars

These functions draw vertical bars from points to axis plane. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Barh}, @ref{Area}, @ref{Stem}, @ref{Chart}, @ref{Default sizes}. @sref{Bars sample}

@deftypemethod {mglGraph (Python)} @code{void} Bars (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{const char *}pen=@code{NULL})
The function draws vertical bars from points @{@var{x}[i], @var{y}[i], @var{z}[i]@} down to @var{z} = Org.z.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Bars (@code{mglData *}x, @code{mglData *}y, @code{const char *}pen=@code{NULL})
The function draws vertical bars from points @{@var{x}[i], @var{y}[i]@} down to @var{y} = Org.y in plane @var{z}=@var{Min.z}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Bars (@code{mglData *}y, @code{const char *}pen=@code{NULL})
The function draws vertical bars from points @{@var{x}[i], @var{y}[i]@} down to @var{y} = Org.y in plane @var{z}=@var{Min.z}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@c ==================================================================
@node Barh (Python), Stem (Python), Bars (Python), 1D plotting (Python)
@subsubsection Barh (Python)
@cindex Barh

These functions draw horizontal bars from points to axis plane. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Barh}, @ref{Default sizes}. @sref{Barh sample}

@deftypemethod {mglGraph (Python)} @code{void} Barh (@code{mglData *}y, @code{mglData *}v, @code{const char *}pen=@code{NULL})
The function draws horizontal bars from points @{@var{v}[i], @var{y}[i]@} down to @var{x} = Org.x in plane @var{z}=@var{Min.z}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Barh (@code{mglData *}v, @code{const char *}pen=@code{NULL})
The function draws horizontal bars from points @{@var{v}[i], @var{y}[i]@} down to @var{x} = Org.x in plane @var{z}=@var{Min.z}, where @var{y}[i] values are equidistantly distributed in interval [@var{Min}.y, @var{Max}.y].
@end deftypemethod

@c ==================================================================
@node Stem (Python), Step (Python), Barh (Python), 1D plotting (Python)
@subsubsection Stem (Python)
@cindex Stem

These functions draw vertical lines from points to axis plane. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Area}, @ref{Bars}, @ref{Plot}. @sref{Stem sample}

@deftypemethod {mglGraph (Python)} @code{void} Stem (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{const char *}pen=@code{NULL})
The function draws vertical lines from points @{@var{x}[i], @var{y}[i], @var{z}[i]@} down to @var{z} = Org.z.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Stem (@code{mglData *}x, @code{mglData *}y, @code{const char *}pen=@code{NULL})
The function draws vertical lines from points @{@var{x}[i], @var{y}[i]@} down to @var{y} = Org.y in plane @var{z}=@var{Min.z}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Stem (@code{mglData *}y, @code{const char *}pen=@code{NULL})
The function draws vertical lines from points @{@var{x}[i], @var{y}[i]@} down to @var{y} = Org.y in plane @var{z}=@var{Min.z}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@c ==================================================================
@node Step (Python), Torus (Python), Stem (Python), 1D plotting (Python)
@subsubsection Step (Python)
@cindex Step

These functions draw continuous stairs for points to axis plane. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Plot}, @ref{Stem}, @ref{Tile}, @ref{Boxs}. @sref{Step sample}

@deftypemethod {mglGraph (Python)} @code{void} Step (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{const char *}pen=@code{NULL})
The function draws continuous stairs for points @{@var{x}[i], @var{y}[i], @var{z}[i]@}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Step (@code{mglData *}x, @code{mglData *}y, @code{const char *}pen=@code{NULL})
The function draws continuous stairs for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Step (@code{mglData *}y, @code{const char *}pen=@code{NULL})
The function draws continuous stairs for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@c ==================================================================
@node Torus (Python), Chart (Python), Step (Python), 1D plotting (Python)
@subsubsection Torus (Python)
@cindex Torus

These functions draw surface which is result of curve @{@var{r}, @var{z}@} rotation around @var{AxialDir} axis (@pxref{Other settings}). The sizes of 1st dimension @strong{must be equal} for all arrays @var{r.nx=z.nx}. String @var{pen} specifies the color (@pxref{Line styles}). By default (@code{pen=NULL}) color from palette is used (@pxref{Palette and colors}). See also @ref{Plot}, @ref{Axial}. @sref{Torus sample}

@deftypemethod {mglGraph (Python)} @code{void} Torus (@code{mglData *}r, @code{mglData *}z, @code{const char *}pen=@code{NULL})
The function draws surface which is result of curve @{@var{r}[i], @var{z}[i]@} rotation.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Torus (@code{mglData *}z, @code{const char *}pen=@code{NULL})
The function draws surface which is result of curve @{@var{r}[i], @var{z}[i]@} rotation, where @var{r}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@c ==================================================================
@node Chart (Python), Mark (Python), Torus (Python), 1D plotting (Python)
@subsubsection Chart (Python)
@cindex Chart

@deftypemethod {mglGraph (Python)} @code{void} Chart (@code{mglData *}a, @code{const char *}col=@code{NULL})
The function draws colored stripes (boxes) for data in array @var{a}. The number of stripes is equal to the number of rows in @var{a} (equal to @var{a.ny}). The color of each next stripe is ciclically changed from colors specified in string @var{col} or in palette Pal (@pxref{Palette and colors}). Spaces in colors denote transparent ``color'', i.e. if @var{col} contain space(s) then corresponding stripe(s) are not drawn. The stripe width is proportional to value of element in @var{a}. Chart is plotted only for data with non-negative elements. If string @var{col} have symbol @samp{#} then black border lines are drawn. The most nice form the chart have in 3d (after rotation of coordiantes) or in cilindrical coordinates (becomes so called Pie chart). @sref{Chart sample}
@end deftypemethod

@c ==================================================================
@node Mark (Python), TextMark (Python), Chart (Python), 1D plotting (Python)
@subsubsection Mark (Python)
@cindex Mark

These functions draw marks with size @var{r}*@var{MarkSize} (@pxref{Default sizes}) at points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx=r.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). If you need to draw markers of the same size then you may use @ref{Plot} function. See also @ref{Plot}, @ref{TextMark}, @ref{Stem}, @ref{Error}. @sref{Mark sample}

@deftypemethod {mglGraph (Python)} @code{void} Mark (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}r, @code{const char *}pen=@code{NULL})
The function draws marks for points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Mark (@code{mglData *}x, @code{mglData *}y, @code{mglData *}r, @code{const char *}pen=@code{NULL})
The function draws marks for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Mark (@code{mglData *}y, @code{mglData *}r, @code{const char *}pen=@code{NULL})
The function draws marks for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@c ==================================================================
@node TextMark (Python), Error (Python), Mark (Python), 1D plotting (Python)
@subsubsection TextMark (Python)
@cindex TextMark

These functions draw string @var{text} as marks with size proportional to @var{r}*@var{MarkSize} (@pxref{Default sizes}) at points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx=r.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Plot}, @ref{Mark}, @ref{Stem}. @sref{TextMark sample}

@deftypemethod {mglGraph (Python)} @code{void} TextMark (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}r, @code{const wchar_t *}text, @code{const char *}fnt=@code{NULL})
@deftypemethodx {mglGraph (Python)} @code{void} TextMark (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}r, @code{const char *}text, @code{const char *}fnt=@code{NULL})
The function draws textual marks for points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} TextMark (@code{mglData *}x, @code{mglData *}y, @code{mglData *}r, @code{const wchar_t *}text, @code{const char *}fnt=@code{NULL})
@deftypemethodx {mglGraph (Python)} @code{void} TextMark (@code{mglData *}x, @code{mglData *}y, @code{mglData *}r, @code{const char *}text, @code{const char *}fnt=@code{NULL})
The function draws textual marks for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} TextMark (@code{mglData *}y, @code{mglData *}r, @code{const wchar_t *}text, @code{const char *}fnt=@code{NULL})
@deftypemethodx {mglGraph (Python)} @code{void} TextMark (@code{mglData *}y, @code{mglData *}r, @code{const char *}text, @code{const char *}fnt=@code{NULL})
The function draws textual marks for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} TextMark (@code{mglData *}y, @code{const wchar_t *}text, @code{const char *}fnt=@code{NULL})
@deftypemethodx {mglGraph (Python)} @code{void} TextMark (@code{mglData *}y, @code{const char *}text, @code{const char *}fnt=@code{NULL})
The function draws textual marks for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x]. The mark sizes @var{r}[i]=1 for all points.
@end deftypemethod

@c ==================================================================
@node Error (Python), Tube (Python), TextMark (Python), 1D plotting (Python)
@subsubsection Error (Python)
@cindex Error

These functions draw error boxes at points @{@var{x}[i], @var{y}[i]@}  on plane @var{z} = @var{Min.z}. This can be useful, for example, in experimental points, or to show numeric error or some estimations and so on. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx=r.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Plot}. @sref{Error sample}

@deftypemethod {mglGraph (Python)} @code{void} Error (@code{mglData *}x, @code{mglData *}y, @code{mglData *}ex, @code{mglData *}ey, @code{const char *}pen=@code{NULL})
Draws a error box @{@var{ex}, @var{ey}@} in point position @{@var{x}, @var{y}@}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Error (@code{mglData *}x, @code{mglData *}y, @code{mglData *}ey, @code{const wchar_t *}pen=@code{NULL})
Draws a error box @var{ey} (along only one direction) in point position @{@var{x}, @var{y}@}.
@end deftypemethod
@deftypemethod {mglGraph (Python)} @code{void} Error (@code{mglData *}y, @code{mglData *}ey, @code{const char *}pen=@code{NULL})
Draws a error box @var{ey} (along only one direction) in point position @{@var{x}, @var{y}@}, where @var{x} values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@c ==================================================================
@node Tube (Python), , Error (Python), 1D plotting (Python)
@subsubsection Tube (Python)
@cindex Tube

These functions draw the tube with variable radius @var{r}[i] along the curve between points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx=r.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Plot}. @sref{Tube sample}

@deftypemethod {mglGraph (Python)} @code{void} Tube (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}r, @code{const char *}pen=@code{NULL})
@deftypemethodx {mglGraph (Python)} @code{void} Tube (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{float} r, @code{const char *}pen=@code{NULL})
The function draws tube with radius @var{r} between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Tube (@code{mglData *}x, @code{mglData *}y, @code{mglData *}r, @code{const char *}pen=@code{NULL})
@deftypemethodx {mglGraph (Python)} @code{void} Tube (@code{mglData *}x, @code{mglData *}y, @code{float} r, @code{const char *}pen=@code{NULL})
The function draws tube with radius @var{r} beween points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Tube (@code{mglData *}y, @code{mglData *}r, @code{const char *}pen=@code{NULL})
@deftypemethodx {mglGraph (Python)} @code{void} Tube (@code{mglData *}y, @code{float} r, @code{const char *}pen=@code{NULL})
The function draws tube with radius @var{r} beween points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@c ##################################################################
@node 2D plotting (Python), 3D plotting (Python), 1D plotting (Python), Python interface
@subsection 2D plotting (Python)

These functions perform plotting of 2D data. 2D means that data depend from 2 independent parameters like matrix @math{f(x_i,y_j), i=1...n, j=1...m}. There are 6 generally different types of data representations: simple mesh lines plot (Mesh), surface plot (Surf), surface plot by boxes (Boxs), surface plot by tiles (Tile), waterfall-like plot (Fall), belt plot (Belt), density plot (Dens), contour lines plot (Cont), solid contours plot (ContF) and its rotational figure (Axial). Cont, ContF and Axial functions have variants for automatic and manual selection of level values for contours. Also there are functions for plotting data grid lines according to the data format (Grid) for enhancing density or contour plots. Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@menu
* Mesh (Python)::               
* Fall (Python)::               
* Belt (Python)::               
* Surf (Python)::               
* Boxs (Python)::               
* Tile (Python)::               
* Dens (Python)::               
* Cont (Python)::               
* ContF (Python)::              
* Axial (Python)::              
* Grid (Python)::               
@end menu

@c ==================================================================
@node Mesh (Python), Fall (Python), , 2D plotting (Python)
@subsubsection Mesh (Python)
@cindex Mesh

@deftypemethod {mglGraph (Python)} @code{void} Mesh (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{const char *}sch=@code{NULL})
The function draws mesh lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Mesh lines are plotted for each z slice of the data. See also @ref{Surf}, @ref{Fall}, NeshNum (@pxref{Other settings}), @ref{Cont}. @sref{Mesh sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Mesh (@code{mglData *}z, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Fall (Python), Belt (Python), Mesh (Python), 2D plotting (Python)
@subsubsection Fall (Python)
@cindex Fall

@deftypemethod {mglGraph (Python)} @code{void} Fall (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{const char *}sch=@code{NULL})
The function draws fall lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If @var{sch} contain @samp{x} then lines are drawn along x-direction else (by default) lines are drawn along y-direction. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Fall lines are plotted for each z slice of the data. See also @ref{Belt}, @ref{Mesh}, NeshNum (@pxref{Other settings}). @sref{Fall sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Fall (@code{mglData *}z, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Belt (Python), Surf (Python), Fall (Python), 2D plotting (Python)
@subsubsection Belt (Python)
@cindex Belt

@deftypemethod {mglGraph (Python)} @code{void} Belt (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{const char *}sch=@code{NULL})
The function draws belts for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. This plot can be used as 3d generalization of Plot (@pxref{Plot}). String @var{sch} sets the color scheme. Previous color scheme is used by default. If @var{sch} contain @samp{x} then belts are drawn along x-direction else (by default) belts are drawn along y-direction. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Belts are plotted for each z slice of the data. See also @ref{Fall}, @ref{Surf}, @ref{Plot}, NeshNum (@pxref{Other settings}). @sref{Belt sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Belt (@code{mglData *}z, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Surf (Python), Boxs (Python), Belt (Python), 2D plotting (Python)
@subsubsection Surf (Python)
@cindex Surf

@deftypemethod {mglGraph (Python)} @code{void} Surf (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{const char *}sch=@code{NULL})
The function draws surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Mesh}, @ref{Dens}, @ref{Belt}, @ref{Tile}, @ref{Boxs}, @ref{SurfC}, @ref{SurfA}. @sref{Surf sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Surf (@code{mglData *}z, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Boxs (Python), Tile (Python), Surf (Python), 2D plotting (Python)
@subsubsection Boxs (Python)
@cindex Boxs

@deftypemethod {mglGraph (Python)} @code{void} Boxs (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{const char *}sch=@code{NULL})
The function draws vertical boxes for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Surf}, @ref{Tile}, @ref{Step}. @sref{Boxs sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Boxs (@code{mglData *}z, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Tile (Python), Dens (Python), Boxs (Python), 2D plotting (Python)
@subsubsection Tile (Python)
@cindex Tile

@deftypemethod {mglGraph (Python)} @code{void} Tile (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{const char *}sch=@code{NULL})
The function draws horizontal tiles for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. Such plot can be used as 3d generalization of Step (@pxref{Step}). String @var{sch} sets the color scheme. Previous color scheme is used by default. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Surf}, @ref{Boxs}, @ref{Step}, @ref{TileS}. @sref{Tile sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Tile (@code{mglData *}z, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Dens (Python), Cont (Python), Tile (Python), 2D plotting (Python)
@subsubsection Dens (Python)
@cindex Dens

@deftypemethod {mglGraph (Python)} @code{void} Dens (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws density plot for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z} = @var{zVal}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Surf}, @ref{Cont}, @ref{ContF}, @ref{DensXYZ}. @sref{Dens sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Dens (@code{mglData *}z, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Cont (Python), ContF (Python), Dens (Python), 2D plotting (Python)
@subsubsection Cont (Python)
@cindex Cont

@deftypemethod {mglGraph (Python)} @code{void} Cont (@code{mglData *}v, @code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws contour lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z} = @var{zVal} (or for @var{z=v}[k] if @code{zVal==NAN}). Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Dens}, @ref{ContF}, @ref{Axial}, @ref{ContXYZ}. @sref{Cont sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Cont (@code{mglData *}v, @code{mglData *}z, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Cont (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{const char *}sch=@code{NULL}, @code{int} num=@code{7}, @code{float} zVal=@code{NAN})
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Cont (@code{mglData *}z, @code{const char *}sch=@code{NULL}, @code{int} num=@code{7}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node ContF (Python), Axial (Python), Cont (Python), 2D plotting (Python)
@subsubsection ContF (Python)
@cindex ContF

@deftypemethod {mglGraph (Python)} @code{void} ContF (@code{mglData *}v, @code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws solid (or filled) contour lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z} = @var{zVal} (or for @var{z=v}[k] if @code{zVal==NAN}). Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Dens}, @ref{Cont}, @ref{Axial}, @ref{ContFXYZ}. @sref{ContF sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContF (@code{mglData *}v, @code{mglData *}z, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContF (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{const char *}sch=@code{NULL}, @code{int} num=@code{7}, @code{float} zVal=@code{NAN})
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContF (@code{mglData *}z, @code{const char *}sch=@code{NULL}, @code{int} num=@code{7}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Axial (Python), Grid (Python), ContF (Python), 2D plotting (Python)
@subsubsection Axial (Python)
@cindex Axial

@deftypemethod {mglGraph (Python)} @code{void} Axial (@code{mglData *}v, @code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{const char *}sch=@code{NULL})
The function draws surface which is result of contour plot rotation for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then wire plot is produced. If string contain symbols @samp{x}, @samp{y} or @samp{z} then rotation axis @var{AxialDir} (@pxref{Other settings}) will be set to specified direction. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Cont}, @ref{ContF}, @ref{Torus}, @ref{Surf3}. @sref{Axial sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Axial (@code{mglData *}v, @code{mglData *}z, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Axial (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{const char *}sch=@code{NULL}, @code{int} num=@code{3})
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Axial (@code{mglData *}z, @code{const char *}sch=@code{NULL}, @code{int} num=@code{3})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Grid (Python), , Axial (Python), 2D plotting (Python)
@subsubsection Grid (Python)
@cindex Grid

@deftypemethod {mglGraph (Python)} @code{void} Grid (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws grid lines for density plot of surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z} = @var{zVal}. String @var{sch} sets the color scheme. Previous color scheme is used by default. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Grid is plotted for each z slice of the data. See also @ref{Dens}, @ref{Cont}, @ref{ContF}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Grid (@code{mglData *}z, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod


@c ##################################################################
@node 3D plotting (Python), Dual plotting (Python), 2D plotting (Python), Python interface
@subsection 3D plotting (Python)

These functions perform plotting of 3D data. 3D means that data depend from 3 independent parameters like matrix @math{f(x_i,y_j,z_k), i=1...n, j=1...m, k=1...l}. There are 4 generally different types of data representations: isosurface or surface of constant value (Surf3), density plot at slices (Dens3), contour lines plot at slices (Cont3), solid contours plot at slices (ContF3) and cloud-like plot (Cloud). Surf3, Cont3 and ContF3 functions have variants for automatic and manual selection of level values for surfaces/contours. Also there are functions for plotting data grid lines according to the data format (Grid3) for enhancing density or contour plots. Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@menu
* Surf3 (Python)::              
* Dens3 (Python)::              
* Cont3 (Python)::              
* ContF3 (Python)::             
* Grid3 (Python)::              
* Cloud (Python)::              
* Beam (Python)::               
@end menu

@c ==================================================================
@node Surf3 (Python), Dens3 (Python), , 3D plotting (Python)
@subsubsection Surf3 (Python)
@cindex Surf3

@deftypemethod {mglGraph (Python)} @code{void} Surf3 (@code{float} val, @code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}a, @code{const char *}stl=@code{NULL})
The function draws isosurface plot for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) at @var{a}(x,y,z)=@var{val}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). Note, that there is possibility of incorrect plotting due to uncertainty of cross-subsection defining if there are two or more isosurface intersubsections inside one cell. See also @ref{Cloud}, @ref{Dens3}, @ref{Surf3C}, @ref{Surf3A}, @ref{Axial}. @sref{Surf3 sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Surf3 (@code{float} val, @code{mglData *}a, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Surf3 (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}a, @code{const char *}stl=@code{NULL}, @code{int} num=@code{3})
Draws @var{num}-th uniformly distributed in range [@var{Cmin}, @var{Cmax}] isosurfaces for 3d data specified parametrically.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Surf3 (@code{mglData *}a, @code{const char *}sch=@code{NULL}, @code{int} num=@code{3})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Dens3 (Python), Cont3 (Python), Surf3 (Python), 3D plotting (Python)
@subsubsection Dens3 (Python)
@cindex Dens3
@cindex DensA

@deftypemethod {mglGraph (Python)} @code{void} Dens3 (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}stl=@code{NULL})
The function draws density plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Density is plotted at slice @var{sVal} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{stl} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). See also @ref{Cont3}, @ref{ContF3}, @ref{Dens}, @ref{Grid3}. @sref{Dens3 sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Dens3 (@code{mglData *}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} DensA (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}a, @code{const char *}stl=@code{NULL})
Draws density plots at all central slices of the 3d data specified parametrically.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} DensA (@code{mglData *}a, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Cont3 (Python), ContF3 (Python), Dens3 (Python), 3D plotting (Python)
@subsubsection Cont3 (Python)
@cindex Cont3
@cindex ContA

@deftypemethod {mglGraph (Python)} @code{void} Cont3 (@code{mglData *}v, @code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}stl=@code{NULL})
The function draws contour plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Contours are plotted for values specified in array @var{v} at slice @var{sVal} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{stl} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). See also @ref{Dens3}, @ref{ContF3}, @ref{Cont}, @ref{Grid3}. @sref{Cont3 sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Cont3 (@code{mglData *}v, @code{mglData *}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Cont3 (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}stl=@code{NULL}, @code{int} num=@code{7})
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Cont3 (@code{mglData *}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}sch=@code{NULL}, @code{int} num=@code{7})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContA (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}a, @code{const char *}stl=@code{NULL}, @code{int} num=@code{7})
Draws contour plots at all central slices of the 3d data specified parametrically.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContA (@code{mglData *}a, @code{const char *}sch=@code{NULL}, @code{int} num=@code{7})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node ContF3 (Python), Grid3 (Python), Cont3 (Python), 3D plotting (Python)
@subsubsection ContF3 (Python)
@cindex ContF3
@cindex ContFA

@deftypemethod {mglGraph (Python)} @code{void} ContF3 (@code{mglData *}v, @code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}stl=@code{NULL})
The function draws solid (or filled) contour plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Contours are plotted for values specified in array @var{v} at slice @var{sVal} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{stl} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). See also @ref{Dens3}, @ref{Cont3}, @ref{ContF}, @ref{Grid3}. @sref{ContF3 sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContF3 (@code{mglData *}v, @code{mglData *}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContF3 (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}stl=@code{NULL}, @code{int} num=@code{7})
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContF3 (@code{mglData *}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}sch=@code{NULL}, @code{int} num=@code{7})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContFA (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}a, @code{const char *}stl=@code{NULL}, @code{int} num=@code{7})
Draws contour plots at all central slices of the 3d data specified parametrically.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContFA (@code{mglData *}a, @code{const char *}sch=@code{NULL}, @code{int} num=@code{7})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Grid3 (Python), Cloud (Python), ContF3 (Python), 3D plotting (Python)
@subsubsection Grid3 (Python)
@cindex Grid3
@cindex GridA

@deftypemethod {mglGraph (Python)} @code{void} Grid3 (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}stl=@code{NULL})
The function draws grid for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Density is plotted at slice @var{sVal} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{stl} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). See also @ref{Cont3}, @ref{ContF3}, @ref{Dens3}, @ref{Grid}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Grid3 (@code{mglData *}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} GridA (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}a, @code{const char *}stl=@code{NULL})
Draws grids at all central slices of the 3d data specified parametrically.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} GridA (@code{mglData *}a, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Cloud (Python), Beam (Python), Grid3 (Python), 3D plotting (Python)
@subsubsection Cloud (Python)
@cindex CloudP
@cindex CloudQ

@deftypemethod {mglGraph (Python)} @code{void} Cloud (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}a, @code{const char *}stl=@code{NULL}, @code{float} alpha=@code{1})
The function draws cloud plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). This plot is a set of cubes with color and transparency proportional to value of @var{a}. The resulting plot is like cloud -- low value is transparent but higher ones are not. The number of plotting cells depend on MeshNum (@pxref{Other settings}). String @var{sch} sets the color scheme. Previous color scheme is used by default. Parameter @var{alpha} changes the overall transparency of plot. The minor dimensions of arrays @var{x}, @var{y}, @var{z} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). See also @ref{Surf3}. @sref{CloudQ sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Cloud (@code{mglData *}a, @code{const char *}stl=@code{NULL}, @code{float} alpha=@code{1})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Beam (Python), , Cloud (Python), 3D plotting (Python)
@subsubsection Beam (Python)
@cindex Beam

@deftypemethod {mglGraph (Python)} @code{void} Beam (@code{float} val, @code{mglData *}tr, @code{mglData *}g1, @code{mglData *}g2, @code{mglData *}a, @code{float} r, @code{const char *}stl=@code{NULL}, @code{int} flag=@code{0})
Draws the isosurface for 3d array @var{a} at constatnt values of @var{a}=@var{val}. This is special kind of plot for @var{a} specified in accompanied coordinates along curve @var{tr} with orts @var{g1}, @var{g2} and with transverse scale @var{r}. Variable @var{flag} is bitwise: @samp{0x1} - draw in accompanied (not laboratory) coordinates; @samp{0x2} - draw projection to @math{\rho-z} plane; @samp{0x4} - draw normalized in each slice field. The x-size of data arrays @var{tr}, @var{g1}, @var{g2} must be nx>2. The y-size of data arrays @var{tr}, @var{g1}, @var{g2} and z-size of the data array @var{a} must be equal. @xref{Surf3}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Beam (@code{mglData *}tr, @code{mglData *}g1, @code{mglData *}g2, @code{mglData *}a, @code{float} r, @code{const char *}stl=@code{NULL}, @code{int} flag=@code{0}, @code{int} num=@code{3})
Draws @var{num}-th uniformly distributed in range [@var{Cmin}, @var{Cmax}] isosurfaces for 3d data specified parametrically.
@end deftypemethod



@c ##################################################################
@node Dual plotting (Python), Vector fields (Python), 3D plotting (Python), Python interface
@subsection Dual plotting (Python)

These plotting functions draw @emph{two matrix} simultaneously. There are 5 generally different types of data representations: surface or isosurface colored by other data (SurfC, Surf3C), surface or isosurface transpared by other data (SurfA, Surf3A), tiles with variable size (TileS), mapping diagram (Map), STFA diagram (STFA). Surf3A and Surf3C have variants for automatic and manual selection of level values for isosurfaces. Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@menu
* SurfC (Python)::              
* Surf3C (Python)::             
* SurfA (Python)::              
* Surf3A (Python)::             
* TileS (Python)::              
* Map (Python)::                
* STFA (Python)::               
@end menu

@c ==================================================================
@node SurfC (Python), Surf3C (Python), , Dual plotting (Python)
@subsubsection SurfC (Python)
@cindex SurfC

@deftypemethod {mglGraph (Python)} @code{void} SurfC (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}c, @code{const char *}sch=@code{NULL})
The function draws surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} and color it by matrix @var{c}[i,j]. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. All dimensions of arrays @var{z} and @var{c} must be equal. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Surf}, @ref{SurfA}, @ref{Surf3C}. @sref{SurfC sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SurfC (@code{mglData *}z, @code{mglData *}c, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod


@c ==================================================================
@node Surf3C (Python), SurfA (Python), SurfC (Python), Dual plotting (Python)
@subsubsection Surf3C (Python)
@cindex Surf3C

@deftypemethod {mglGraph (Python)} @code{void} Surf3C (@code{float} val, @code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}a, @code{mglData *}c, @code{const char *}stl=@code{NULL})
The function draws isosurface plot for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) at @var{a}(x,y,z)=@var{val}. It is mostly the same as Surf3() function but the color of isosurface depends on values of array @var{c}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. All dimensions of arrays @var{z} and @var{c} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). Note, that there is possibility of incorrect plotting due to uncertainty of cross-subsection defining if there are two or more isosurface intersubsections inside one cell. See also @ref{Surf3}, @ref{SurfC}, @ref{Surf3A}. @sref{Surf3C sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Surf3C (@code{float} val, @code{mglData *}a, @code{mglData *}c, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Surf3C (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}a, @code{mglData *}c, @code{const char *}stl=@code{NULL}, @code{int} num=@code{3})
Draws @var{num}-th uniformly distributed in range [@var{Cmin}, @var{Cmax}] isosurfaces for 3d data specified parametrically.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Surf3C (@code{mglData *}a, @code{mglData *}c, @code{const char *}sch=@code{NULL}, @code{int} num=@code{3})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod


@c ==================================================================
@node SurfA (Python), Surf3A (Python), Surf3C (Python), Dual plotting (Python)
@subsubsection SurfA (Python)
@cindex SurfA

@deftypemethod {mglGraph (Python)} @code{void} SurfA (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}c, @code{const char *}sch=@code{NULL})
The function draws surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} and transparent it by matrix @var{c}[i,j]. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. All dimensions of arrays @var{z} and @var{c} must be equal. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Surf}, @ref{SurfC}, @ref{Surf3A}, @ref{TileS}. @sref{SurfA sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} SurfA (@code{mglData *}z, @code{mglData *}c, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod


@c ==================================================================
@node Surf3A (Python), TileS (Python), SurfA (Python), Dual plotting (Python)
@subsubsection Surf3A (Python)
@cindex Surf3A

@deftypemethod {mglGraph (Python)} @code{void} Surf3A (@code{float} val, @code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}a, @code{mglData *}c, @code{const char *}stl=@code{NULL})
The function draws isosurface plot for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) at @var{a}(x,y,z)=@var{val}. It is mostly the same as Surf3() function but the transparency of isosurface depends on values of  @var{b} array. This allows one to remove the part of isosurface where @var{b} is negligibly small (useful for phase plotting of a beam or a pulse). String @var{sch} sets the color scheme. Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. All dimensions of arrays @var{z} and @var{c} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). Note, that there is possibility of incorrect plotting due to uncertainty of cross-subsection defining if there are two or more isosurface intersubsections inside one cell. See also @ref{Surf3}, @ref{SurfA}, @ref{Surf3C}. @sref{Surf3A sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Surf3A (@code{float} val, @code{mglData *}a, @code{mglData *}c, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Surf3A (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}a, @code{mglData *}c, @code{const char *}stl=@code{NULL}, @code{int} num=@code{3})
Draws @var{num}-th uniformly distributed in range [@var{Cmin}, @var{Cmax}] isosurfaces for 3d data specified parametrically.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Surf3A (@code{mglData *}a, @code{mglData *}c, @code{const char *}sch=@code{NULL}, @code{int} num=@code{3})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node TileS (Python), Map (Python), Surf3A (Python), Dual plotting (Python)
@subsubsection TileS (Python)
@cindex TileS

@deftypemethod {mglGraph (Python)} @code{void} TileS (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}r, @code{const char *}sch=@code{NULL})
The function draws horizontal tiles for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. It is mostly the same as Tile() but the size of tiles is determined by @var{r} array. This is some kind of ``transparency'' useful for exporting to EPS files. String @var{sch} sets the color scheme. Previous color scheme is used by default. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{SurfA}, @ref{Tile}. @sref{TileS sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} TileS (@code{mglData *}z, @code{mglData *}c, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Map (Python), STFA (Python), TileS (Python), Dual plotting (Python)
@subsubsection Map (Python)
@cindex Map

@deftypemethod {mglGraph (Python)} @code{void} Map (@code{mglData *}x, @code{mglData *}y, @code{mglData *}ax, @code{mglData *}ay, @code{const char *}sch=@code{NULL}, @code{int} ks=@code{0}, @code{bool} pnts=@code{true})
The function draws mapping plot for matrixes @{@var{ax}, @var{ay} @} which parametrically depend on coordinates @var{x}, @var{y}. The previous position of the cell (point) is marked by color. Height is proportional to Jacobian(ax,ay). This plot is like Arnold diagram ???. If @code{pnts=false} then face is drawn otherwise the color ball at matrix knots are drawn. Parameter @var{ks} specifies the slice of matrixes which will be used. String @var{sch} sets the color scheme. Previous color scheme is used by default. The size of @var{ax} and @var{ay} must be the same. The minor dimensions of arrays @var{x}, @var{y}, @var{ax} should be equal. Arrays @var{x}, @var{y} can be vectors (not matrix as @var{ax}). @xref{Color scheme}. @sref{Map sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Map (@code{mglData *}ax, @code{mglData *}ay, @code{const char *}sch=@code{NULL}, @code{int} ks=@code{0}, @code{bool} pnts=@code{true})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node STFA (Python), , Map (Python), Dual plotting (Python)
@subsubsection STFA (Python)
@cindex STFA

@deftypemethod {mglGraph (Python)} @code{void} STFA (@code{mglData *}x, @code{mglData *}y, @code{mglData *}re, @code{mglData *}im, @code{int} dn, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
Draws spectrogram of complex array @var{re}+i*@code{im} for Fourier size of @var{dn} points at plane @var{z=zVal}. Parameter @var{dn} is arbitrary even integer. For example in 1D case, result is density plot of data @math{res[i,j]=|\sum_d^dn exp(I*j*d)*(re[i*dn+d]+I*im[i*dn+d])|/dn} with size @{int(nx/dn), dn, ny@}. At this array @var{re}, @var{im} parametrically depend on coordinates @var{x}, @var{y}. String @var{sch} sets the color scheme. Previous color scheme is used by default. The size of @var{re} and @var{im} must be the same. The minor dimensions of arrays @var{x}, @var{y}, @var{re} should be equal. Arrays @var{x}, @var{y} can be vectors (not matrix as @var{re}). @xref{Color scheme}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} STFA (@code{mglData *}re, @code{mglData *}im, @code{int} dn, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod


@c ##################################################################
@node Vector fields (Python), Other plotting (Python), Dual plotting (Python), Python interface
@subsection Vector fields (Python)

These functions perform plotting of 2D and 3D vector fields. There are 5 generally different types of vector fields representations: simple vector field (Vect), vector field with coloring (VectC), vector field by dew-drops (Dew), flow threads (Flow), flow pipes (Pipe). Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@menu
* Vect (Python)::               
* VectC (Python)::              
* Dew (Python)::                
* Flow (Python)::               
* Pipe (Python)::               
@end menu

@c ==================================================================
@node Vect (Python), VectC (Python), , Vector fields (Python)
@subsubsection Vect (Python)
@cindex Vect

@deftypemethod {mglGraph (Python)} @code{void} Vect (@code{mglData *}x, @code{mglData *}y, @code{mglData *}ax, @code{mglData *}ay, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws plane vector field plot for the field @{@var{ax}, @var{ay}@} depending parametrically on coordinates @var{x}, @var{y} at level @var{z=zVal}. The length of hachures is proportional to @math{\sqrt@{ax^2+ay^2@}}. The number of hachures depend on @var{MeshNum} (@pxref{Other settings}). The color is specified by the string argument @var{sch}. Previous color scheme is used by default. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also @ref{VectC}, @ref{Flow}, @ref{Dew}. @sref{Vect sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Vect (@code{mglData *}ax, @code{mglData *}ay, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Vect (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}ax, @code{mglData *}ay, @code{mglData *}az, @code{const char *}sch=@code{NULL})
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the length of hachures is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. @sref{Vect 3D sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Vect (@code{mglData *}ax, @code{mglData *}ay, @code{mglData *}az, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node VectC (Python), Dew (Python), Vect (Python), Vector fields (Python)
@subsubsection VectC (Python)
@cindex VectC

@deftypemethod {mglGraph (Python)} @code{void} VectC (@code{mglData *}x, @code{mglData *}y, @code{mglData *}ax, @code{mglData *}ay, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws plane vector field plot for the field @{@var{ax}, @var{ay}@} depending parametrically on coordinates @var{x}, @var{y} at level @var{z=zVal}. The color of hachures is proportional to @math{\sqrt@{ax^2+ay^2@}}. The number of hachures depend on @var{MeshNum} (@pxref{Other settings}). The color is specified by the string argument @var{sch}. Previous color scheme is used by default. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also @ref{Vect}, @ref{Flow}, @ref{Dew}.  @sref{VectC sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} VectC (@code{mglData *}ax, @code{mglData *}ay, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} VectC (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}ax, @code{mglData *}ay, @code{mglData *}az, @code{const char *}sch=@code{NULL})
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the color of hachures is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. @sref{VectC 3D sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} VectC (@code{mglData *}ax, @code{mglData *}ay, @code{mglData *}az, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@c ==================================================================
@node Dew (Python), Flow (Python), VectC (Python), Vector fields (Python)
@subsubsection Dew (Python)
@cindex Dew

@deftypemethod {mglGraph (Python)} @code{void} Dew (@code{mglData *}x, @code{mglData *}y, @code{mglData *}ax, @code{mglData *}ay, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws dew-drops for plane vector field @{@var{ax}, @var{ay}@} depending parametrically on coordinates @var{x}, @var{y} at level @var{z=zVal}. Note that this is very expensive plot in memory usage and creation time! The color of drops is proportional to @math{\sqrt@{ax^2+ay^2@}}. The numer of drops depend on @var{MeshNum} (@pxref{Other settings}). The color is specified by the string argument @var{sch}. Previous color scheme is used by default. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also @ref{Vect}, @ref{VectC}. @sref{Dew sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Dew (@code{mglData *}ax, @code{mglData *}ay, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod


@c ==================================================================
@node Flow (Python), Pipe (Python), Dew (Python), Vector fields (Python)
@subsubsection Flow (Python)
@cindex Flow

@deftypemethod {mglGraph (Python)} @code{void} Flow (@code{mglData *}x, @code{mglData *}y, @code{mglData *}ax, @code{mglData *}ay, @code{const char *}sch=@code{NULL}, @code{int} num=@code{5}, @code{bool} central=@code{true}, @code{float} zVal=@code{NAN})
The function draws flow threads for the plane vector field @{@var{ax}, @var{ay}@} parametrically depending on coordinates @var{x}, @var{y} at level z = @var{zVal}. Number of threads is proportional to @var{num}. Parameter @var{central} sets the thread start from center (if true) or only from edges (if false). The color of lines is proportional to @math{\sqrt@{ax^2+ay^2@}}. Warm color corresponds to normal flow (like attractor). Cold one corresponds to inverse flow (like source). String @var{sch} sets the color scheme. Previous color scheme is used by default. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also @ref{Pipe}, @ref{VectC}, @ref{Vect}. @sref{Flow sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Flow (@code{mglData *}ax, @code{mglData *}ay, @code{const char *}sch=@code{NULL}, @code{int} num=@code{5}, @code{bool} central=@code{true}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Flow (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}ax, @code{mglData *}ay, @code{mglData *}az, @code{const char *}sch=@code{NULL}, @code{int} num=@code{3}, @code{bool} central=@code{true})
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the color of line is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. @sref{Flow 3D sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Flow (@code{mglData *}ax, @code{mglData *}ay, @code{mglData *}az, @code{const char *}sch=@code{NULL}, @code{int} num=@code{3}, @code{bool} central=@code{true})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod


@c ==================================================================
@node Pipe (Python), , Flow (Python), Vector fields (Python)
@subsubsection Pipe (Python)
@cindex Pipe

@deftypemethod {mglGraph (Python)} @code{void} Pipe (@code{mglData *}x, @code{mglData *}y, @code{mglData *}ax, @code{mglData *}ay, @code{const char *}sch=@code{NULL}, @code{float} r0=@code{0.05}, @code{int} num=@code{5}, @code{bool} central=@code{true}, @code{float} zVal=@code{NAN})
The function draws flow pipes for the plane vector field @{@var{ax}, @var{ay}@} parametrically depending on coordinates @var{x}, @var{y} at level z = @var{zVal}. Number of pipes is proportional to @var{num}. Parameter @var{central} sets the pipe start from center (if true) or only from edges (if false). The color of lines is proportional to @math{\sqrt@{ax^2+ay^2@}}. Warm color corresponds to normal flow (like attractor). Cold one corresponds to inverse flow (like source). String @var{sch} sets the color scheme. Previous color scheme is used by default. Parameter @var{r0} set the base pipe radius. If @var{r0}<0 then pipe radius is inverse proportional to amplitude. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also @ref{Pipe}, @ref{VectC}, @ref{Vect}. @sref{Pipe sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Pipe (@code{mglData *}ax, @code{mglData *}ay, @code{const char *}sch=@code{NULL}, @code{float} r0=@code{0.05}, @code{int} num=@code{5}, @code{bool} central=@code{true}, @code{float} zVal=@code{NAN})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Pipe (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}ax, @code{mglData *}ay, @code{mglData *}az, @code{const char *}sch=@code{NULL}, @code{float} r0=@code{0.05}, @code{int} num=@code{3}, @code{bool} central=@code{true})
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the color of line is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. @sref{Pipe 3D sample}
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Pipe (@code{mglData *}ax, @code{mglData *}ay, @code{mglData *}az, @code{const char *}sch=@code{NULL}, @code{float} r0=@code{0.05}, @code{int} num=@code{3}, @code{bool} central=@code{true})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod


@c ##################################################################
@node Other plotting (Python), Nonlinear fitting (Python), Vector fields (Python), Python interface
@subsection Other plotting (Python)

These functions perform miscelaneous plotting. There is unstructured data points plots (Dots), surface reconstruction (Crust), surfaces on the triangular mesh (TriPlot), textual formula plotting (Plots by formula), data plots at edges (Dens[XYZ], Cont[XYZ], ContF[XYZ]), simple plot (SimplePlot). Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@menu
* DensXYZ (Python)::            
* ContXYZ (Python)::            
* ContFXYZ (Python)::           
* Dots (Python)::               
* Crust (Python)::              
* TriPlot (Python)::            
* Plots by formula (Python)::   
* SimplePlot (Python)::         
@end menu

@c ==================================================================
@node DensXYZ (Python), ContXYZ (Python), , Other plotting (Python)
@subsubsection DensXYZ (Python)
@cindex DensX
@cindex DensY
@cindex DensZ

These plotting functions draw density plot in x, y, or z plain. If @var{a} is a tensor (3-dimensional data) then interpolation to a given @var{sVal} is performed. These functions are useful for creating projections of the 3D data array to the bounding box. See also @ref{ContXYZ}, @ref{ContFXYZ}, @ref{Dens}. @sref{Dens projection sample}

@deftypemethod {mglGraph (Python)} @code{void} DensX (@code{mglData *}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN})
Draws density plot for data @var{a} at x = @var{sVal}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} DensY (@code{mglData *}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN})
Draws density plot for data @var{a} at y = @var{sVal}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} DensZ (@code{mglData *}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN})
Draws density plot for data @var{a} at z = @var{sVal}.
@end deftypemethod

@c ==================================================================
@node ContXYZ (Python), ContFXYZ (Python), DensXYZ (Python), Other plotting (Python)
@subsubsection ContXYZ (Python)
@cindex ContX
@cindex ContY
@cindex ContZ

These plotting functions draw density plot in x, y, or z plain. If @var{a} is a tensor (3-dimensional data) then interpolation to a given @var{sVal} is performed. These functions are useful for creating projections of the 3D data array to the bounding box. See also @ref{ContFXYZ}, @ref{DensXYZ}, @ref{Cont}. @sref{Cont projection sample}

@deftypemethod {mglGraph (Python)} @code{void} ContX (@code{mglData *}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN}, @code{int} num=@code{7})
Draws @var{num}-th contour lines for data @var{a} at x = @var{sVal}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContY (@code{mglData *}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN}, @code{int} num=@code{7})
Draws @var{num}-th contour lines for data @var{a} at y = @var{sVal}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContZ (@code{mglData *}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN}, @code{int} num=@code{7})
Draws @var{num}-th contour lines for data @var{a} at z = @var{sVal}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContX (@code{mglData *}v, @code{mglData *}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN})
Draws contour lines for data @var{a}=@var{v}[i] at x = @var{sVal}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContY (@code{mglData *}v, @code{mglData *}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN})
Draws contour lines for data @var{a}=@var{v}[i] at y = @var{sVal}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContZ (@code{mglData *}v, @code{mglData *}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN})
Draws contour lines for data @var{a}=@var{v}[i] at z = @var{sVal}.
@end deftypemethod

@c ==================================================================
@node ContFXYZ (Python), Dots (Python), ContXYZ (Python), Other plotting (Python)
@subsubsection ContFXYZ (Python)
@cindex ContFX
@cindex ContFY
@cindex ContFZ

These plotting functions draw density plot in x, y, or z plain. If @var{a} is a tensor (3-dimensional data) then interpolation to a given @var{sVal} is performed. These functions are useful for creating projections of the 3D data array to the bounding box. See also @ref{ContXYZ}, @ref{DensXYZ}, @ref{ContF}.

@deftypemethod {mglGraph (Python)} @code{void} ContFX (@code{mglData *}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN}, @code{int} num=@code{7})
Draws @var{num}-th solid contours for data @var{a} at x = @var{sVal}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContFY (@code{mglData *}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN}, @code{int} num=@code{7})
Draws @var{num}-th solid contours for data @var{a} at y = @var{sVal}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContFZ (@code{mglData *}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN}, @code{int} num=@code{7})
Draws @var{num}-th solid contours for data @var{a} at z = @var{sVal}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContFX (@code{mglData *}v, @code{mglData *}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN})
Draws solid contours for data @var{a}=@var{v}[i] at x = @var{sVal}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContFY (@code{mglData *}v, @code{mglData *}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN})
Draws solid contours for data @var{a}=@var{v}[i] at y = @var{sVal}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} ContFZ (@code{mglData *}v, @code{mglData *}a, @code{const char *}stl=@code{NULL}, @code{float} sVal=@code{NAN})
Draws solid contours for data @var{a}=@var{v}[i] at z = @var{sVal}.
@end deftypemethod

@c ==================================================================
@node Dots (Python), Crust (Python), ContFXYZ (Python), Other plotting (Python)
@subsubsection Dots (Python)
@cindex Dots

@deftypemethod {mglGraph (Python)} @code{void} Dots (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{const char *}sch=@code{NULL})
The function draws the arbitrary placed points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. Arrays @var{x}, @var{y}, @var{z} must have equal sizes. See also @ref{Crust}, @ref{Mark}, @ref{Plot}. @sref{Dots sample}
@end deftypemethod

@c ==================================================================
@node Crust (Python), TriPlot (Python), Dots (Python), Other plotting (Python)
@subsubsection Crust (Python)
@cindex Crust

@deftypemethod {mglGraph (Python)} @code{void} Crust (@code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{const char *}sch=@code{NULL}, @code{float} er=@code{0})
The function reconstruct and draws the surface for arbitrary placed points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. Parameter @var{er} set relative radius for (increase it for removing holes). String @var{sch} sets the color scheme. Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. Arrays @var{x}, @var{y}, @var{z} must have equal sizes. See also @ref{Dots}, @ref{TriPlot}. @sref{Crust sample}
@end deftypemethod

@c ==================================================================
@node TriPlot (Python), Plots by formula (Python),  Crust (Python), Other plotting (Python)
@subsubsection TriPlot (Python)
@cindex TriPlot

@deftypemethod {mglGraph (Python)} @code{void} TriPlot (@code{mglData *}id, @code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{const char *}sch=@code{NULL})
The function draws the surface of triangles. Triangle vertexes are set by indexes @var{id} of data points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. First dimensions of @var{id} must be 3 or greater. Arrays @var{x}, @var{y}, @var{z} must have equal sizes. See also @ref{Dots}, @ref{Crust}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} TriPlot (@code{mglData *}id, @code{mglData *}x, @code{mglData *}y, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN})
The same as previous with @var{z}[i]=@var{zVal}.
@end deftypemethod

@c ==================================================================
@node Plots by formula (Python), SimplePlot (Python), TriPlot (Python), Other plotting (Python)
@subsubsection Plots by formula (Python)
@cindex Plot
@cindex Surf

These functions perform plotting of 1D or 2D functions specified by textual formula. You do not need to create the data arrays to plot it. The parameter @var{stl} set the line style (@pxref{Line styles}) for @code{Plot()} or color scheme (@pxref{Color scheme}) for @code{Surf()}. The parameter @var{n} set the minimal number of points along coordinate(s) for plots. At this time (v. 1.7) there is no adaptive increase of data points numbers but in future it will appear.

@deftypemethod {mglGraph (Python)} @code{void} Plot (@code{const char *}eqY, @code{const char *}stl=@code{NULL}, @code{float} zVal=@code{NAN}, @code{int} n=@code{100})
The function draws function @samp{eqY(x)} at plane z=@var{zVal} where @samp{x} variable is changed in range [@var{Min}.x, @var{Max}.x]. See also @ref{Plot}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Plot (@code{const char *}eqX, @code{const char *}eqY, @code{const char *}eqZ, @code{const char *}stl=@code{NULL}, @code{float} zVal=@code{NAN}, @code{int} n=@code{100})
The function draws parametrical curve @{@samp{eqX(t)}, @samp{eqY(t)}, @samp{eqZ(t)}@} where @samp{t} variable is changed in range [0, 1]. See also @ref{Plot}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Surf (@code{const char *}eqZ, @code{const char *}stl=@code{NULL}, @code{int} n=@code{100});
The function draws surface for function @samp{eqY(x,y)} where @samp{x}, @samp{y} variables are changed in range [@var{Min}, @var{Max}]. See also @ref{Surf}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} Surf (@code{const char *}eqX, @code{const char *}eqY, @code{const char *}eqZ, @code{const char *}stl=@code{NULL}, @code{int} n=@code{100})
The function draws parametrical surface @{@samp{eqX(u,v)}, @samp{eqY(u,v)}, @samp{eqZ(u,v)}@} where @samp{u}, @samp{v} variables are changed in range [0, 1]. See also @ref{Surf}.
@end deftypemethod

@c ==================================================================
@node SimplePlot (Python), , Plots by formula (Python), Other plotting (Python)
@subsubsection SimplePlot (Python)
@cindex SimplePlot

@deftypemethod {mglGraph (Python)} @code{void} SimplePlot (@code{mglData *}a, @code{int} type=@code{0}, @code{const char *}stl=@code{NULL})
Plots the array @var{a} depending on it's dimensions and @var{type} parameter. String @var{stl} specifies the style of plotting. For 1d data: @code{type=0} -- @ref{Plot}, @code{type=1} -- @ref{Area}, @code{type=2} -- @ref{Step}, @code{type=3} -- @ref{Stem}, @code{type=4} -- @ref{Bars}. For 2d data: @code{type=0} -- @ref{Surf}, @code{type=1} -- @ref{Dens}, @code{type=2} -- @ref{Mesh}, @code{type=3} -- @ref{Cont}. For 3d data: @code{type=0} -- @ref{Surf3}, @code{type=1} -- @ref{Dens3}, @code{type=2} -- @ref{Cont3}, @code{type=2} -- @ref{Cloud}.
@end deftypemethod

@c ##################################################################
@node Nonlinear fitting (Python), Data import (Python), Other plotting (Python), Python interface
@subsection Nonlinear fitting (Python)
@cindex Fit
@cindex FitS
@cindex PutsFit
@cindex FitPnts
@cindex Fit2
@cindex Fit3

These functions fit data to formula. Fitting goal is to find formula parameters for the best fit the data points, i.e. to minimize the sum @math{\sum_i (f(x_i, y_i, z_i) - a_i)^2/s_i^2}. At this, approximation function @samp{f} can depend only on one argument @samp{x} (1D case), on two arguments @samp{x,y} (2D case) and on three arguments @samp{x,y,z} (3D case). The function @samp{f} also may depend on parameters. Normally the list of fitted parameters is specified by @var{var} string (like, @samp{abcd}). Usually user should supply initial values for fitted parameters by @var{ini} variable. But if he/she don't supply it then the zeros are used. Parameter @var{print}=@code{true} switch on printing the found coefficients to @var{Message} (@pxref{Error handling}).

Functions Fit() and FitS() do not draw the obtained data themselves. They fill the data @var{fit} by formula @samp{f} with found coefficients and return the @math{\chi^2} error of approximation. At this, the @samp{x,y,z} coordinates are equidistantly distributed in the interval @var{Min}--@var{Max}. Number of points in @var{fit} is selected as maximal value of @var{fit} size and the value of @var{FitPnts}. Note, that this functions use GSL library and do something only if MathGL was compiled with GSL support. @sref{Fitting sample}

@deftypemethod {mglGraph (Python)} @code{float} FitS (@code{mglData *}fit, @code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}a, @code{mglData *}s, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx {mglGraph (Python)} @code{float} FitS (@code{mglData *}fit, @code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}a, @code{mglData *}s, @code{const char *}func, @code{const char *}var, @code{mglData *}ini, @code{bool} print=@code{false})
Fit data along x-, y- and z-directions for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]).
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{float} FitS (@code{mglData *}fit, @code{mglData *}x, @code{mglData *}y, @code{mglData *}a, @code{mglData *}s, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx {mglGraph (Python)} @code{float} FitS (@code{mglData *}fit, @code{mglData *}x, @code{mglData *}y, @code{mglData *}a, @code{mglData *}s, @code{const char *}func, @code{const char *}var, @code{mglData *}ini, @code{bool} print=@code{false})
Fit data along x-, and y-directions for 2d array specified parametrically @var{a}[i,j](@var{x}[i,j], @var{y}[i,j]) for each data slice.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{float} FitS (@code{mglData *}fit, @code{mglData *}x, @code{mglData *}a, @code{mglData *}s, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx {mglGraph (Python)} @code{float} FitS (@code{mglData *}fit, @code{mglData *}x, @code{mglData *}a, @code{mglData *}s, @code{const char *}func, @code{const char *}var, @code{mglData *}ini, @code{bool} print=@code{false})
Fit data along x-direction for 1d array specified parametrically @var{a}[i](@var{x}[i]) for each data slice.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{float} FitS (@code{mglData *}fit, @code{mglData *}a, @code{mglData *}s, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx {mglGraph (Python)} @code{float} FitS (@code{mglData *}fit, @code{mglData *}a, @code{mglData *}s, @code{const char *}func, @code{const char *}var, @code{mglData *}ini, @code{bool} print=@code{false})
Fit data along x-direction for 1d array with @var{x} equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{float} Fit (@code{mglData *}fit, @code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}a, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx {mglGraph (Python)} @code{float} Fit (@code{mglData *}fit, @code{mglData *}x, @code{mglData *}y, @code{mglData *}z, @code{mglData *}a, @code{const char *}func, @code{const char *}var, @code{mglData *}ini, @code{bool} print=@code{false})
Fit data along x-, y- and z-directions for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) with @var{s}[i,j,k]=1.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{float} Fit (@code{mglData *}fit, @code{mglData *}x, @code{mglData *}y, @code{mglData *}a, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx {mglGraph (Python)} @code{float} Fit (@code{mglData *}fit, @code{mglData *}x, @code{mglData *}y, @code{mglData *}a, @code{const char *}func, @code{const char *}var, @code{mglData *}ini, @code{bool} print=@code{false})
Fit data along x-, and y-directions for 2d array specified parametrically @var{a}[i,j](@var{x}[i,j], @var{y}[i,j]) with @var{s}[i,j]=1 for each data slice.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{float} Fit (@code{mglData *}fit, @code{mglData *}x, @code{mglData *}a, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx {mglGraph (Python)} @code{float} Fit (@code{mglData *}fit, @code{mglData *}x, @code{mglData *}a, @code{const char *}func, @code{const char *}var, @code{mglData *}ini, @code{bool} print=@code{false})
Fit data along x-direction for 1d array specified parametrically @var{a}[i](@var{x}[i]) with @var{s}[i]=1 for each data slice.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{float} Fit (@code{mglData *}fit, @code{mglData *}a, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx {mglGraph (Python)} @code{float} Fit (@code{mglData *}fit, @code{mglData *}a, @code{const char *}func, @code{const char *}var, @code{mglData *}ini, @code{bool} print=@code{false})
Fit data along x-direction for 1d array @var{a} with @var{s}=1 and @var{x} equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{float} Fit2 (@code{mglData *}fit, @code{mglData *}a, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx {mglGraph (Python)} @code{float} Fit2 (@code{mglData *}fit, @code{mglData *}a, @code{const char *}func, @code{const char *}var, @code{mglData *}ini, @code{bool} print=@code{false})
Fit data along x-, and y-directions for 2d array @var{a} with @var{s}=1 and @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{float} Fit3 (@code{mglData *}fit, @code{mglData *}a, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypemethodx {mglGraph (Python)} @code{float} Fit3 (@code{mglData *}fit, @code{mglData *}a, @code{const char *}func, @code{const char *}var, @code{mglData *}ini, @code{bool} print=@code{false})
Fit data along x-, y- and z-directions for 3d array @var{a} with @var{s}=1 and @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} PutsFit (@code{mglPoint} p, @code{const char *}prefix=@code{NULL}, @code{const char *}font=@code{NULL}, @code{float} size=@code{-1})
Print last fitted formula with found coefficients (as numbers) at position @var{p0}. The string @var{prefix} will be printed before formula. All other parameters are the same as in @ref{Text printing}.
@end deftypemethod

@deftypemethod {mglGraph (Python)} @code{void} @code{int} FitPnts
Minimal number of points for output array after nonlinear fitting.
@end deftypemethod

@c ##################################################################
@node Data import (Python), Data filling (Python), Nonlinear fitting (Python), Python interface
@subsection Data import (Python)

Starting from this section the @code{mglData} class description is placed.  The class has functions for easy and safe allocation, resizing, loading and saving, modifying of data arrays. Also it can numerically differentiate and integrate data, interpolate, fill data by formula and so on. Class supports data with dimensions up to 3 (like function of 3 variables - x,y,z). The internal representation of numbers is float. Float type was chosen because it has smaller size in memory and usually it has enough precision in plotting purposes.

Note, that mglData class is not the array of data. And main purpose of this class is to keep the data for plotting and to do some ``high-level'' data handling (like summing, transpose, smoothing and so in). However, there is several operators which allows one to chage its values cell-by-cell. 

@defop Constructor {mglData (Python)} @code{} mglData (@code{int} mx=@code{1}, @code{int} my=@code{1}, @code{int} mz=@code{1})
Default constructor. Allocates the memory for data array and initializes it by zero.
@end defop
@defop Constructor {mglData (Python)} @code{} mglData (@code{const char *}fname)
Initializes the data by reading from file.
@end defop
@defop Constructor {mglData (Python)} @code{} mglData (@code{const mglData *}dat)
Initiates by other @code{mglData} instance.
@end defop

@deftypemethod {mglData (Python)} @code{void} Create (@code{int} mx, @code{int} my=@code{1}, @code{int} mz=@code{1})
Creates or recreates the array with specified size and fills it by zero. This function does nothing if one of parameters @var{mx}, @var{my}, @var{mz} is zero or negative.
@end deftypemethod

@deftypemethod {mglData (Python)} @code{void} SetF (@code{const float *}A, @code{int} NX, @code{int} NY=@code{1}, @code{int} NZ=@code{1})
Allocates memory and copies the data from the @strong{flat} @code{float*} array. 
@end deftypemethod
@deftypemethod {mglData (Python)} @code{void} SetD (@code{const double *}A, @code{int} NX, @code{int} NY=@code{1}, @code{int} NZ=@code{1})
Allocates memory and copies the data from the @strong{flat} @code{double*} array.
@end deftypemethod

@deftypemethod {mglData (Python)} @code{void} SetV (@code{gsl_vector *}v)
Allocates memory and copies the data from the @code{gsl_vector *} structure.
@end deftypemethod
@deftypemethod {mglData (Python)} @code{void} SetM (@code{gsl_matrix *}m)
Allocates memory and copies the data from the @code{gsl_matrix *} structure.
@end deftypemethod
@deftypemethod {mglData (Python)} @code{inline void} Set (@code{const mglData *}dat)
Copies the data from mglData instance @var{dat}.
@end deftypemethod

@deftypemethod {mglData (Python)} @code{void} Set (@code{const char *}str, @code{int} NX, @code{int} NY=@code{1}, @code{int} NZ=@code{1})
Allocates memory and scanf the data from the string.
@end deftypemethod

@deftypemethod {mglData (Python)} @code{void} Set (@code{float} val, @code{int} i, @code{int} j=@code{0}, @code{int} k=@code{0})
Sets a[@var{i},@var{j},@var{k}] = @var{val}.
@end deftypemethod

@deftypemethod {mglData (Python)} @code{void} Get (@code{int} i, @code{int} j=@code{0}, @code{int} k=@code{0})
Gets the value of a[@var{i},@var{j},@var{k}].
@end deftypemethod

@c ------------------------------------------------------------------
@node Data filling (Python), Rearrange data (Python), Data import (Python), Python interface
@subsection Data filling (Python)
@cindex Fill
@cindex Modify

@deftypemethod {mglData (Python)} @code{void} Fill (@code{float} x1, @code{float} x2, @code{char} dir=@code{'x'})
Equidistantly fills the data values to range [@var{x1}, @var{x2}] in direction @var{dir}=@{@samp{x},@samp{y},@samp{z}@}.
@end deftypemethod

@deftypemethod {mglData (Python)} @code{void} Fill (@code{mglData *}gr, @code{const char *}eq, @code{const mglData *}v=@code{NULL}, @code{const mglData *}w=@code{NULL})
Function fills the value of array according to the formula in string @var{eq}. Formula is an arbitrary expression depending  on variables @samp{x}, @samp{y}, @samp{z}, @samp{u}, @samp{v}, @samp{w}. Coordinates @samp{x}, @samp{y}, @samp{z} are supposed to be normalized in interval [@var{r1}...@var{r2}]. Variable @samp{u} is the original value of the array. Variables @samp{v} and @samp{w} are values of @var{v}, @var{w}.
@end deftypemethod

@deftypemethod {mglData (Python)} @code{void} Modify (@code{const char *}eq, @code{mglData *}v=@code{NULL}, @code{mglData *}w=@code{NULL})
Function fills the value of array according to the formula in string @var{eq}. Formula is an arbitrary expression depending  on variables @samp{x}, @samp{y}, @samp{z}, @samp{u}, @samp{v}, @samp{w}. Coordinates @samp{x}, @samp{y}, @samp{z} are supposed to be normalized in interval [0,1]. Variable @samp{u} is the original value of the array. Variables @samp{v} and @samp{w} are values of @var{v}, @var{w}.
@end deftypemethod

@c ------------------------------------------------------------------
@node Rearrange data (Python), File I/O (Python), Data filling (Python), Python interface
@subsection Rearrange data (Python)
@cindex Rearrange
@cindex Extend
@cindex Transpose
@cindex Squeeze
@cindex Crop

@deftypemethod {mglData (Python)} @code{void} Rearrange (@code{int} mx, @code{int} my=@code{0}, @code{int} mz=@code{0})
Rearrange dimensions without changing data array so that resulting sizes should  be @var{mx}*@var{my}*@var{mz} < nx*ny*nz. If some of parameter @var{my} or @var{mz} are zero then it will be selected to optimal fill of data array. For example, if @var{my}=0 then it will be change to @var{my}=nx*ny*nz/@var{mx} and @var{mz} will be 1.
@end deftypemethod
@deftypemethod {mglData (Python)} @code{void} Extend (@code{int} n1, @code{int} n2=@code{0})
Increase the dimensions of the data by inserting new (|@var{n1}|+1)-th slices after (for @var{n1}>0) or before (for @var{n1}<0) of existed one. It is possible to insert 2 dimensions simultaneously for 1d data by using parameter @var{n2}. Data to new slices is copy from existed one. For example, for @var{n1}>0 new array will be 
@iftex
@math{a_{ij}^{new} = a_i^{old}} where j=0...@var{n1}. Correspondingly, for @var{n1}<0 new array will be @math{a_{ij}^{new} = a_j^{old}} where i=0...|@var{n1}|.
@end iftex
@ifnottex
a_ij^new = a_i^old where j=0...@var{n1}. Correspondingly, for @var{n1}<0 new array will be a_ij^new = a_j^old where i=0...|@var{n1}|.
@end ifnottex
@end deftypemethod
@deftypemethod {mglData (Python)} @code{void} Transpose (@code{const char *}dim=@code{"yxz"})
Transposes (shift order of) dimensions of the data. New order of dimensions is specified int string @var{dim}. This function may be useful also for the reading of one-dimensional data.
@end deftypemethod
@deftypemethod {mglData (Python)} @code{void} Squeeze (@code{int} rx, @code{int} ry=@code{1}, @code{int} rz=@code{1}, @code{bool} smooth=@code{true})
Reduces the data size by excluding data elements which indexes are not divisible by @var{rx}, @var{ry}, @var{rz} correspondingly.
@end deftypemethod
@deftypemethod {mglData (Python)} @code{void} Crop (@code{int} n1, @code{int} n2, @code{char} dir=@code{'x'})
Cuts off edges @var{i}<@var{n1} and @var{i}>@var{n2} of the data along direction @var{dir}.
@end deftypemethod

@c ------------------------------------------------------------------
@node File I/O (Python), Make another data (Python), Rearrange data (Python), Python interface
@subsection File I/O (Python)
@cindex Read
@cindex ReadMat
@cindex ReadAll
@cindex ReadRange
@cindex ReadHDF
@cindex Save
@cindex SaveHDF
@cindex Export
@cindex Import

@deftypemethod {mglData (Python)} @code{void} Read (@code{const char *}fname, @code{int} mx=@code{0}, @code{int} my=@code{1}, @code{int} mz=@code{1})
Reads data from text file with specified data sizes. If @var{mx}=0 then library auto determine sizes of the data.
@end deftypemethod
@deftypemethod {mglData (Python)} @code{void} ReadMat (@code{const char *}fname, @code{int} dim=@code{2})
Read data from text file with size specified at beginning of the file by first @var{dim} numbers. At this, variable @var{dim} set data dimensions.
@end deftypemethod

@deftypemethod {mglData (Python)} @code{void} Save (@code{const char *}fname, @code{int} ns=@code{-1}) @code{const}
Saves the whole data array (for @var{ns}=@code{-1}) or only ns-th slice to text file. If @var{ns}>0 then only @var{ns}-th slice (or column for 2D array) will be saved.
@end deftypemethod

@deftypemethod {mglData (Python)} @code{void} Import (@code{const char *}fname, @code{const char *}scheme, @code{float} v1=@code{0}, float v2=@code{1})
Reads data from bitmap file (now support only PNG format). The RGB values of bitmap pixels are transformed to float values in range [@var{v1}, @var{v2}] using color scheme @var{scheme} (@pxref{Color scheme}).
@end deftypemethod
@deftypemethod {mglData (Python)} @code{void} Export (@code{const char *}fname, @code{const char *}scheme, @code{float} v1=@code{0}, float v2=@code{0}, @code{int} ns=@code{-1}) const
Saves data matrix (or @code{ns}-th slice for 3d data) to bitmap file (now support only PNG format). The data values are transformed from range [@var{v1}, @var{v2}] to RGB pixels of bitmap using color scheme @var{scheme} (@pxref{Color scheme}). If @var{v1}>=@var{v2} then the values of @var{v1}, @var{v2} are automatically determined as minimal and maximal value of the data array.
@end deftypemethod

@c ------------------------------------------------------------------
@node Make another data (Python), Functions on direction (Python), File I/O (Python), Python interface
@subsection Make another data (Python)
@cindex SubData
@cindex Column
@cindex SetColumnId
@cindex Hist
@cindex Momentum
@cindex Sum
@cindex Max
@cindex Min
@cindex Combine
@cindex Evaluate
@cindex Resize

@deftypemethod {mglData (Python)} @code{mglData *} SubData (@code{int} xx, @code{int} yy=@code{-1}, @code{int} zz=@code{-1}) @code{const}
Extracts sub-array data from the original data array keeping fixed positive index. For example @code{SubData(-1,2)} extracts 3d row (indexes are zero based), @code{SubData(4,-1)} extracts 5th column, @code{SubData(-1,-1,3)} extracts 4th slice and so on. The most convenient way is to use this function as initialization of other @code{mglData} variable like @code{mglData a1(a.SubData(-1,-1,3))}.
@end deftypemethod
@deftypemethod {mglData (Python)} @code{mglData *} Column (@code{const char *}eq)
Get column (or slice) of the data filled by formula @var{eq} of other named columns. For example, @code{Column("n*w^2/exp(t)");}. The column ids must be defined first by @code{SetColumnId()} function.
@end deftypemethod
@deftypemethod {mglData (Python)} @code{void} SetColumnId (@code{const char *}ids)
Set the symbol id for data columns. The string must contain one symbol 'a'...'z' per column (without spaces).
@end deftypemethod

@deftypemethod {mglData (Python)} @code{mglData *} Hist (@code{int} n, @code{float} v1=@code{0}, @code{float} v2=@code{1}, @code{int} nsub=@code{0})
Creates @var{n}-th points distribution of the data values in range [@var{v1}, @var{v2}]. Parameter @var{nsub} define the number of additional interpolated points (for smoothness of histogram).
@end deftypemethod
@deftypemethod {mglData (Python)} @code{mglData *} Hist (@code{mglData *}w, @code{int} n, @code{float} v1=@code{0}, @code{float} v2=@code{1}, @code{int} nsub=@code{0})
Creates @var{n}-th points distribution of the data values in range [@var{v1}, @var{v2}]. Array @var{w} specifies weights of the data elements. Parameter @var{nsub} define the number of additional interpolated points (for smoothness of histogram).
@end deftypemethod
@deftypemethod {mglData (Python)} @code{mglData *} Momentum (@code{char} dir, @code{const char *}how) @code{const}
Get momentum (1D-array) of the data along direction @var{dir}. String @var{how} contain kind of momentum and may looks like @code{"x1"} for median 
@iftex
@math{\sum_{ij} x_i a_{ij}} in x-direction, @code{"y2"} for @math{\sum_{ij} y_j^2 a_{ij}}
@end iftex
@ifnottex
\sum_ij x_i a_ij in x-direction, @code{"y2"} for \sum_ij y_j^2 a_ij
@end ifnottex
in x-dir and so on. Mixed momentum (like @code{"xy"}) are not supported now.
@end deftypemethod

@deftypemethod {mglData (Python)} @code{mglData *} Sum (@code{const char *}dir)
Gets array which is the result of summation in given direction or direction(s).
@end deftypemethod
@deftypemethod {mglData (Python)} @code{mglData *} Max (@code{const char *}dir)
Gets array which is the maximal data values in given direction or direction(s).
@end deftypemethod
@deftypemethod {mglData (Python)} @code{mglData *} Min (@code{const char *}dir)
Gets array which is the maximal data values in given direction or direction(s).
@end deftypemethod

@deftypemethod {mglData (Python)} @code{mglData *} Combine (@code{mglData *}a)
Return direct multiplication of arrays (like, res[i,j] = this[i]*a[j] and so on).
@end deftypemethod
@deftypemethod {mglData (Python)} @code{mglData *} Evaluate (@code{mglData *}idat, @code{bool} norm=@code{true})
@deftypemethodx mglData @code{mglData} Evaluate (@code{mglData *}idat, @code{mglData *}jdat, @code{bool} norm=@code{true})
@deftypemethodx mglData @code{mglData} Evaluate (@code{mglData *}idat, @code{mglData *}jdat, @code{mglData *}kdat, @code{bool} norm=@code{true})
Get array which values is result of interpolation of original array for coordinates from other arrays. All dimensions must be the same for data @var{idat}, @var{jdat}, @var{kdat}. Coordinates from @var{idat}, @var{jdat}, @var{kdat} are supposed to be normalized in range [0,1] (if @var{norm}=@code{true}) or in range [0,nx], [0,ny], [0,nz] correspondingly.
@end deftypemethod
@deftypemethod {mglData (Python)} @code{mglData} Resize (@code{int} mx, @code{int} my=@code{1}, @code{int} mz=@code{1}, @code{float} x1=@code{0}, @code{float} x2=@code{1}, @code{float} y1=@code{0}, @code{float} y2=@code{1}, @code{float} z1=@code{0}, @code{float} z2=@code{1}) @code{const}
Resizes the data to new size @var{mx}, @var{my}, @var{mz} from box (part) [@var{x1},@var{x2}] x [@var{y1},@var{y2}] x [@var{z1},@var{z2}] of original array. Initially x,y,z coordinates are supposed to be in [0,1].
@end deftypemethod

@c ------------------------------------------------------------------
@node Functions on direction (Python), Interpolation (Python), Make another data (Python), Python interface
@subsection Functions on direction (Python)
@cindex CumSum
@cindex Integral
@cindex Diff
@cindex Diff2
@cindex Swap
@cindex Mirror
@cindex Sew
@cindex Smooth
@cindex Envelop
@cindex Norm
@cindex NormSl

These functions change the data in some direction like differentiations, integrations and so on. The direction in which the change will applied is specified by the string parameter, which may contain @samp{x}, @samp{y} or @samp{z} characters for 1-st, 2-nd and 3-d dimension correspondengly.

@deftypemethod {mglData (Python)} @code{void} CumSum (@code{const char *}dir)
Cumulative summation of the data in given direction or directions.
@end deftypemethod
@deftypemethod {mglData (Python)} @code{void} Integral (@code{const char *}dir)
Integrates (like cumulative summation) the data in given direction or directions.
@end deftypemethod
@deftypemethod {mglData (Python)} @code{void} Diff (@code{const char *}dir)
Differentiates the data in given direction or directions.
@end deftypemethod
@deftypemethod {mglData (Python)} @code{void} Diff2 (@code{const char *}dir)
Double-differentiates (like Laplace operator) the data in given direction.
@end deftypemethod
@deftypemethod {mglData (Python)} @code{void} Swap (@code{const char *}dir)
Swaps the left and right part of the data in given direction (useful for Fourier spectrum).
@end deftypemethod
@deftypemethod {mglData (Python)} @code{void} Mirror (@code{const char *}dir)
Mirror the left-to-right part of the data in given direction. Looks like change the value index @var{i}->@var{n-i}.
@end deftypemethod
@deftypemethod {mglData (Python)} @code{void} Sew (@code{const char *}dir, @code{float} da=@code{2*M_PI})
Remove value steps (like phase jumps after inverse trigonometric functions) with period @var{da} in given direction.
@end deftypemethod
@deftypemethod {mglData (Python)} @code{void} Smooth (@code{int} Type, @code{const char *}dir, @code{float} delta=@code{0})
Smooths the data on specified direction or directions by method @var{Type}. Now 4 methods are supported: @code{SMOOTH_NONE} does nothing for @var{delta}=0 or approaches data to zero with the step @var{delta}, @code{SMOOTH_LINE_3} linear averaging by 3 points, @code{SMOOTH_LINE_5} linear averaging by 5 points, @code{SMOOTH_QUAD_5} quadratic averaging by 5 points. Parameter @var{delta} forbids to change values of array more than @var{delta} from the original ones. String @var{dirs} specifies the dimensions which will be smoothed. It may contain characters: 'x' for 1st dimension, 'y' for 2nd dimension, 'z' for 3d dimension.
@end deftypemethod

@deftypemethod {mglData (Python)} @code{void} Envelop (@code{char} dir=@code{'x'})
Find envelop for data values along direction @var{dir}.
@end deftypemethod

@deftypemethod {mglData (Python)} @code{void} NormSl (@code{float} v1=@code{0}, @code{float} v2=@code{1}, @code{char} dir=@code{'z'}, @code{bool} keep_en=@code{true}, @code{bool} sym=@code{false})
Normalizes data slice-by-slice along direction @var{dir} the data in slices to range [@var{v1},@var{v2}]. If flag @var{sym}=@code{true} then symmetrical interval [-max(|v1|,|v2|), max(|v1|,|v2|)] is used. If @var{keep_en} is set then maximal value of k-th slice will be limited by 
@iftex
@math{\sqrt{\sum a_{ij}(k)/\sum a_{ij}(0)}}.
@end iftex
@ifnottex
@math{\sqrt@{\sum a_ij(k)/\sum a_ij(0)@}}.
@end ifnottex
@end deftypemethod
@deftypemethod {mglData (Python)} @code{void} Norm (@code{float} v1=@code{0}, @code{float} v2=@code{1}, @code{bool} sym=@code{false}, @code{int} dim=@code{0})
Normalizes the data to range [@var{v1},@var{v2}]. If flag @var{sym}=@code{true} then symmetrical interval [-max(|v1|,|v2|), max(|v1|,|v2|)] is used. Modification will be applied only for slices >=@var{dim}.
@end deftypemethod

@c ------------------------------------------------------------------
@node Interpolation (Python), Informational functions (Python), Functions on direction (Python), Python interface
@subsection Interpolation (Python)
@cindex Spline
@cindex Spline1
@cindex Linear
@cindex Linear1
@cindex Spline5
@cindex v

@deftypemethod {mglData (Python)} @code{float} Spline (@code{float} x, @code{float} y=@code{0}, @code{float} z=@code{0}) @code{const}
Interpolates data by cubic spline to the given point @var{x}, @var{y}, @var{z} which assumed to be normalized in range [0, 1].
@end deftypemethod
@deftypemethod {mglData (Python)} @code{float} Linear (@code{float} x, @code{float} y=@code{0}, @code{float} z=@code{0}) @code{const}
Interpolates data by linear function to the given point @var{x}, @var{y}, @var{z} which assumed to be normalized in range [0, 1].
@end deftypemethod

@c ------------------------------------------------------------------
@node Informational functions (Python), , Interpolation (Python), Python interface
@subsection Informational functions (Python)
@cindex Maximal
@cindex Minimal

@deftypemethod {mglData (Python)} @code{float} Maximal () @code{const}
Gets maximal value of the data.
@end deftypemethod
@deftypemethod {mglData (Python)} @code{float} Minimal () @code{const}
Gets minimal value of the data.
@end deftypemethod

