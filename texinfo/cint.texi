@c ------------------------------------------------------------------
@node C interface, Python interface, Other classes, Top
@chapter C interface

MathGL library have interface for a set of languages. Most of them are based on C interface via SWIG tool. There are Python, Java, Octave, Lisp, C#, Guile, Lua, Modula 3, Ocaml, Perl, PHP, Pike, R, Ruby, Tcl. Also there is Fortran interface which have similar set of functions but slightly different type of arguments (integers instead of pointers). The C interface functions are described in @ref{C interface}.
@c ++++++++++
Some of languages listed above support classes (like Python). So for them the special wrapper was written. These classes and functions are described in @ref{Python interface}.
@c ++++++++++
Finally the special command language MGL was written for faster access to C++ plotting functions. Corresponding scripts can be executed separately (by UDAV, mgl2png, mgl2eps and so on) or from the C++ code (@pxref{mglParse class}). These commands are described in @ref{MGL interface}.

C interface is base for many other interfaces. It contain pure C functions for most of methods of MathGL classes. In difference from C++ classes, C functions must have argument HMGL (for graphics) and/or HMDT (for data arrays) which specify the object for drawing or manipulating (changing). So, firstly user have to create this object by function @code{mgl_create_*()} and have to delete it after using by function @code{mgl_delete_*()}.

All C functions are described in header file @code{#include <mgl/mgl_c.h>}
and use variable of types:
@itemize
@item 
@code{HMGL} --- Pointer to class @code{mglGraph} (@pxref{MathGL core}).
@item 
@code{HMDT} --- Pointer to class @code{mglData} (@pxref{mglData class}).
@item 
@code{HMPR} --- Pointer to class @code{mglParse} (@pxref{mglParse class})..
@end itemize
These variables contain identifiers for graphics drawing objects and for data objects. 

Fortran functions/subroutines have the same names as C functions. However, there is a difference. Variable of types @code{HMGL, HMDT} must be integer with sufficient size (@code{integer*4} for 32-bit operating system or @code{integer*8} for 64-bit operating system). All C functions are subroutines in Fortran which should be called by operator @code{call}. The exceptions are functions which return variables of types @code{HMGL} or @code{HMDT}. These functions should be declared as integer in Fortran code. Also one should keep in mind that strings in Fortran are denoted by @code{'} sign but not @code{"} one.

For compiling Fortran program you should specify AT&T calling conversion (it is default for gfortran, g77 and so on). The internal difference of AT&T interface from C interface is that the symbol '_' is added at the end of function name, and string length(s) is passed at the end of argument list. For example:
@itemize
@item
C function is
 
void mgl_fplot(HMGL graph, const char *fy, const char *stl, int n);

@item
AT&T function is

void mgl_fplot_(uintptr_t *graph, const char *fy, const char *stl, int
*n, int ly, int ls);
@end itemize

@menu
* Create and delete objects::   
* MGL parsing (Pure C)::        
* Graphics setup (Pure C)::     
* Axis settings (Pure C)::      
* Transformation matrix (Pure C)::  
* Export to file (Pure C)::     
* Primitives drawing (Pure C)::  
* Text printing (Pure C)::      
* Axis and Colorbar (Pure C)::  
* Legend (Pure C)::             
* 1D plotting (Pure C)::        
* 2D plotting (Pure C)::        
* 3D plotting (Pure C)::        
* Dual plotting (Pure C)::      
* Vector fields (Pure C)::      
* Other plotting (Pure C)::     
* Nonlinear fitting (Pure C)::  
* Frames/Animation (Pure C)::   
* Data import (Pure C)::        
* Data filling (Pure C)::       
* Rearrange data (Pure C)::     
* File I/O (Pure C)::           
* Make another data (Pure C)::  
* Functions on direction (Pure C)::  
* Interpolation (Pure C)::      
* Informational functions (Pure C)::  
* Operators (Pure C)::          
* Global functions (Pure C)::   
@end menu

@c ##################################################################
@node Create and delete objects, MGL parsing (Pure C), , C interface
@section Create and delete objects

There are several group of functions.

@itemize
@item Functions for non-visual ``grapher'' creation:
@deftypefn {C function} @code{HMGL} mgl_create_graph_gl ()
Create the instance of class mglGraphGL.
@end deftypefn
@deftypefn {C function} @code{HMGL} mgl_create_graph_zb (@code{int} width, @code{int} height)
Create the instance of class mglGraphZB with specified sizes.
@end deftypefn
@deftypefn {C function} @code{HMGL} mgl_create_graph_ps (@code{int} width, @code{int} height)
Create the instance of class mglGraphPS with specified sizes.
@end deftypefn
@deftypefn {C function} @code{HMGL} mgl_create_graph_idtf ()
Create the instance of class mglGraphIDTF.
@end deftypefn

@item Function for windowed ``grapher'' creation:
@deftypefn {C function} @code{HMGL} mgl_create_graph_glut (@code{int (*}draw@code{)(HMGL gr, void *p)}, @code{const char *}title, @code{void *}par)
Create the instance of class mglGraphGLUT and connected GLUT window. Only one GLUT window can be opened at once. Arguments description can be found in @ref{mglGraphAB class}.
@end deftypefn
@deftypefn {C function} @code{HMGL} mgl_create_graph_fltk (@code{int (*}draw@code{)(HMGL gr, void *p)}, @code{const char *}title, @code{void *}par)
Create the instance of class mglGraphFLTK and connected FLTK window. Several windows can be opened at the same time. However user must call @code{mgl_fltk_run()} function to start the message handling circle. Arguments description can be found in @ref{mglGraphAB class}. Note, that @var{draw} can be @code{NULL} for displaying static bitmaps only (no animation or slides).
@end deftypefn
@deftypefn {C function} @code{HMGL} mgl_create_graph_qt (@code{int (*}draw@code{)(HMGL gr, void *p)}, @code{const char *}title, @code{void *}par)
Create the instance of class mglGraphQT and connected Qt window. Several windows can be opened at the same time. However user must call @code{mgl_qt_run()} function to start the message handling circle. Arguments description can be found in @ref{mglGraphAB class}. Note, that @var{draw} can be @code{NULL} for displaying static bitmaps only (no animation or slides).
@end deftypefn
@deftypefn {C function} @code{void} mgl_fltk_run ()
Start FLTK message handling cycle. A normal program will end main() function with @code{return mgl_fltk_run();}.
@end deftypefn
@deftypefn {C function} @code{void} mgl_fltk_thread ()
Start FLTK message handling cycle. In difference of @code{mgl_fltk_run()} the loop is started in separate thread so that program continues immediately.
@end deftypefn
@deftypefn {C function} @code{void} mgl_qt_run ()
Start Qt message handling cycle. A normal program will end main() function with @code{return mgl_qt_run();}. Alternatively user may setup Qt application by direct Qt functions calls.
@end deftypefn
@deftypefn {C function} @code{void} mgl_qt_thread ()
Start Qt message handling cycle. In difference of @code{mgl_qt_run()} the loop is started in separate thread so that program continues immediately.
@end deftypefn
@deftypefn {C function} @code{void} mgl_update (@code{HMGL} graph)
Manually update contents of the window.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_show_mouse_pos (@code{HMGL} graph, @code{int} enable)
Switch to show or not in the widget the last mouse click position.
@end deftypefn
@deftypefn {C function} @code{void} mgl_get_last_mouse_pos (@code{HMGL} graph, @code{float *}x, @code{float *}y, @code{float *}z)
Last position of mouse click.
@end deftypefn
@deftypefn {C function} @code{void} mgl_calc_xyz (@code{HMGL} graph, @code{int} xs, @code{int} ys, @code{float *}x, @code{float *}y, @code{float *}z)
Calculate 3D coordinate @{x,y,z@} for screen point @{xs,ys@}. At this moment it ignore perspective and transformation formulas (curvilinear coordinates). The calculation are done for the last used InPlot (@pxref{Transformation matrix}).
@end deftypefn


@item Functions for data creation:
@deftypefn {C function} @code{HMDT} mgl_create_data ()
Create simple instance of class mglData.
@end deftypefn
@deftypefn {C function} @code{HMDT} mgl_create_data_size (@code{int} nx, @code{int} ny, @code{int} nz)
Create instance of class mglData with specified sizes.
@end deftypefn
@deftypefn {C function} @code{HMDT} mgl_create_data_file (@code{const char *}fname)
Create instance of class mglData and fill it by data from text file.
@end deftypefn

@item Each created object @strong{must} be deleted after usage by functions:
@deftypefn {C function} @code{void} mgl_delete_graph (@code{HMGL} graph)
Delete the instance of class. Must be used after plotting for every created graphical object.
@end deftypefn
@deftypefn {C function} @code{void} mgl_delete_data (@code{HMDT} dat)
Delete the instance of class. Must be used after using for every created data object.
@end deftypefn
@end itemize

@c ##################################################################
@node MGL parsing (Pure C), Graphics setup (Pure C), Create and delete objects, C interface
@section MGL parsing (Pure C)

These functions allow one to parse MGL script from the program.

@deftypefn {C function} @code{HMPR} mgl_create_parser ()
Create parser.
@end deftypefn
@deftypefn {C function} @code{void} mgl_delete_parser (@code{HMPR} p)
Delete parser
@end deftypefn
@deftypefn {C function} @code{void} mgl_add_param (@code{HMPR} p, @code{int} id, @code{const char *}val)
@deftypefnx {C function} @code{void} mgl_add_paramw (@code{HMPR} p, @code{int} id, @code{const wchar_t *}val)
Add script parameter @var{id} with value @var{val} (used in string as '\$0','\$1' \ldots '\$9').
@end deftypefn
@deftypefn {C function} @code{const HMDT} mgl_add_var (@code{HMPR} p, @code{const char *}name)
Add variable with @var{name} if it is not exists. Return the created or found variable. @strong{NOTE!!!} You must not delete obtained data arrays. Use this function to put external data array to the script or get the data from the script.
@end deftypefn
@deftypefn {C function} @code{const HMDT} mgl_find_var  (@code{HMPR} p, @code{const char *}name)
Find variable with @var{name} and return it (or @code{NULL} if variable is absent). @strong{NOTE!!!} You must not delete obtained data arrays. Use this function to put external data array to the script or get the data from the script.
@end deftypefn
@deftypefn {C function} @code{int} mgl_parse (@code{HMGL} gr, @code{HMPR} p, @code{const char *}str, @code{int} pos)
@deftypefnx {C function} @code{int} mgl_parsew (@code{HMGL} gr, @code{HMPR} p, @code{const wchar_t *}str, @code{int} pos)
Parse and draw (using @var{gr}) the string @var{str} with MGL commands. Returns the value depending on an error presence in the string str: 0 - no error, 1 - wrong command argument(s), 2 - unknown command, 3 - string is too long. 
@end deftypefn

@deftypefn {C function} @code{void} mgl_parse_text (@code{HMGL} gr, @code{HMPR} p, @code{const char *}text)
@deftypefnx {C function} @code{void} mgl_parsew_text (@code{HMGL} gr, @code{HMPR} p, @code{const wchar_t *}text)
Function parse and execute line-by-line MGL script in string @var{text}. Lines are separated by @samp{\n} symbol as usual. If @var{error} is not @code{NULL} then this function will be called for all warnings, information and other messages. Also this function support the @code{for|next} MGL commands.
@end deftypefn



@deftypefn {C function} @code{void} mgl_restore_once (@code{HMPR} p)
Restore 'once' state (for data reloading on next parsing).
@end deftypefn
@deftypefn {C function} @code{void} mgl_parser_allow_setsize (@code{HMPR} p, @code{int} a)
Allow to parse 'setsize' command or not.
@end deftypefn

@c ##################################################################
@node Graphics setup (Pure C), Transformation matrix (Pure C), MGL parsing (Pure C), C interface
@section Graphics setup (Pure C)

Functions and variables in this group influences on overall graphics appearance. So all of them should be placed @emph{before} any actual plotting function calls.

@deftypefn {mglGraph (C function)} @code{void} mgl_set_def_param (@code{HMGL} gr)
Restore initial values for all of parameters except described in @ref{Zooming}.
@end deftypefn

@menu
* Transparency (Pure C)::       
* Lighting (Pure C)::           
* Fog (Pure C)::                
* Default sizes (Pure C)::      
* Zooming (Pure C)::            
* Cutting (Pure C)::            
* Font settings (Pure C)::      
* Palette and colors (Pure C)::  
* Other settings (Pure C)::     
@end menu

@c ==================================================================
@node Transparency (Pure C), Lighting (Pure C), , Graphics setup (Pure C)
@subsection Transparency (Pure C)
@cindex Alpha
@cindex AlphaDef
@cindex Transparent
@cindex TranspType

There are several functions for setup transparency. The general function is @code{Alpha()} which switch on/off the transparency for overall plot. It influence only for graphics which created after @code{Alpha()} call. Variable @code{AlphaDef} specify the default value of alpha-channel. You may switch off transparency of selected plot by variable @code{Transparent}. Finally, variable @code{TranspType} set the kind of transparency. @sref{Transparent surface sample}

@deftypefn {C function} @code{void} mgl_set_alpha (@code{HMGL} gr, @code{int} enable)
Sets the transparency on/off. It is recommended to call this function before any plotting command. Default value is transparency off. Use @code{mgl_set_transp(false)} in particular plot to disable its transparency.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_alpha_default (@code{HMGL} gr, @code{float} alpha)
Default value of alpha channel (transparency) for all plotting functions.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_transp (@code{HMGL} gr, @code{int} enable)
Temporary switches transparency on/off for the plot.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_transp_type (@code{HMGL} gr, @code{int} enable)
This variable set the transparency type. Normal transparency (@samp{0}) -- below things is less visible than upper ones. It does not look well in OpenGL mode (mglGraphGL) for several surfaces. Glass-like transparency (@samp{1}) -- below and upper things are commutable and just decrease intensity of light by RGB channel. Lamp-like transparency (@samp{2}) -- below and upper things are commutable and are the source of some additional light. I recommend to set @code{mgl_set_alpha_default(0.3)} or less for lamp-like transparency.
@end deftypefn

@c ==================================================================
@node Lighting (Pure C), Fog (Pure C), Transparency (Pure C), Graphics setup (Pure C)
@subsection Lighting (Pure C)
@cindex Light
@cindex Ambient

There are several functions for setup lighting. The general function is @code{mgl_set_light()} which switch on/off the lighting for overall plot. It influence only for graphics which created after @code{mgl_set_light()} call. Generally MathGL support up to 10 independent light sources. But in OpenGL mode only 8 of light sources is used due to OpenGL limitations. The position, color, brightness of each light source can be set separately. By default only one light source is active. It is source number @code{0} with white color, located at top of the plot.

@deftypefn {C function} @code{void} mgl_set_light (@code{HMGL} gr, @code{int} enable)
Sets the using of light on/off for overall plot. It is recommended to call this function before any plotting command. Default value is lightning off.
@end deftypefn
@deftypefn {C function} @code{void} mgl_set_light_n (@code{HMGL} gr, @code{int} n, @code{int} enable)
Switch on/off @var{n}-th light source separately.
@end deftypefn

@deftypefn {C function} @code{void} mgl_add_light (@code{HMGL} gr, @code{int} n, @code{float} x, @code{float} y, @code{float} z, @code{char} c)
@deftypefnx {C function} @code{void} mgl_add_light_rgb (@code{HMGL} gr, @code{int} n, @code{float} x, @code{float} y, @code{float} z, @code{int} infty, @code{float} r, @code{float} g, @code{float} b, @code{float} i)
The function adds a light source with identification @var{n} at position @{@var{x}, @var{y}, @var{z}@}. The color of light is defined by character @var{c} or by RGB values @{@var{r}, @var{g}, @var{b}@}. The brightness of light is @var{i} which must be in range [0,1]. Flag @var{infty}=@code{true} puts the source to infinite distance (for the faster drawing). It is recommended to call this function before any plotting command.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_ambbr (@code{HMGL} gr, @code{float} bright)
Sets the brightness of ambient light. The value should be in range [0,1]. Initial value is @code{0.5}. It is recommended to call this function before any plotting command.
@end deftypefn

@c ==================================================================
@node Fog (Pure C), Default sizes (Pure C), Lighting (Pure C), Graphics setup (Pure C)
@subsection Fog (Pure C)
@cindex Fog

@deftypefn {C function} @code{void} mgl_set_fog (@code{HMGL} gr, @code{float} d, @code{float} dz)
Function imitate a fog in the plot. Fog start from relative distance @var{dz} from view point and its density growths exponentially in depth. So that the fog influence is determined by law ~ 1-exp(-@emph{d*z}). Here @emph{z} is normalized to 1 depth of the plot. If value @var{d}=@code{0} then the fog is absent. @sref{Surface in fog sample}
@end deftypefn

@c ==================================================================
@node Default sizes (Pure C), Zooming (Pure C), Fog (Pure C), Graphics setup (Pure C)
@subsection Default sizes (Pure C)
@cindex BarWidth
@cindex MarkSize
@cindex ArrowSize
@cindex BaseLineWidth
@cindex SetTickLen
@cindex SetTickStl

These functions control the default (initial) values for most graphics parameters including sizes of markers, arrows, linewidth and so on. As any other settings these ones will influence only on plots created after the settings change.

@deftypefn {C function} @code{void} mgl_set_bar_width (@code{HMGL} gr, @code{float} val)
Relative width of rectangles in Bars plot. Default value is @code{0.7}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_mark_size (@code{HMGL} gr, @code{float} val)
The size of marks for @ref{1D plotting (Pure C)}. Default value is @code{0.02}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_arrow_size (@code{HMGL} gr, @code{float} val)
The size of arrows for @ref{1D plotting (Pure C)}, lines and curves. Default value is @code{0.03}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_base_line_width (@code{HMGL} gr, @code{float} val)
The variable define the base width for all lines. The value <1 is ignored. Increase of this variables is actual for large bitmap pictures. Default value is @code{1}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_tick_len (@code{HMGL} gr, @code{float} val, @code{float} stt)
The relative length of axis ticks. Default value is @code{0.1}. Parameter @var{stt}>0 set relative length of subticks which is in @code{sqrt(1+stt)} times smaller.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_tick_stl (@code{HMGL} gr, @code{const char *}stl, @code{const char *}sub)
The line style of axis ticks (@var{stl}) and subticks (@var{sub}). If @var{stl} is empty then default style is used (@samp{k} or @samp{w} depending on transparency type). If @var{sub} is empty then ticks style is used (i.e. @var{stl}).
@end deftypefn


@c ==================================================================
@node Zooming (Pure C), Cutting (Pure C), Default sizes (Pure C), Graphics setup (Pure C)
@subsection Zooming (Pure C)
@cindex PlotFactor
@cindex AutoPlotFactor
@cindex Zoom

These functions control the overall zooming of the picture or the sub-picture. Normally you can use these variables and functions for removing ``white'' spaces around a plot.

@deftypefn {C function} @code{void} mgl_set_plotfactor (@code{HMGL} gr, @code{float} val)
Sets the factor of plot size. It is not recommended to set it lower then 1.6. This is some anlogue of function Zoom() but applied not to overall image but for each InPlot. Use negative value to enable automatic @code{PlotFactor} selection.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_zoom (@code{HMGL} gr, @code{float} x1, @code{float} y1, @code{float} x2, @code{float} y2)
Changes the scale of graphics that correspond to zoom in/out of the picture. After function call the current plot will be cleared and further the picture will contain plotting from its part [x1,x2]*[y1,y2]. Here picture coordinates @var{x1}, @var{x2}, @var{y1}, @var{y2} changes from 0 to 1. Use @code{Zoom(0,0,1,1)} to return default view.
@end deftypefn

@c ==================================================================
@node Cutting (Pure C), Font settings (Pure C), Zooming (Pure C), Graphics setup (Pure C)
@subsection Cutting (Pure C)
@cindex Cut
@cindex CutMin
@cindex CutMax
@cindex CutOff

These functions set the condition when the points are excluded (cutted) from the drawing.

@deftypefn {C function} @code{void} mgl_set_cut (@code{HMGL} gr, @code{int} val)
Determines how points outside bounding box are drawn. If it is @code{true} then points are excluded from plot (it is default) otherwise the points are projected to edges of bounding box.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_cut_box (@code{HMGL} gr, @code{float} x1, @code{float} y1, @code{float} z1, @code{float} x2, @code{float} y2, @code{float} z2)
Lower and upper edge of the box in which never points are drawn. If both edges are the same (the variables are equal) then the cutting box is empty. @sref{CutMinMax sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_cutoff (@code{HMGL} gr, @code{const char *}EqC)
Function set the cutting off condition by formula @var{EqC}. This condition determine will point be plotted or not. If value of formula is nonzero then point is omitted, otherwise it plotted. Set argument as @code{NULL} to disable cutting off condition. @sref{CutOff sample}
@end deftypefn

@c ==================================================================
@node Font settings (Pure C), Palette and colors (Pure C), Cutting (Pure C), Graphics setup (Pure C)
@subsection Font settings
@cindex FontSize (Pure C)
@cindex FontDef
@cindex RotatedText

@deftypefn {C function} @code{void} mgl_set_font_size (@code{HMGL} gr, @code{float} val)
Sets the size of font for tick and axis labels. Default font size of axis labels is 1.4 times large than for tick labels.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_font_def (@code{HMGL} gr, @code{const char *} val)
Sets the font specification (@pxref{Text printing (Pure C)}). Default is ``rC'' -- Roman font centering.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_rotated_text (@code{HMGL} gr, @code{int} val)
Sets to use or not text rotation along axis.
@end deftypefn

@deftypefn {C function} @code{void} mgl_load_font (@code{HMGL} gr, @code{const char *}name, @code{const char *}path)
Load font typeface from @var{path}/@var{name}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_copy_font (@code{HMGL} gr, @code{HMGL} gr_from)
Copy font data from another HMGL object.
@end deftypefn

@deftypefn {C function} @code{void} mgl_restore_font (@code{HMGL} gr)
Restore font data to default typeface.
@end deftypefn

@c ==================================================================
@node Palette and colors (Pure C), Other settings (Pure C), Font settings (Pure C), Graphics setup (Pure C)
@subsection Pallete (Pure C)
@cindex Pal
@cindex NumPal
@cindex SetPalette
@cindex SetScheme
@cindex SelectPen

@deftypefn {C function} @code{void} mgl_set_palette (@code{HMGL} gr, @code{const char *}@var{colors})
Sets the palette as selected colors. Default value is @code{"Hbgrcmyhlnqeup"}. The palette is used mostly in 1D plots (@pxref{1D plotting (Pure C)}) for curves which styles are not specified.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_pal_color (@code{HMGL} gr, @code{int} n, @code{float} r, @code{float} g, @code{float} b)
Sets color for individual palette entry. Look at @code{mgl_set_palette()} function for simplified palette setting.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_pal_num (@code{HMGL} gr, @code{int} num)
Sets the number of actual colors in palette. The value must be less then 100.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_scheme (@code{HMGL} gr, @code{const char *}sch)
Sets the color scheme for following plots. Usually this function is used internally. @xref{Color scheme}.
@end deftypefn


@c ==================================================================
@node Other settings (Pure C), , Palette and colors (Pure C), Graphics setup (Pure C)
@subsection Other settings (Pure C)

@deftypefn {C function} @code{void} mgl_set_meshnum (@code{HMGL} gr, @code{int} num)
Sets approximate number of lines in Mesh(), Fall(), Grid() and also the number of hachures in Vect(), VectC(), Dew() and the number of cells in Cloud*(). By default (=0) it draws all lines/hachures/cells.
@end deftypefn

@deftypefn {C function} @code{} mgl_set_axial_dir (@code{HMGL} gr, @code{char} dir)
Sets direction around which curve rotated in Axial() and Torus(). Default value is 'z'.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_draw_face (@code{HMGL} gr, @code{int} val)
If set to @code{true} then it prevent faces drawing. It is useful for speeding up drawing (for example, during rotation and so on).
@end deftypefn


@c ==================================================================
@node Axis settings (Pure C), Transformation matrix (Pure C), Graphics setup (Pure C), C interface
@section Axis settings (Pure C)

These large set of functions control how the axis and ticks will be drawn. Note that there is 3-step transformation of data coordinates are performed. Firstly, coordinates are projected if @code{Cut=true} (@pxref{Cutting (Pure C)}), after it transformation formulas are applied, and finally the data was normalized in bounding box.

@menu
* Ranges (bounding box) (Pure C)::  
* Transformation (Pure C)::     
* Ticks (Pure C)::              
@end menu

@c ------------------------------------------------------------------
@node Ranges (bounding box) (Pure C), Transformation (Pure C), , Axis settings (Pure C)
@subsection Ranges (bounding box) (Pure C)
@cindex Axis
@cindex CAxis
@cindex XRange
@cindex YRange
@cindex ZRange
@cindex Min
@cindex Max
@cindex Cmin
@cindex Cmax
@cindex Org
@cindex AutoOrg

@deftypefn {C function} @code{void} mgl_set_axis_2d (@code{HMGL} gr, @code{float} x1, @code{float} y1, @code{float} x2, @code{float} y2)
@deftypefnx {C function} @code{void} mgl_set_axis_3d (@code{HMGL} gr, @code{float} x1, @code{float} y1, @code{float} z1, @code{float} x2, @code{float} y2, @code{float} z2)
@c @deftypefnx {C function} @code{void} mgl_set_axis (@code{HMGL} gr, @code{float} x1, @code{float} y1, @code{float} z1, @code{float} x2, @code{float} y2, @code{float} z2, @code{float} x0, @code{float} y0, @code{float} z0)
Sets maximal and minimal values for coordinate range (bounding box). If minimal and maximal values of the coordinate are the same or a variable is absent in the list of arguments then they are ignored. This function also sets @var{Cmin}=@var{z1} and @var{Cmax}=@var{z2}. This is default color range for 2d plots.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_caxis (@code{HMGL} gr, @code{float} c1, @code{float} c2)
Sets values for color range. This values are used later for determining the color of the surface.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_xrange (@code{HMGL} gr, @code{const HMDT} a, @code{int} add)
Sets values of x-range as minimal and maximal values of data @var{a}. See also mgl_set_axis().
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_yrange (@code{HMGL} gr, @code{const HMDT} a, @code{int} add)
Sets values of y-range as minimal and maximal values of data @var{a}. See also mgl_set_axis().
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_zrange (@code{HMGL} gr, @code{const HMDT} a, @code{int} add)
Sets values of z-range as minimal and maximal values of data @var{a}. See also mgl_set_axis().
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_crange (@code{HMGL} gr, @code{const HMDT} a, @code{int} add)
Sets values of color range as minimal and maximal values of data @var{a}. See also  mgl_set_caxis().
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_origin (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0)
Sets center of axis cross section. If one of values is NAN then MathGL library try to select optimal axis position.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_auto (@code{HMGL} gr, @code{float} x1, @code{float} x2, @code{float} y1, @code{float} y2, @code{float} z1, @code{float} z2)
Sets ranges for automatic variables of plots. It act as changing of @var{Min}, @var{Max} proprties without calling of RecalcBorder(). Function don't change the direction if minimal and maximal values are the same. For example, if y@var{y1}=@var{y2} then ranges along y-direction will not be changed (will be used previous one). Note that the automatic range become axis range after next call of [XYZ]Range() function(s).
@end deftypefn

@c ------------------------------------------------------------------
@node Transformation (Pure C), Ticks (Pure C), Ranges (bounding box) (Pure C), Axis settings (Pure C)
@subsection Transformation (curved coordinates, Pure C)
@cindex Axis
@cindex Ternary

@deftypefn {C function} @code{void} mgl_set_func (@code{HMGL} gr, @code{const char *}EqX, @code{const char *}EqY, @code{const char *}EqZ)
Sets the transformation formulas for curvilinear coordinate. Each string should contain mathematical expression for new (real) coordinate depending on old (input) coordinates x, y, z. For example, the cylindrical coordinates are introduced as @code{mgl_set_func("x*cos(y)", "x*sin(y)", "z");}. For removing of formulas the corresponding parameter should be @code{NULL}. Using transformation formulas will slightly slowing the program, i.e. @code{mgl_set_func(NULL, NULL, NULL)} is faster than @code{mgl_set_func("x", "y", "z")}. @xref{mglFormula class}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_coor (@code{HMGL} gr, @code{int} how)
Sets one of the predefined transformation formulas for curvilinear coordinate. Paramater @var{how} define the coordinates: @code{mglCartesian=0} -- Cartesian coordinates (no transformation); @code{mglPolar=1} -- Polar coordiantes @math{x_n=x*cos(y),y_n=x*sin(y), z_n=z}; @code{mglSpherical=2} -- Sperical coordinates @math{x_n=x*sin(y)*cos(z), y_n=x*sin(y)*sin(z), z_n=x*cos(y)}; @code{mglParabolic=3} -- Parabolic coordinates @math{x_n=x*y, y_n=(x*x-y*y)/2, z_n=z}; @code{mglParaboloidal=4} -- Paraboloidal coordinates @math{x_n=(x*x-y*y)*cos(z)/2, y_n=(x*x-y*y)*sin(z)/2, z_n=x*y}; @code{mglOblate=5} -- Oblate coordinates @math{x_n=cosh(x)*cos(y)*cos(z), y_n=cosh(x)*cos(y)*sin(z), z_n=sinh(x)*sin(y)}; @code{mglProlate=6} -- Prolate coordinates @math{x_n=sinh(x)*sin(y)*cos(z), y_n=sinh(x)*sin(y)*sin(z), z_n=cosh(x)*cos(y)}; @code{mglElliptic=7} -- Elliptic coordinates @math{x_n=cosh(x)*cos(y), y_n=sinh(x)*sin(y), z_n=z}; @code{mglToroidal=8} -- Toroidal coordinates @math{x_n=sinh(x)*cos(z)/(cosh(x)-cos(y)), y_n=sinh(x)*sin(z)/(cosh(x)-cos(y)), z_n=sin(y)/(cosh(x)-cos(y))}; @code{mglBispherical=9} -- Bispherical coordinates @math{x_n=sin(y)*cos(z)/(cosh(x)-cos(y)), y_n=sin(y)*sin(z)/(cosh(x)-cos(y)), z_n=sinh(x)/(cosh(x)-cos(y))}; @code{mglBipolar=10} -- Bipolar coordinates @math{x_n=sinh(x)/(cosh(x)-cos(y)), y_n=sin(y)/(cosh(x)-cos(y)), z_n=z}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_ternary (@code{HMGL} gr, @code{int} tern)
The function sets to draws Ternary plot. This special plot is for 3 dependent coordinates (components) @var{a}, @var{b}, @var{c} so that @var{a}+@var{b}+@var{c}=1. MathGL uses only 2 independent coordinates @var{a}=x and @var{b}=y since it is enough to plot everything. At this third coordinate z act as another parameter to produce contour lines, surfaces and so on. @sref{Ternary plot sample}
@end deftypefn

@c ------------------------------------------------------------------
@node Ticks (Pure C), , Transformation (Pure C), Axis settings (Pure C)
@subsection Ticks (Pure C)
@cindex SetTicks
@cindex SetTicksVal
@cindex xtt
@cindex ytt
@cindex ztt
@cindex ctt
@cindex OrgT
@cindex TuneTicks
@cindex AdjustTicks

@deftypefn {C function} @code{void} mgl_adjust_ticks (@code{HMGL} gr, @code{const char *}dir)
Set the ticks step, number of sub-ticks and initial ticks position to be the most human readable for the axis along direction(s) @var{dir}. Also set @var{TuneTicks}=@code{true}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_ticks_dir (@code{HMGL} gr, @code{char} dir, @code{float} d, @code{int} ns, @code{float} org)
Set the ticks step @var{d}, number of sub-ticks @var{ns} and initial ticks position @var{org} for the axis along direction @var{dir}. Variable @var{d} set step for axis ticks (if positive) or it's number on the axis range (if negative). Zero value set logarithmic ticks. If @var{org} value is NAN then value from @var{Org} is used.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_ticks_vals (@code{HMGL} gr, @code{char} dir, @code{int} n, @code{float *}val, @code{const char **}lbl)
@deftypefnx {C function} @code{void} mgl_set_ticks_val (@code{HMGL} gr, @code{char} dir, @code{int} n, @code{double} val, @code{const char *}lbl, ...)
Set the manual positions @var{val} and its labels @var{lbl} for @var{n}-th ticks along axis @var{dir}. The arrays @var{val} and @var{lbl} have to contain @var{n} elements. Use @code{mgl_set_ticks_dir()} to restore automatic ticks. Note, these functions are not available in Fortran interface. Note, you @strong{have to be} very careful to use floating-point (not integer!!!) values as ticks position due to limitations of stdarg library (argument transfer). @sref{Manual ticks sample}
@end deftypefn


@deftypefn {C function} @code{void} mgl_set_ticks (@code{HMGL} gr, @code{float} dx, @code{float} dy, @code{float} dz)
Step for axis ticks (if positive) or it's number (if negative) in x-,y-,z- directions. Zero value set logarithmic ticks. This function are obsolete -- use @code{mgl_set_ticks_dir()} function instead.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_subticks (@code{HMGL} gr, @code{int} nx, @code{int} ny, @code{int} nz)
Number of axis subticks in x-,y-,z- directions. This function are obsolete -- use @code{mgl_set_ticks_dir()} function instead.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_tick_origin (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0)
Starting point for ticks. If corresponding value is NAN then value from @var{Org} is used (it is default). This function are obsolete -- use @code{mgl_set_ticks_dir()} function instead.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_xttw (@code{HMGL} gr, @code{const wchar_t *}templ)
@deftypefnx {C function} @code{void} mgl_set_yttw (@code{HMGL} gr, @code{const wchar_t *}templ)
@deftypefnx {C function} @code{void} mgl_set_zttw (@code{HMGL} gr, @code{const wchar_t *}templ)
@deftypefnx {C function} @code{void} mgl_set_cttw (@code{HMGL} gr, @code{const wchar_t *}templ)
@deftypefnx {C function} @code{void} mgl_set_xtt (@code{HMGL} gr, @code{const wchar_t *}templ)
@deftypefnx {C function} @code{void} mgl_set_ytt (@code{HMGL} gr, @code{const wchar_t *}templ)
@deftypefnx {C function} @code{void} mgl_set_ztt (@code{HMGL} gr, @code{const wchar_t *}templ)
@deftypefnx {C function} @code{void} mgl_set_ctt (@code{HMGL} gr, @code{const wchar_t *}templ)
The template for x-,y-,z-axis ticks or colorbar ticks. It may contain TeX symbols also. If @var{templ}=@code{NULL} then default template is used (in simplest case it is @samp{%.2g}) with automatic detaching of common multiplier or common component (see @var{TuneTicks}).
@end deftypefn

@deftypefn {C function} @code{void} mgl_tune_ticks (@code{HMGL} gr, @code{int} tune, @code{float} fact_pos)
Switch on/off ticks enhancing by factoring common multiplier (for small, like from 0.001 to 0.002, or large, like from 1000 to 2000, coordinate values) or common component (for narrow range, like from 0.999 to 1.000). Also set the position of common multiplier/component on the axis: =0 at minimal axis value, =1 at maximal axis value. Default value is 1.15.
@end deftypefn


@c ##################################################################
@node Transformation matrix (Pure C), Export to file (Pure C), Axis settings (Pure C), C interface
@section Transformation matrix (Pure C)
@cindex Aspect
@cindex Rotate
@cindex RotateN
@cindex SubPlot
@cindex InPlot
@cindex Identity
@cindex Perspective
@cindex ColumnPlot

These functions control how and where further plotting will be placed. There is a curtain order of calling of these functions for the better plot view. First one should be SubPlot() or InPlot() for specifying the place. After it a Rotate() and Aspect(). And finally any other plotting functions may be called. Alternatevely you can use ColumnPlot() for position plots in the column one by another without gap between plot axis (bounding boxes).

@deftypefn {C function} @code{void} mgl_subplot (@code{HMGL} gr, @code{int} nx, @code{int} ny, @code{int} m)
@deftypefnx {C function} @code{void} mgl_subplot_d (@code{HMGL} gr, @code{int} nx, @code{int} ny, @code{int} m, @code{float} dx, @code{float} dy)
Puts further plotting in a @var{m}-th cell of @var{nx}*@var{ny} grid of the whole frame area. This function set off any aspects or rotations. So it should be used first for creating the subplot. From the aesthetical point of view it is not recommended to use this function with different matrices in the same frame. The position of the cell can be shifted from its default position by relative size @var{dx}, @var{dy}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_inplot (@code{HMGL} gr, @code{float} x1, @code{float} x2, @code{float} y1, @code{float} y2)
Puts further plotting in some region of the whole frame surface. This function allows one to create a plot in arbitrary place of the screen. The position is defined by rectangular coordinates [@var{x1}, @var{x2}]*[@var{y1}, @var{y2}]. The coordinates @var{x1}, @var{x2}, @var{y1}, @var{y2} are normalized to interval [0, 1]. This function set off any aspects or rotations. So it should be used first for creating subplot.
@end deftypefn

@deftypefn {C function} @code{void} mgl_relplot (@code{HMGL} gr, @code{float} x1, @code{float} x2, @code{float} y1, @code{float} y2)
Puts further plotting in some region of the last SubPlot() or InPlot(). This function allows one to create a plot in arbitrary place of the screen. The position is defined by rectangular coordinates [@var{x1}, @var{x2}]*[@var{y1}, @var{y2}]. The coordinates @var{x1}, @var{x2}, @var{y1}, @var{y2} are normalized to interval [0, 1]. This function set off any aspects or rotations. So it should be used first for creating subplot.
@end deftypefn

@deftypefn {C function} @code{void} mgl_rotate (@code{HMGL} gr, @code{float} TetX, @code{float} TetZ, @code{float} TetY)
Rotates a further plotting relative to each axis (x, z, y) consecutively on angles @var{TetX}, @var{TetZ}, @var{TetY}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_rotate_vector (@code{HMGL} gr, @code{float Tet}, @code{float x}, @code{float y}, @code{float z})
Rotates a further plotting around vector @{x,y,z@}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_aspect (@code{HMGL} gr, @code{float} Ax, @code{float} Ay, @code{float} Az)
Defines aspect ratio for the plot. The viewable axes will be related one to another as the ratio @var{Ax:Ay:Az}. For the best effect it should be used after Rotate() function.
@end deftypefn

@deftypefn {C function} @code{void} mgl_perspective (@code{HMGL} gr, @code{float} a)
Add (switch on) the perspective to plot. The parameter @math{a ~ 1/z_@{eff@} \in [0,1)}. By default (@code{a=0}) the perspective is off.
@end deftypefn

@deftypefn {C function} @code{void} mgl_identity (@code{HMGL} gr)
Clears transformation matrix. This function clears all previous effects of Aspect(), SubPlot(), InPlot() or Rotate() functions. It is equivalent to the call of  @code{mgl_inplot(0,1,0,1)}.
@end deftypefn

@c ##################################################################
@node Export to file (Pure C), Primitives drawing (Pure C), Transformation matrix (Pure C), C interface
@section Export to file (Pure C)
@cindex WritePNG
@cindex WriteIDTF
@cindex WriteSVG
@cindex WriteBMP
@cindex WriteEPS
@cindex WriteJPEG
@cindex SetSize
@cindex GetRGBA
@cindex GetBits

These functions export current view to a graphic file. The filename @var{fname} should have appropriate extension. Parameter @var{descr} gives the short description of the picture. Just now the transparency is supported in PNG and SVG files.

@deftypefn {C function} @code{void} mgl_write_frame (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to a file @var{fname} which type is determined by the extension. Parameter @var{descr} adds description to file (can be @code{NULL}). If @var{fname}=@code{NULL} then the file @samp{frame####.jpg} is used, where @samp{####} is current frame id.
@end deftypefn

@deftypefn {C function} @code{void} mgl_write_png (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
@deftypefnx {C function} @code{void} mgl_write_png_solid (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to PNG file with transparent background. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (can be @code{NULL}).
@end deftypefn

@deftypefn {C function} @code{void} mgl_write_jpg (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to JPEG file with non-transparent background (usually white). Parameter @var{fname} specifies the file name, @var{descr} adds description to file (can be @code{NULL}).
@end deftypefn

@deftypefn {C function} @code{void} mgl_write_gif (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to GIF file with non-transparent background (usually white). Parameter @var{fname} specifies the file name, @var{descr} adds description to file (can be @code{NULL}).
@end deftypefn

@deftypefn {C function} @code{void} mgl_write_bmp (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to BMP file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (can be @code{NULL}). There is no compression used.
@end deftypefn

@deftypefn {C function} @code{void} mgl_write_eps (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to EPS file. The vector representation is used if possible. So it is not recommended for the export of large data plot. It is better to use bitmap format (for example PNG or JPEG). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (can be @code{NULL}).
@end deftypefn

@deftypefn {C function} @code{void} mgl_write_svg (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to SVG (Scalable Vector Graphics) file. The vector representation is used. In difference of EPS format, SVG format support transparency that allows to correctly draw half-transparent plot (like SurfA(), Surf3A(), Cloud()). Note, the output file may be too large for graphic of large data array (especially for surfaces). It is better to use bitmap format (for example PNG or JPEG). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name).
@end deftypefn

@deftypefn {C function} @code{void} mgl_write_idtf (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to IDTF file. Later this file can be converted to U3D format. The vector representation is used. So, the output file may be too large for graphic of large data array (especially for surfaces). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name).
@end deftypefn

@deftypefn {C function} @code{void} mgl_show_image (@code{const char *}viewer, @code{int} nowait)
Displays the current picture using external program @var{viewer} for viewing. The function save the picture to temporary file and call @var{viewer} to display it. If @var{nowait}=@code{true} then the function return immediately (it will not wait while window will be closed).
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_size (@code{HMGL} gr, @code{int} width, @code{int} height)
Sets size of picture in pixels. This function @strong{must be} called before any other plotting because it completely remove picture contents.
@end deftypefn

@deftypefn {C function} @code{void} mgl_flush (@code{HMGL} gr)
Flushes the plotting commands to frame. This function may be useful if one wants to remove array before the finishing of the plot (i.e. before calling @code{Finish()}). Also call of this function separate the objects in mglGraphIDTF. Most of plots call this function internally.
@end deftypefn

@deftypefn {C function} @code{int} mgl_get_width (@code{HMGL} gr)
@deftypefnx {C function} @code{int} mgl_get_height (@code{HMGL} gr)
Gets width or height of the image.
@end deftypefn

@deftypefn {C function} @code{const unsigned char *} mgl_get_rgb (@code{HMGL} gr)
Gets RGB bitmap of the current state of the image. Format of each element of bits is: @{red, green, blue@}. Number of elements is Width*Height. Position of element @{i,j@} is [3*i + 3*Width*j].
@end deftypefn

@deftypefn {C function} @code{const unsigned char *} mgl_get_rgba (@code{HMGL} gr)
Gets RGBA bitmap of the current state of the image. Format of each element of bits is: @{red, green, blue, alpha@}. Number of elements is Width*Height. Position of element @{i,j@} is [4*i + 4*Width*j].
@end deftypefn

@c ##################################################################
@node Primitives drawing (Pure C), Text printing (Pure C), Export to file (Pure C), C interface
@section Primitives drawing
@cindex Ball
@cindex Clf
@cindex Line
@cindex Curve
@cindex Mark
@cindex FaceX
@cindex FaceY
@cindex FaceZ
@cindex Cone
@cindex Drop
@cindex Sphere

These functions draw some simple objects like line, point, sphere, drop, cone and so on.

@deftypefn {C function} @code{void} mgl_clf (@code{HMGL} gr)
@deftypefnx {C function} @code{void} mgl_clf_rgb (@code{HMGL} gr, @code{float} r, @code{float} g, @code{float} b)
Clear the picture and will it by color @{@var{r},@var{g},@var{b}@} or previous one.
@end deftypefn

@deftypefn {C function} @code{void} mgl_ball (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z)
@deftypefnx {C function} @code{void} mgl_ball_rgb (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z, @code{float} r, @code{float} g, @code{float} b, @code{float} alpha)
@deftypefnx {C function} @code{void} mgl_ball_str (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z, @code{const char *} col)
Draws a point (ball) at position @{@var{x}, @var{y}, @var{z}@} with color defined by string @var{col} or by RGBA values @{@var{r}, @var{g}, @var{b}; @var{alpha}@}. Default color is red.
@end deftypefn

@deftypefn {C function} @code{void} mgl_line (@code{HMGL} gr, @code{float} x1, @code{float} y1, @code{float} z1, @code{float} x2, @code{float} y2, @code{float} z2, @code{char *}stl, @code{int}num)
Draws a geodesic line (straight line in Cartesian coordinates) from point @{@var{x1},@var{y1},@var{z1}@} to @{@var{x2},@var{y2},@var{z2}@} using line style @var{stl}. Parameter @var{num} define the ``quality'' of the line. If @var{num}=@code{2} then the straight line will be drawn in all coordinate system (independently on transformation formulas (@pxref{Transformation (Pure C)}). Contrary, for large values (for example, =@code{100}) the geodesic line will be drawn in corresponding coordinate system (straight line in Cartesian coordinates, circle in polar coordinates and so on).
@end deftypefn

@deftypefn {C function} @code{void} mgl_curve (@code{HMGL} gr, @code{float} x1, @code{float} y1, @code{float} z1, @code{float} dx1, @code{float} dy1, @code{float} dz1, @code{float} x2, @code{float} y2, @code{float} z2, @code{float} dx2, @code{float} dy2, @code{float} dz2, @code{const char *}stl, @code{int} num)
Draws Bezier-like curve from point @{@var{x1},@var{y1},@var{z1}@} to @{@var{x2},@var{y2},@var{z2}@} using line style @var{stl}. At this tangent is co-directed with @{@var{dx1},@var{dy1},@var{dz1}@}, @{@var{dx2},@var{dy2},@var{dz2}@} and proportional to its amplitude. Parameter @var{num} define the number of points for the curve.
@end deftypefn

@deftypefn {C function} @code{void} mgl_facex (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0, @code{float} wy, @code{float} wz, @code{const char *}stl, @code{float} d1, @code{float} d2)
@deftypefnx {C function} @code{void} mgl_facey (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0, @code{float} wx, @code{float} wz, @code{const char *}stl, @code{float} d1, @code{float} d2)
@deftypefnx {C function} @code{void} mgl_facez (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0, @code{float} wx, @code{float} wy, @code{const char *}stl, @code{float} d1, @code{float} d2)
Draws the solid rectangle (face) perpendicular to [x,y,z]-axis correspondingly at position @{@var{x0}, @var{y0}, @var{z0}@} with color @var{stl} and with widths @var{wx}, @var{wy}, @var{wz} along corresponding directions. At this colors can be the same for all vertexes or different if all 4 colors are specified for each vertex. Parameters @var{d1}!=0, @var{d2}!=0 set additional shift of the last vertex (i.e. to draw quadrangle).
@end deftypefn

@deftypefn {C function} @code{void} mgl_sphere (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0, @code{float} r, @code{const char *}stl)
Draw the sphere with radius @var{r} and center at point @{@var{x0}, @var{y0}, @var{z0}@} and color @var{stl}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_drop (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0, @code{float} dx, @code{float} dy, @code{float} dz, @code{float} r, @code{const char *}col, @code{float} shift, @code{float} ap)
Draw the drop with radius @var{r} at point @{@var{x0},@var{y0},@var{z0}@} elongated in direction @{@var{dx},@var{dy},@var{dz}@} and with color @var{col}. Parameter @var{shift} set the degree of drop oblongness: @samp{0} is sphere, @samp{1} is maximally oblongness drop. Parameter @var{ap} set relative width of the drop (this is analogue of ``ellipticity'' for the sphere). @sref{Drops sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_cone (@code{HMGL} gr, @code{float} x1, @code{float} y1, @code{float} z1, @code{float} x2, @code{float} y2, @code{float} z2, @code{float} r1, @code{float} r2, @code{const char *}stl, @code{int} draw_edge)
Draw tube (or truncated cone if @var{edge}=@code{false}) between points @{@var{x1},@var{y1},@var{z1}@}, @{@var{x2},@var{y2},@var{z2}@} with radius at the edges @var{r1}, @var{r2}. If @var{r2}<0 then it is suppsosed that @var{r2}=@var{r1}. The cone color is defined by string @var{stl}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_mark (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z, @code{char} mark)
Draws a marks of different type at position @{@var{x},@var{y},@var{z}@}.
@end deftypefn

@c ##################################################################
@node Text printing (Pure C), Axis and Colorbar (Pure C), Primitives drawing (Pure C), C interface
@section Text printing (Pure C)
@cindex Puts
@cindex Putsw
@cindex Text
@cindex Title

These functions draw the text. There are functions for drawing text in arbitrary place, in arbitrary direction and along arbitrary curve. The class mglFont (@pxref{mglFont class}) is used for low-level string parsing and printing. It can use arbitrary font-faces and parse many TeX commands. All these functions have 2 variant: for printing 8-bit text (@code{char *}) and for printing Unicode text (@code{wchar_t *}). In first case the conversion in current locale is used. So sometimes you need to specify it by @code{setlocale()} function. The size argument control the size of text: if positive it give the value, if negative it give the value relative to @var{FontSize}. The font type (STIX, arial, courier, times and so on) can be selected by function @code{mgl_load_font()}. @xref{Font settings (Pure C)}.

The font parameters are described by string. This string may contain several characters of font type (@samp{rbiwou}) and/or align (@samp{LRC}) specification. Also it may contain the text color @samp{wkrgbcymhRGBCYMHW} (@pxref{mglColor class}) after symbol @samp{:}. The font types are: @samp{r} -- roman font, @samp{i} -- italic style, @samp{b} -- bold style, @samp{w} -- wired style, @samp{o} -- over-lined text, @samp{u} -- underlined text. By default roman font is used. The align types are: @samp{L} -- align left (default), @samp{C} -- align center, @samp{R} -- align right. Also a parsing of the LaTeX-like syntax is provided (for detail @pxref{mglFont class}). For example, string @samp{iC:b} correspond to italic font style for centered text which printed by blue color.

@deftypefn {C function} @code{void} mgl_puts (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z, @code{const char *}text)
@deftypefnx {C function} @code{void} mgl_putsw (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z, @code{const wchar_t *}text)
@deftypefnx {C function} @code{void} mgl_puts_ext (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z, @code{const char *}text, @code{const char *}font, @code{float} size, @code{char} dir)
@deftypefnx {C function} @code{void} mgl_putsw_ext (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z, @code{const wchar_t *}text, @code{const char *}font, @code{float} size, @code{char} dir)
The function plots the string @var{text} at position @{@var{x},@var{y},@var{z}@} with fonts specifying by the criteria @var{how}. The size of font is set by @var{size} parameter (default is @var{FontSize}). Parameter @var{dir} specifies the additional string align. The aligns are: @samp{x} -- align as x-label, @samp{y} -- align as y-label, @samp{z} -- align as z-label, @samp{i} -- align as x-label but inverse writing direction, @samp{t} -- no align (default), @samp{n} -- align in x-y plane.
@end deftypefn

@deftypefn {C function} @code{void} mgl_puts_dir (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z, @code{float} dx, @code{float} dy, @code{float} dz, @code{const char *}text, @code{float} size)
@deftypefnx {C function} @code{void} mgl_putsw_dir (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z, @code{float} dx, @code{float} dy, @code{float} dz, @code{const wchar_t *}text, @code{float} size)
The function plots the string @var{text} at position @{@var{x},@var{y},@var{z}@} along direction @{@var{dx},@var{dy},@var{dz}@} with specified @var{size}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_title (@code{HMGL} gr, @code{const char *}text, @code{const char *}font, @code{int} size)
@deftypefnx {C function} @code{void} mgl_titlew (@code{HMGL} gr, @code{const wchar_t *}text, @code{const char *}font, @code{int} size)
Print string @var{text} as title of the picture (at the top of the picture). Can be used at any place (even inside SubPlot()).
@end deftypefn

@deftypefn {C function} @code{void} mgl_text_y (@code{HMGL} gr, @code{const HMDT} y, @code{const char *}text, @code{const char *}font, float size)
@deftypefnx {C function} @code{void} mgl_text_xy (@code{const HMDT} x, @code{const HMDT} y, @code{const char *}text, @code{const char *}font, float size)
@deftypefnx {C function} @code{void} mgl_text_xyz (@code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}text, @code{const char *}font, float size)
The function draws @var{text} along the curve between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} by font style @var{font} and with size @var{size}. The string @var{font} may contain symbols @samp{t} for printing the text under the curve (default), or @samp{T} for printing the text above the curve. The sizes of 1st dimension must be equal for all arrays @var{x.nx=y.nx=z.nx}. If array @var{x} is not specified then its an automatic array is used with values equidistantly distributed in interval [@var{Min}.x, @var{Max}.x] (@pxref{Ranges (bounding box) (Pure C)}). If array @var{z} is not specified then @var{z}[i] = @var{zVal} is used. @sref{Text sample}
@end deftypefn

@c ##################################################################
@node Axis and Colorbar (Pure C), Legend (Pure C), Text printing (Pure C), C interface
@section Axis and Colorbar (Pure C)
@cindex Axis
@cindex Box
@cindex Grid
@cindex Colorbar
@cindex Label

These functions draw the ``things for measuring'', like axis with ticks, colorbar with ticks, grid along axis, bounding box and labels for axis. For more information @pxref{Axis settings (Pure C)}.

@deftypefn {C function} @code{void} mgl_axis (@code{HMGL} gr, @code{const char *}dir)
Draws axes with ticks (@pxref{Axis settings (Pure C)}) in directions determined by string parameter @var{dir}.If string contain the symbol @samp{_} then tick labels are not printed. Font for ticks labels is determined by @code{mgl_set_font_def()} (@pxref{Font settings (Pure C)}).
@end deftypefn

@deftypefn {C function} @code{void} mgl_colorbar (@code{HMGL} gr, @code{const char *}sch, @code{int} where)
Draws colorbar with color scheme @var{sch} (current scheme if @code{sch=NULL}) at edge of plot. Parameter @var{where} specifies the position of colorbar: @samp{0} - at right (default), @samp{1} - at left, @samp{2} - at top, @samp{3} - at bottom. @sref{Dens sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_colorbar_ext (@code{HMGL} gr, @code{const char *}sch, @code{int} where, @code{float} x, @code{float} y, @code{float} w, @code{float} h)
Draws colorbar with color scheme @var{sch} (current scheme if not specified) at arbitrary position of subplot @{@var{x}, @var{y}@} (supposed to be in range [0,1]). Parameter @var{where} specifies the position of colorbar labels: @samp{0} - at left, @samp{1} - at right, @samp{2} - at bottom, @samp{3} - at top. Parameters @var{w}, @var{h} set the relative width and height of the colorbar.
@end deftypefn

@deftypefn {C function} @code{void} mgl_colorbar_val (@code{HMGL} gr, @code{const HMDT} v, @code{const char *}sch, @code{int} where)
Draws colorbar with sharp colors @var{sch} (current palette if @code{sch=NULL}) for values @var{v} at edge of plot. Parameter @var{where} specifies the position of colorbar: @samp{0} - at right (default), @samp{1} - at left, @samp{2} - at top, @samp{3} - at bottom. @sref{Dens sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_axis_grid (@code{HMGL} gr, @code{const char *}dir, @code{const char *}pen)
Draws grid lines perpendicular to direction determined by string parameter @var{dir}. The step of grid lines is the same as tick step for an Axis(). The style of lines is determined by @var{pen} parameter.
@end deftypefn

@deftypefn {C function} @code{void} mgl_box (@code{HMGL} gr, @code{int} ticks)
@deftypefnx {C function} @code{void} mgl_box_rgb (@code{HMGL} gr, @code{float} r, @code{float} g, @code{float} b, @code{int} ticks)
@deftypefnx {C function} @code{void} mgl_box_str (@code{HMGL} gr, @code{const char *}col, @code{int} ticks)
Draws bounding box outside the plotting volume with color specified by string @var{col} or by RGB values.
@end deftypefn

@deftypefn {C function} @code{void} mgl_label (@code{HMGL} gr, @code{char} dir, @code{const char *}text)
@deftypefnx {C function} @code{void} mgl_label_ext (@code{HMGL} gr, @code{char} dir, @code{const char *}text, @code{int} pos, @code{float} size, @code{float} shift)
Prints the label @var{text} for axis @var{dir}=@samp{x},@samp{y},@samp{z},@samp{t}  (here @samp{t} is ``ternary'' axis @math{t=1-x-y}). The position of label is determined by @var{pos} parameter. If @var{pos}=0 then label is printed at the center of axis. If @var{pos}>0 then label is printed at the maximum of axis (default). If @var{pos}<0 then label is printed at the minimum of axis. Parameter @var{size} determines the font size for the label. By default the font size is 1.4 times larger than the one for ticks @var{FontSize}. @xref{Text printing (Pure C)}.
@end deftypefn

@c ##################################################################
@node Legend (Pure C), 1D plotting (Pure C), Axis and Colorbar (Pure C), C interface
@section Legend (Pure C)
@cindex Legend
@cindex AddLegend
@cindex ClearLegend

These functions draw legend to the graph (useful for @ref{1D plotting (Pure C)}). Legend entry is a pair of strings: one for style of the line, another one with description text (with included LaTeX parsing). The array of string are accumulated first to the internal arrays (by function AddLegend()) and are plotted later. The position of the legend can be selected automatic or manually. Parameters @var{font} and @var{size} specify the font style and size (@pxref{Font settings (Pure C)}). Parameter @var{llen} set the relative width of the line sample and the text indent (default value is 0.1). If line style string for entry is empty then the corresponding text is printed without indent. @sref{Legend sample}

@deftypefn {C function} @code{void} mgl_legend (@code{HMGL} gr, @code{int} where, @code{const char *}font, @code{float} size, @code{float} llen)
Draws legend of accumulated legend entries by font @var{font} with @var{size}. Parameter @var{where} sets the position of the legend: @samp{0} is bottom left corner, @samp{1} is bottom right corner, @samp{2} is top left corner, @samp{3} is top right corner (is default).
@end deftypefn

@deftypefn {C function} @code{void} mgl_legend_xy (@code{HMGL} gr, @code{float} x, @code{float} y, @code{const char *}font, @code{float} size, @code{float} llen)
Draws legend of accumulated legend entries by font @var{font} with @var{size}. Position of legend is determined by parameter @var{x}, @var{y} which supposed to be normalized to interval [0,1].
@end deftypefn

@deftypefn {C function} @code{void} mgl_add_legend (@code{HMGL} gr, @code{const char *}text, @code{const char *}style)
@deftypefnx {C function} @code{void} mgl_add_legendw (@code{HMGL} gr, @code{const wchar_t *}text, @code{const char *}style)
Adds string @var{text} to internal legend accumulator. The style of described line and mark is specified in string @var{style} (@pxref{Line styles}). Maximal number of entries is 100.
@end deftypefn

@deftypefn {C function} @code{void} mgl_clear_legend (@code{HMGL} gr)
Clears saved legend strings.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_legend_box (@code{HMGL} gr, @code{int} enable)
Switch on/off drawing box near legend. By default (=@code{true}) box is drawn.
@end deftypefn

@c ##################################################################
@node 1D plotting (Pure C), 2D plotting (Pure C), Legend (Pure C), C interface
@section 1D plotting (Pure C)

These functions perform plotting of 1D data. 1D means that data depended from only 1 parameter like parametric curve @{x(i),y(i),z(i)@}, i=1...n. There are 5 generally different types of data representations: simple line plot (Plot), line plot with filling under it (Area), stairs plot (Step), bar plot (Bars, Barh) and vertical lines (Stem). Each type of plotting has similar interface. There are 3D version and two 2D versions. One of last requires single array. The parameters of line and marks are specified by the string argument. If the string parameter is NULL then solid line with color from palette Pal is used (@pxref{Palette and colors}). Also there are some special 1d plots having slightly different interface: surface of curve rotation (Torus), chart (Chart) and error boxes (Error), marks with variable size (Mark), tubes (Tube) and so on. @xref{Line styles}.

@menu
* Plot (Pure C)::               
* Radar (Pure C)::               
* Tens (Pure C)::               
* Area (Pure C)::               
* Region (Pure C)::             
* Bars (Pure C)::               
* Barh (Pure C)::               
* Stem (Pure C)::               
* Step (Pure C)::               
* Torus (Pure C)::              
* Chart (Pure C)::              
* Mark (Pure C)::               
* TextMark (Pure C)::           
* Error (Pure C)::              
* Tube (Pure C)::               
@end menu


@c ==================================================================
@node Plot (Pure C), Radar (Pure C), , 1D plotting (Pure C)
@subsection Plot (Pure C)
@cindex Plot

These functions draw continuous lines between points. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also Area(), Step(), Stem, Tube(), Mark(), Error(), Belt(). @sref{Plot sample}

@deftypefn {C function} @code{void} mgl_plot_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}pen)
The function draws continuous lines between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space.
@end deftypefn

@deftypefn {C function} @code{void} mgl_plot_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const char *}pen)
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_plot (@code{HMGL} gr, @code{const HMDT} y, @code{const char *}pen)
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn


@c ==================================================================
@node Radar (Pure C), Tens (Pure C), Plot (Pure C), 1D plotting (Pure C)
@subsection Radar
@cindex Radar

@deftypefn {C function} @code{void} mgl_radar (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}pen, @code{float} r)
This functions draws radar chart which is continuous lines between points located on an radial lines (like plot in Polar coordinates). The plots are drawn for each row if one of the data is the matrix. Parameter @var{r} set the additional shift of data (i.e. the data @var{a}+@var{r} is used instead of @var{a}). If @code{r<0} then @code{r=max(0, -min(a)}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). If @var{pen} containt @samp{#} symbol then "grid" (radial lines and circle for @var{r}) is drawn See also @ref{Plot}. @sref{Radar sample}
@end deftypefn


@c ==================================================================
@node Tens (Pure C), Area (Pure C), Radar (Pure C), 1D plotting (Pure C)
@subsection Tens (Pure C)
@cindex Tens

These functions draw continuous lines between points with color defined by the special array (look like tension plot). The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color scheme (@pxref{Color scheme}) and style and/or width of line (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with current color scheme is used. See also Plot(), Mesh(), Fall(). @sref{Tens sample}

@deftypefn {C function} @code{void} mgl_tens_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} c, @code{const char *}pen)
The function draws continuous lines between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space with color defined by @var{c}[i].
@end deftypefn

@deftypefn {C function} @code{void} mgl_tens_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} c, @code{const char *}pen)
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z} with color defined by @var{c}[i].
@end deftypefn

@deftypefn {C function} @code{void} mgl_tens (@code{HMGL} gr, @code{const HMDT} y, @code{const HMDT} c, @code{const char *}pen)
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z} with color defined by @var{c}[i], where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn


@c ==================================================================
@node Area (Pure C), Region (Pure C), Tens (Pure C), 1D plotting (Pure C)
@subsection Area (Pure C)
@cindex Area

These functions draw continuous lines between points and fills it to axis plane. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also Plot(), Bars(), Stem(). @sref{Area sample}

@deftypefn {C function} @code{void} mgl_area_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}pen)
The function draws continuous lines between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space and fills it down to @var{z} = @var{Org.z}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_area_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const char *}pen)
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z} and fills it down to @var{y} = @var{Org.y}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_area_xys (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const char *}pen)
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z} and fills it down to @var{y} = @var{Org.y}. The lines are drawn one abover another (like summation). Note, you can reach the same effect if call @code{mgl_data_cumsum(y,"y");} before plot.
@end deftypefn

@deftypefn {C function} @code{void} mgl_area (@code{HMGL} gr, @code{const HMDT} y, @code{const char *}pen)
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z} and fills it down to @var{y} = @var{Org.y}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn

@c ==================================================================
@node Region (Pure C), Bars (Pure C), Area (Pure C), 1D plotting (Pure C)
@subsection Region (Pure C)
@cindex Region

These functions fill area between 2 curves. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y1.nx=y2.nx} and all dimensions of arrays @var{y1} and @var{y2} must be equal too. String @var{pen} specifies the color (@pxref{Line styles}). By default (@code{pen=NULL}) color from palette is used (@pxref{Palette and colors}). See also Area(), Bars(), Stem(). @sref{Region sample}

@deftypefn {C function} @code{void} mgl_region_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y1, @code{const HMDT} y2, @code{const char *}pen, @code{int} inside)
The function fills area between curves @{@var{x}[i], @var{y1}[i]@} and @{@var{x}[i], @var{y2}[i]@}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_region (@code{HMGL} gr, @code{const HMDT} y1, @code{const HMDT} y2, @code{const char *}pen, @code{int} inside)
The function fills area between curves @{@var{x}[i], @var{y1}[i]@} and @{@var{x}[i], @var{y2}[i]@}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn

@c ==================================================================
@node Bars (Pure C), Barh (Pure C), Region (Pure C), 1D plotting (Pure C)
@subsection Bars (Pure C)
@cindex Bars

These functions draw vertical bars from points to axis plane. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also Barh(), Area(), Stem(), Chart(). @sref{Bars sample}

@deftypefn {C function} @code{void} mgl_bars_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}pen=@code{NULL})
The function draws vertical bars from points @{@var{x}[i], @var{y}[i], @var{z}[i]@} down to @var{z} = Org.z.
@end deftypefn

@deftypefn {C function} @code{void} mgl_bars_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws vertical bars from points @{@var{x}[i], @var{y}[i]@} down to @var{y} = Org.y in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}).
@end deftypefn

@deftypefn {C function} @code{void} mgl_bars (@code{HMGL} gr, @code{const HMDT} y, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws vertical bars from points @{@var{x}[i], @var{y}[i]@} down to @var{y} = Org.y in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}), where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn

@c ==================================================================
@node Barh (Pure C), Stem (Pure C), Bars (Pure C), 1D plotting (Pure C)
@subsection Barh (Pure C)
@cindex Barh

These functions draw horizontal bars from points to axis plane. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also Bars(). @sref{Barh sample}

@deftypefn {C function} @code{void} mgl_barh_xy (@code{HMGL} gr, @code{const HMDT} y, @code{const HMDT} v, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws horizontal bars from points @{@var{v}[i], @var{y}[i]@} down to @var{x} = Org.x in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}).
@end deftypefn

@deftypefn {C function} @code{void} mgl_barh (@code{HMGL} gr, @code{const HMDT} v, @code{const char *}pen=@code{NULL}, @code{float} zVal=@code{NAN})
The function draws horizontal bars from points @{@var{v}[i], @var{y}[i]@} down to @var{x} = Org.x in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}), where @var{y}[i] values are equidistantly distributed in interval [@var{Min}.y, @var{Max}.y].
@end deftypefn

@c ==================================================================
@node Stem (Pure C), Step (Pure C), Barh (Pure C), 1D plotting (Pure C)
@subsection Stem (Pure C)
@cindex Stem

These functions draw vertical lines from points to axis plane. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also Area(), Bars(), Plot(). @sref{Stem sample}

@deftypefn {C function} @code{void} mgl_stem_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}pen)
The function draws vertical lines from points @{@var{x}[i], @var{y}[i], @var{z}[i]@} down to @var{z} = Org.z.
@end deftypefn

@deftypefn {C function} @code{void} mgl_stem_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const char *}pen)
The function draws vertical lines from points @{@var{x}[i], @var{y}[i]@} down to @var{y} = Org.y in plane @var{z}=@var{Min.z}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_stem (@code{HMGL} gr, @code{const HMDT} y, @code{const char *}pen)
The function draws vertical lines from points @{@var{x}[i], @var{y}[i]@} down to @var{y} = Org.y in plane @var{z}=@var{Min.z}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn


@c ==================================================================
@node Step (Pure C), Torus (Pure C), Stem (Pure C), 1D plotting (Pure C)
@subsection Step (Pure C)
@cindex Step

These functions draw continuous stairs for points to axis plane. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also Plot(), Stem(), Tile(), Boxs(). @sref{Step sample}

@deftypefn {C function} @code{void} mgl_step_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}pen)
The function draws continuous stairs for points @{@var{x}[i], @var{y}[i], @var{z}[i]@}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_step_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const char *}pen)
The function draws continuous stairs for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_step (@code{HMGL} gr, @code{const HMDT} y, @code{const char *}pen)
The function draws continuous stairs for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn

@c ==================================================================
@node Torus (Pure C), Chart (Pure C), Step (Pure C), 1D plotting (Pure C)
@subsection Torus (Pure C)
@cindex Torus

These functions draw surface which is result of curve @{@var{r}, @var{z}@} rotation around @var{AxialDir} axis (@pxref{Other settings}). The sizes of 1st dimension @strong{must be equal} for all arrays @var{r.nx=z.nx}. String @var{pen} specifies the color (@pxref{Line styles}). By default (@code{pen=NULL}) color from palette is used (@pxref{Palette and colors}). See also Plot(), Axial(). @sref{Torus sample}

@deftypefn {C function} @code{void} mgl_torus (@code{HMGL} gr, @code{const HMDT} r, @code{const HMDT} z, @code{const char *}pen)
The function draws surface which is result of curve @{@var{r}[i], @var{z}[i]@} rotation.
@end deftypefn

@deftypefn {C function} @code{void} mgl_torus_2 (@code{HMGL} gr, @code{const HMDT} z, @code{const char *}pen)
The function draws surface which is result of curve @{@var{r}[i], @var{z}[i]@} rotation, where @var{r}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn


@c ==================================================================
@node Chart (Pure C), Mark (Pure C), Torus (Pure C), 1D plotting (Pure C)
@subsection Chart (Pure C)
@cindex Chart

@deftypefn {C function} @code{void} mgl_chart (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}col)
The function draws colored stripes (boxes) for data in array @var{a}. The number of stripes is equal to the number of rows in @var{a} (equal to @var{a.ny}). The color of each next stripe is cyclically changed from colors specified in string @var{col} or in palette Pal (@pxref{Palette and colors}). Spaces in colors denote transparent ``color'', i.e. if @var{col} contain space(s) then corresponding stripe(s) are not drawn. The stripe width is proportional to value of element in @var{a}. Chart is plotted only for data with non-negative elements. If string @var{col} have symbol @samp{#} then black border lines are drawn. The most nice form the chart have in 3d (after rotation of coordinates) or in cylindrical coordinates (becomes so called Pie chart). @sref{Chart sample}
@end deftypefn

@c ==================================================================
@node Mark (Pure C), TextMark (Pure C), Chart (Pure C), 1D plotting (Pure C)
@subsection Mark (Pure C)
@cindex Mark

These functions draw marks with size @var{r}*@var{MarkSize} (@pxref{Default sizes}) at points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx=r.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). If you need to draw markers of the same size then you may use Plot() function. See also Plot(), TextMark(), Stem(), Error(). @sref{Mark sample}

@deftypefn {C function} @code{void} mgl_mark_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} r, @code{const char *}pen)
The function draws marks for points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space.
@end deftypefn

@deftypefn {C function} @code{void} mgl_mark_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} r, @code{const char *}pen)
The function draws marks for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_mark_y (@code{HMGL} gr, @code{const HMDT} y, @code{const HMDT} r, @code{const char *}pen)
The function draws marks for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn

@c ==================================================================
@node TextMark (Pure C), Error (Pure C), Mark (Pure C), 1D plotting (Pure C)
@subsection TextMark (Pure C)
@cindex TextMark

These functions draw string @var{text} as marks with size proportional to @var{r}*@var{MarkSize} (@pxref{Default sizes}) at points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx=r.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also Plot(), Mark(), Stem(). @sref{TextMark sample}

@deftypefn {C function} @code{void} mgl_textmarkw_xyzr (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} r, @code{const wchar_t *}text, @code{const char *}fnt=@code{NULL})
@end deftypefn
@deftypefn {C function} @code{void} mgl_textmark_xyzr (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} r, @code{const char *}text, @code{const char *}fnt=@code{NULL})
The function draws textual marks for points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space.
@end deftypefn

@deftypefn {C function} @code{void} mgl_textmarkw_xyr (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} r, @code{const wchar_t *}text, @code{const char *}fnt)
@deftypefnx {C function} @code{void} mgl_textmark_xyr (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} r, @code{const char *}text, @code{const char *}fnt)
The function draws textual marks for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_textmarkw_yr (@code{HMGL} gr, @code{const HMDT} y, @code{const HMDT} r, @code{const wchar_t *}text, @code{const char *}fnt)
@deftypefnx {C function} @code{void} mgl_textmark_yr (@code{HMGL} gr, @code{const HMDT} y, @code{const HMDT} r, @code{const char *}text, @code{const char *}fnt)
The function draws textual marks for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn

@deftypefn {C function} @code{void} mgl_textmarkw (@code{HMGL} gr, @code{const HMDT} y, @code{const wchar_t *}text, @code{const char *}fnt)
@deftypefnx {C function} @code{void} mgl_textmark (@code{HMGL} gr, @code{const HMDT} y, @code{const char *}text, @code{const char *}fnt)
The function draws textual marks for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x]. The mark sizes @var{r}[i]=1 for all points.
@end deftypefn

@c ==================================================================
@node Error (Pure C), Tube (Pure C), TextMark (Pure C), 1D plotting (Pure C)
@subsection Error (Pure C)
@cindex Error

These functions draw error boxes at points @{@var{x}[i], @var{y}[i]@}  on plane @var{z} = @var{zVal} (by default @var{z}=@var{Min.z}). This can be useful, for example, in experimental points, or to show numeric error or some estimations and so on. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx=r.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also Plot(). @sref{Error sample}

@deftypefn {C function} @code{void} mgl_error_exy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} ex, @code{const HMDT} ey, @code{const char *}pen)
Draws a error box @{@var{ex}, @var{ey}@} in point position @{@var{x}, @var{y}@}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_error_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} ey, @code{const wchar_t *}pen)
Draws a error box @var{ey} (along only one direction) in point position @{@var{x}, @var{y}@}.
@end deftypefn
@deftypefn {C function} @code{void} mgl_error (@code{HMGL} gr, @code{const HMDT} y, @code{const HMDT} ey, @code{const char *}pen)
Draws a error box @var{ey} (along only one direction) in point position @{@var{x}, @var{y}@}, where @var{x} values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn

@c ==================================================================
@node Tube (Pure C), , Error (Pure C), 1D plotting (Pure C)
@subsection Tube (Pure C)
@cindex Tube

These functions draw the tube with variable radius @var{r} along the curve between points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx=r.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}). See also Plot(). @sref{Tube sample}

@deftypefn {C function} @code{void} mgl_tube_xyzr (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} r, @code{const char *}pen)
@deftypefnx {C function} @code{void} mgl_tube_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{float} r, @code{const char *}pen)
The function draws tube with radius @var{r} between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space.
@end deftypefn

@deftypefn {C function} @code{void} mgl_tube_xyr (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} r, @code{const char *}pen)
@deftypefnx {C function} @code{void} mgl_tube_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{float} r, @code{const char *}pen)
The function draws tube with radius @var{r} between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_tube_r (@code{HMGL} gr, @code{const HMDT} y, @code{const HMDT} r, @code{const char *}pen)
@deftypefnx {C function} @code{void} mgl_tube (@code{HMGL} gr, @code{const HMDT} y, @code{float} r, @code{const char *}pen)
The function draws tube with radius @var{r} between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{Min.z}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn

@c ##################################################################
@node 2D plotting (Pure C), 3D plotting (Pure C), 1D plotting (Pure C), C interface
@section 2D plotting (Pure C)

These functions perform plotting of 2D data. 2D means that data depend from 2 independent parameters like matrix @math{f(x_i,y_j), i=1...n, j=1...m}. There are 6 generally different types of data representations: simple mesh lines plot (Mesh), surface plot (Surf), surface plot by boxes (Boxs), surface plot by tiles (Tile), waterfall-like plot (Fall), belt plot (Belt), density plot (Dens), contour lines plot (Cont), solid contours plot (ContF) and its rotational figure (Axial). Cont, ContF and Axial functions have variants for automatic and manual selection of level values for contours. Also there are functions for plotting data grid lines according to the data format (Grid) for enhancing density or contour plots. Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@menu
* Mesh (Pure C)::               
* Fall (Pure C)::               
* Belt (Pure C)::               
* Surf (Pure C)::               
* Boxs (Pure C)::               
* Tile (Pure C)::               
* Dens (Pure C)::               
* Cont (Pure C)::               
* ContF (Pure C)::              
* ContD (Pure C)::              
* Axial (Pure C)::              
* Grid (Pure C)::               
@end menu

@c ==================================================================
@node Mesh (Pure C), Fall (Pure C), , 2D plotting (Pure C)
@subsection Mesh (Pure C)
@cindex Mesh

@deftypefn {C function} @code{void} mgl_mesh_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch)
The function draws mesh lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Mesh lines are plotted for each z slice of the data. See also Surf(), Fall(), NeshNum, Cont(). @sref{Mesh sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_mesh (@code{HMGL} gr, @code{const HMDT} z, @code{const char *}sch)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Fall (Pure C), Belt (Pure C), Mesh (Pure C), 2D plotting (Pure C)
@subsection Fall (Pure C)
@cindex Fall

@deftypefn {C function} @code{void} mgl_fall_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch=@code{NULL})
The function draws fall lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. If @var{sch} contain @samp{x} then lines are drawn along x-direction else (by default) lines are drawn along y-direction. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Fall lines are plotted for each z slice of the data. See also Belt(), Mesh(), NeshNum. @sref{Fall sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_fall (@code{HMGL} gr, @code{const HMDT} z, @code{const char *}sch=@code{NULL})
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Belt (Pure C), Surf (Pure C), Fall (Pure C), 2D plotting (Pure C)
@subsection Belt (Pure C)
@cindex Belt

@deftypefn {C function} @code{void} mgl_belt_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch)
The function draws belts for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. This plot can be used as 3d generalization of Plot(). String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. If @var{sch} contain @samp{x} then belts are drawn along x-direction else (by default) belts are drawn along y-direction. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Belts are plotted for each z slice of the data. See also Fall(), Surf(), Plot(), NeshNum. @sref{Belt sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_belt (@code{HMGL} gr, @code{const HMDT} z, @code{const char *}sch)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Surf (Pure C), Boxs (Pure C), Belt (Pure C), 2D plotting (Pure C)
@subsection Surf (Pure C)
@cindex Surf

@deftypefn {C function} @code{void} mgl_surf_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch)
The function draws surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also Mesh(), Dens(), Belt(), Tile(), Boxs(), SurfC(), SurfA(). @sref{Surf sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_surf (@code{HMGL} gr, @code{const HMDT} z, @code{const char *}sch)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Boxs (Pure C), Tile (Pure C), Surf (Pure C), 2D plotting (Pure C)
@subsection Boxs (Pure C)
@cindex Boxs

@deftypefn {C function} @code{void} mgl_boxs_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch)
The function draws vertical boxes for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also Surf(), Tile(), Step(). @sref{Boxs sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_boxs (@code{HMGL} gr, @code{const HMDT} z, @code{const char *}sch)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Tile (Pure C), Dens (Pure C), Boxs (Pure C), 2D plotting (Pure C)
@subsection Tile (Pure C)
@cindex Tile

@deftypefn {C function} @code{void} mgl_tile_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch)
The function draws horizontal tiles for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. Such plot can be used as 3d generalization of Step(). String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also Surf(), Boxs(), Step(), TileS(). @sref{Tile sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_tile (@code{HMGL} gr, @code{const HMDT} z, @code{const char *}sch)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Dens (Pure C), Cont (Pure C), Tile (Pure C), 2D plotting (Pure C)
@subsection Dens (Pure C)
@cindex Dens

@deftypefn {C function} @code{void} mgl_dens_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch, @code{float} zVal)
The function draws density plot for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z} = @var{zVal}. String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also Surf(), Cont(), ContF(), Dens[XYZ](). @sref{Dens sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_dens (@code{HMGL} gr, @code{const HMDT} z, @code{const char *}sch, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Cont (Pure C), ContF (Pure C), Dens (Pure C), 2D plotting (Pure C)
@subsection Cont (Pure C)
@cindex Cont

@deftypefn {C function} @code{void} mgl_cont_xy_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch, @code{float} zVal)
The function draws contour lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z} = @var{zVal} (or for @var{z=v}[k] if @code{zVal==NAN}). Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v}. String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also Dens(), ContF(), Axial(), Cont[XYZ](). @sref{Cont sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_cont__val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} z, @code{const char *}sch, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {C function} @code{void} mgl_cont_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch, @code{int} num, @code{float} zVal)
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypefn

@deftypefn {C function} @code{void} mgl_cont (@code{HMGL} gr, @code{const HMDT} z, @code{const char *}sch, @code{int} num, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node ContF (Pure C), ContD (Pure C), Cont (Pure C), 2D plotting (Pure C)
@subsection ContF (Pure C)
@cindex ContF

@deftypefn {C function} @code{void} mgl_contf_xy_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch, @code{float} zVal)
The function draws solid (or filled) contour lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z} = @var{zVal} (or for @var{z=v}[k] if @code{zVal==NAN}). Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v} (must be @code{v.nx>2}). String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also Dens(), Cont(), ContD(), Axial(), ContF[XYZ](). @sref{ContF sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_contf_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} z, @code{const char *}sch, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {C function} @code{void} mgl_contf_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch, @code{int} num, @code{float} zVal)
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypefn

@deftypefn {C function} @code{void} mgl_contf (@code{HMGL} gr, @code{const HMDT} z, @code{const char *}sch, @code{int} num, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node ContD (Pure C), Axial (Pure C), ContF (Pure C), 2D plotting (Pure C)
@subsection ContD (Pure C)
@cindex ContD

@deftypefn {C function} @code{void} mgl_contd_xy_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch, @code{float} zVal)
The function draws solid (or filled) contour lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z} = @var{zVal} (or for @var{z=v}[k] if @code{zVal==NAN}) with manual colors. Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v} (must be @code{v.nx>2}). String @var{sch} sets the contour colors: the color of k-th contour is determined by character @code{sch[k%strlen(sch)]}. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also Dens(), Cont(), ContF(). @sref{ContD sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_contd_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} z, @code{const char *}sch, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {C function} @code{void} mgl_contd_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch, @code{int} num, @code{float} zVal)
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypefn

@deftypefn {C function} @code{void} mgl_contd (@code{HMGL} gr, @code{const HMDT} z, @code{const char *}sch, @code{int} num, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Axial (Pure C), Grid (Pure C), ContD (Pure C), 2D plotting (Pure C)
@subsection Axial (Pure C)
@cindex Axial

@deftypefn {C function} @code{void} mgl_axial_xy_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch)
The function draws surface which is result of contour plot rotation for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v}. String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then wire plot is produced. If string contain symbols @samp{x}, @samp{y} or @samp{z} then rotation axis @var{AxialDir} (@pxref{Other settings}) will be set to specified direction. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also Cont(), ContF(), Torus(), Surf3(). @sref{Axial sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_axial_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} z, @code{const char *}sch)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {C function} @code{void} mgl_axial_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch, @code{int} num)
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypefn

@deftypefn {C function} @code{void} mgl_axial (@code{HMGL} gr, @code{const HMDT} z, @code{const char *}sch, @code{int} num)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Grid (Pure C), , Axial (Pure C), 2D plotting (Pure C)
@subsection Grid (Pure C)
@cindex Grid

@deftypefn {C function} @code{void} mgl_grid_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch, @code{float} zVal)
The function draws grid lines for density plot of surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z} = @var{zVal}. String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Grid is plotted for each z slice of the data. See also Dens(), Cont(), ContF().
@end deftypefn

@deftypefn {C function} @code{void} mgl_grid (@code{HMGL} gr, @code{const HMDT} z, @code{const char *}sch, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn


@c ##################################################################
@node 3D plotting (Pure C), Dual plotting (Pure C), 2D plotting (Pure C), C interface
@section 3D plotting (Pure C)

These functions perform plotting of 3D data. 3D means that data depend from 3 independent parameters like matrix @math{f(x_i,y_j,z_k), i=1...n, j=1...m, k=1...l}. There are 4 generally different types of data representations: isosurface or surface of constant value (Surf3), density plot at slices (Dens3), contour lines plot at slices (Cont3), solid contours plot at slices (ContF3) and cloud-like plot (Cloud). Surf3, Cont3 and ContF3 functions have variants for automatic and manual selection of level values for surfaces/contours. Also there are functions for plotting data grid lines according to the data format (Grid3) for enhancing density or contour plots. Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@menu
* Surf3 (Pure C)::              
* Dens3 (Pure C)::              
* Cont3 (Pure C)::              
* ContF3 (Pure C)::             
* Grid3 (Pure C)::              
* Cloud (Pure C)::              
* Beam (Pure C)::               
@end menu

@c ==================================================================
@node Surf3 (Pure C), Dens3 (Pure C), , 3D plotting (Pure C)
@subsection Surf3 (Pure C)
@cindex Surf3

@deftypefn {C function} @code{void} mgl_surf3_xyz_val (@code{HMGL} gr, @code{float} val, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const char *}stl)
The function draws isosurface plot for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) at @var{a}(x,y,z)=@var{val}. String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). Note, that there is possibility of incorrect plotting due to uncertainty of cross-section defining if there are two or more isosurface intersections inside one cell. See also CloudQ(), CloudP(), Dens3(), Surf3C(), Surf3A(), Axial(). @sref{Surf3 sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_surf3_val (@code{HMGL} gr, @code{float} val, @code{const HMDT} a, @code{const char *}sch)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {C function} @code{void} mgl_surf3_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const char *}stl, @code{int} num)
Draws @var{num}-th uniformly distributed in range [@var{Cmin}, @var{Cmax}] isosurfaces for 3d data specified parametrically.
@end deftypefn

@deftypefn {C function} @code{void} mgl_surf3 (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}sch, @code{int} num)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Dens3 (Pure C), Cont3 (Pure C), Surf3 (Pure C), 3D plotting (Pure C)
@subsection Dens3 (Pure C)
@cindex Dens3
@cindex DensA

@deftypefn {C function} @code{void} mgl_dens3_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{char} dir, @code{int} sVal, @code{const char *}stl)
The function draws density plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Density is plotted at slice @var{sVal} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. If string @var{stl} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). See also Cont3(), ContF3(), Dens(), Grid3(). @sref{Dens3 sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_dens3 (@code{HMGL} gr, @code{const HMDT} a, @code{char} dir, @code{int} sVal, @code{const char *}sch)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {C function} @code{void} mgl_dens3_all_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const char *}stl)
Draws density plots at all central slices of the 3d data specified parametrically.
@end deftypefn

@deftypefn {C function} @code{void} mgl_dens3_all (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}sch)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Cont3 (Pure C), ContF3 (Pure C), Dens3 (Pure C), 3D plotting (Pure C)
@subsection Cont3 (Pure C)
@cindex Cont3
@cindex ContA

@deftypefn {C function} @code{void} mgl_cont3_xyz_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{char} dir, @code{int} sVal, @code{const char *}stl)
The function draws contour plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Contours are plotted for values specified in array @var{v} at slice @var{sVal} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. If string @var{stl} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). See also Dens3(), ContF3(), Cont(), Grid3(). @sref{Cont3 sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_cont3_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} a, @code{char} dir, @code{int} sVal, @code{const char *}sch)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {C function} @code{void} mgl_cont3_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{char} dir, @code{int} sVal, @code{const char *}stl, @code{int} num)
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypefn

@deftypefn {C function} @code{void} mgl_cont3 (@code{HMGL} gr, @code{const HMDT} a, @code{char} dir, @code{int} sVal, @code{const char *}sch, @code{int} num)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {C function} @code{void} mgl_cont3_all_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const char *}stl, @code{int} num)
Draws contour plots at all central slices of the 3d data specified parametrically.
@end deftypefn

@deftypefn {C function} @code{void} mgl_cont3_all (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}sch, @code{int} num)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node ContF3 (Pure C), Grid3 (Pure C), Cont3 (Pure C), 3D plotting (Pure C)
@subsection ContF3 (Pure C)
@cindex ContF3
@cindex ContFA

@deftypefn {C function} @code{void} mgl_contf3_xyz_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{char} dir, @code{int} sVal, @code{const char *}stl)
The function draws solid (or filled) contour plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Contours are plotted for values specified in array @var{v} at slice @var{sVal} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. If string @var{stl} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). See also Dens3(), Cont3(), ContF(), Grid3(). @sref{Cont3 sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_contf3_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} a, @code{char} dir, @code{int} sVal, @code{const char *}sch)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {C function} @code{void} mgl_contf3_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{char} dir, @code{int} sVal, @code{const char *}stl, @code{int} num)
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypefn

@deftypefn {C function} @code{void} mgl_contf3 (@code{HMGL} gr, @code{const HMDT} a, @code{char} dir, @code{int} sVal, @code{const char *}sch, @code{int} num)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {C function} @code{void} mgl_contf3_all_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const char *}stl, @code{int} num)
Draws contour plots at all central slices of the 3d data specified parametrically.
@end deftypefn

@deftypefn {C function} @code{void} mgl_contf3_all (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}sch, @code{int} num)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Grid3 (Pure C), Cloud (Pure C), ContF3 (Pure C), 3D plotting (Pure C)
@subsection Grid3 (Pure C)
@cindex Grid3
@cindex GridA

@deftypefn {C function} @code{void} mgl_grid3_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{char} dir, @code{int} sVal, @code{const char *}stl)
The function draws grid for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Density is plotted at slice @var{sVal} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. If string @var{stl} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). See also Cont3(), ContF3(), Dens3(), Grid().
@end deftypefn

@deftypefn {C function} @code{void} mgl_grid3 (@code{HMGL} gr, @code{const HMDT} a, @code{char} dir, @code{int} sVal, @code{const char *}sch)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {C function} @code{void} mgl_grid3_all_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const char *}stl)
Draws grids at all central slices of the 3d data specified parametrically.
@end deftypefn

@deftypefn {C function} @code{void} mgl_grid3_all (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}sch)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Cloud (Pure C), Beam (Pure C), Grid3 (Pure C), 3D plotting (Pure C)
@subsection Cloud (Pure C)
@cindex CloudP
@cindex CloudQ

@deftypefn {C function} @code{void} mgl_cloudq_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const char *}stl, @code{float} alpha=@code{1})
The function draws cloud plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). This plot is a set of cubes with color and transparency proportional to value of @var{a}. The resulting plot is like cloud -- low value is transparent but higher ones are not. The number of plotting cells depend on MeshNum (@pxref{Other settings}). String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. Parameter @var{alpha} changes the overall transparency of plot. The minor dimensions of arrays @var{x}, @var{y}, @var{z} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). See also @ref{Surf3}. @sref{CloudQ sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_cloudq (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}stl, @code{float} alpha=@code{1})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {C function} @code{void} mgl_cloudp_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const char *}stl, @code{float} alpha=@code{1})
The same as first one but the semi-transparent points are used instead of cubes. @sref{CloudP sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_cloudp (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}stl, @code{float} alpha=@code{1})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn


@c ==================================================================
@node Beam (Pure C), , Cloud (Pure C), 3D plotting (Pure C)
@subsection Beam
@cindex Beam

@deftypefn {C function} @code{void} mgl_beam_val (@code{HMGL} gr, @code{float} val, @code{const HMDT} tr, @code{const HMDT} g1, @code{const HMDT} g2, @code{const HMDT} a, @code{float} r, @code{const char *}stl, @code{int} flag)
Draws the isosurface for 3d array @var{a} at constant values of @var{a}=@var{val}. This is special kind of plot for @var{a} specified in accompanied coordinates along curve @var{tr} with orts @var{g1}, @var{g2} and with transverse scale @var{r}. Variable @var{flag} is bitwise: @samp{0x1} - draw in accompanied (not laboratory) coordinates; @samp{0x2} - draw projection to @math{\rho-z} plane; @samp{0x4} - draw normalized in each slice field. The x-size of data arrays @var{tr}, @var{g1}, @var{g2} must be nx>2. The y-size of data arrays @var{tr}, @var{g1}, @var{g2} and z-size of the data array @var{a} must be equal. @xref{Surf3}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_beam (@code{HMGL} gr, @code{const HMDT} tr, @code{const HMDT} g1, @code{const HMDT} g2, @code{const HMDT} a, @code{float} r, @code{const char *}stl, @code{int} flag=@code{0}, @code{int} num=@code{3})
Draws @var{num}-th uniformly distributed in range [@var{Cmin}, @var{Cmax}] isosurfaces for 3d data specified parametrically.
@end deftypefn



@c ##################################################################
@node Dual plotting (Pure C), Vector fields (Pure C), 3D plotting (Pure C), C interface
@section Dual plotting (Pure C)

These plotting functions draw @emph{two matrix} simultaneously. There are 5 generally different types of data representations: surface or isosurface colored by other data (SurfC, Surf3C), surface or isosurface transpared by other data (SurfA, Surf3A), tiles with variable size (TileS), mapping diagram (Map), STFA diagram (STFA). Surf3A and Surf3C have variants for automatic and manual selection of level values for isosurfaces. Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@menu
* SurfC (Pure C)::              
* Surf3C (Pure C)::             
* SurfA (Pure C)::              
* Surf3A (Pure C)::             
* TileS (Pure C)::              
* Map (Pure C)::                
* STFA (Pure C)::               
@end menu

@c ==================================================================
@node SurfC (Pure C), Surf3C (Pure C), , Dual plotting (Pure C)
@subsection SurfC (Pure C)
@cindex SurfC

@deftypefn {C function} @code{void} mgl_surfc_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} c, @code{const char *}sch)
The function draws surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} and color it by matrix @var{c}[i,j]. String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. All dimensions of arrays @var{z} and @var{c} must be equal. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also Surf(), SurfA(), Surf3C(). @sref{SurfC sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_surfc (@code{HMGL} gr, @code{const HMDT} z, @code{const HMDT} c, @code{const char *}sch)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Surf3C (Pure C), SurfA (Pure C), SurfC (Pure C), Dual plotting (Pure C)
@subsection Surf3C (Pure C)
@cindex Surf3C

@deftypefn {C function} @code{void} mgl_surf3c_xyz_val (@code{HMGL} gr, @code{float} val, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const HMDT} c, @code{const char *}stl)
The function draws isosurface plot for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) at @var{a}(x,y,z)=@var{val}. It is mostly the same as Surf3() function but the color of isosurface depends on values of array @var{c}. String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. All dimensions of arrays @var{z} and @var{c} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). Note, that there is possibility of incorrect plotting due to uncertainty of cross-section defining if there are two or more isosurface intersections inside one cell. See also Surf3(), SurfC(), Surf3A(). @sref{Surf3C sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_surf3c_val (@code{HMGL} gr, @code{float} val, @code{const HMDT} a, @code{const HMDT} c, @code{const char *}sch)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {C function} @code{void} mgl_surf3c_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const HMDT} c, @code{const char *}stl, @code{int} num)
Draws @var{num}-th uniformly distributed in range [@var{Cmin}, @var{Cmax}] isosurfaces for 3d data specified parametrically.
@end deftypefn

@deftypefn {C function} @code{void} mgl_surf3c (@code{HMGL} gr, @code{const HMDT} a, @code{const HMDT} c, @code{const char *}sch, @code{int} num)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node SurfA (Pure C), Surf3A (Pure C), Surf3C (Pure C), Dual plotting (Pure C)
@subsection SurfA (Pure C)
@cindex SurfA

@deftypefn {C function} @code{void} mgl_surfa_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} c, @code{const char *}sch)
The function draws surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} and transparent it by matrix @var{c}[i,j]. String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. All dimensions of arrays @var{z} and @var{c} must be equal. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also Surf(), SurfC(), Surf3A(), TileS(). @sref{SurfA sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_surfa (@code{HMGL} gr, @code{const HMDT} z, @code{const HMDT} c, @code{const char *}sch)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn


@c ==================================================================
@node Surf3A (Pure C), TileS (Pure C), SurfA (Pure C), Dual plotting (Pure C)
@subsection Surf3A (Pure C)
@cindex Surf3A

@deftypefn {C function} @code{void} mgl_surf3a_xyz_val (@code{HMGL} gr, @code{float} val, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const HMDT} c, @code{const char *}stl)
The function draws isosurface plot for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) at @var{a}(x,y,z)=@var{val}. It is mostly the same as Surf3() function but the transparency of isosurface depends on values of  @var{b} array. This allows one to remove the part of isosurface where @var{b} is negligibly small (useful for phase plotting of a beam or a pulse). String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. All dimensions of arrays @var{z} and @var{c} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). Note, that there is possibility of incorrect plotting due to uncertainty of cross-section defining if there are two or more isosurface intersections inside one cell. See also @ref{Surf3}, @ref{SurfA}, @ref{Surf3C}. @sref{Surf3A sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_surf3a_val (@code{HMGL} gr, @code{float} val, @code{const HMDT} a, @code{const HMDT} c, @code{const char *}sch)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {C function} @code{void} mgl_surf3a_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const HMDT} c, @code{const char *}stl, @code{int} num)
Draws @var{num}-th uniformly distributed in range [@var{Cmin}, @var{Cmax}] isosurfaces for 3d data specified parametrically.
@end deftypefn

@deftypefn {C function} @code{void} mgl_surf3a (@code{HMGL} gr, @code{const HMDT} a, @code{const HMDT} c, @code{const char *}sch, @code{int} num)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node TileS (Pure C), Map (Pure C), Surf3A (Pure C), Dual plotting (Pure C)
@subsection TileS (Pure C)
@cindex TileS

@deftypefn {C function} @code{void} mgl_tiles_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} r, @code{const char *}sch)
The function draws horizontal tiles for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. It is mostly the same as Tile() but the size of tiles is determined by @var{r} array. This is some kind of ``transparency'' useful for exporting to EPS files. String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @var{x.nx=z.nx && y.nx=z.ny} or  @var{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{SurfA}, @ref{Tile}. @sref{TileS sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_tiles (@code{HMGL} gr, @code{const HMDT} z, @code{const HMDT} c, @code{const char *}sch)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Map (Pure C), STFA (Pure C), TileS (Pure C), Dual plotting (Pure C)
@subsection Map (Pure C)
@cindex Map

@deftypefn {C function} @code{void} mgl_map_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch, @code{int} ks, @code{int} pnts)
The function draws mapping plot for matrices @{@var{ax}, @var{ay} @} which parametrically depend on coordinates @var{x}, @var{y}. The previous position of the cell (point) is marked by color. Height is proportional to Jacobian(ax,ay). This plot is like Arnold diagram ???. If @code{pnts=false} then face is drawn otherwise the color ball at matrix knots are drawn. Parameter @var{ks} specifies the slice of matrices which will be used. String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. The size of @var{ax} and @var{ay} must be the same. The minor dimensions of arrays @var{x}, @var{y}, @var{ax} should be equal. Arrays @var{x}, @var{y} can be vectors (not matrix as @var{ax}). @sref{Map sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_map (@code{HMGL} gr, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch, @code{int} ks, @code{int} pnts)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node STFA (Pure C), , Map (Pure C), Dual plotting (Pure C)
@subsection STFA (Pure C)
@cindex STFA

@deftypefn {C function} @code{void} mgl_stfa_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} re, @code{const HMDT} im, @code{int} dn, @code{const char *}sch, @code{float} zVal)
Draws spectrogram of complex array @var{re}+i*@code{im} for Fourier size of @var{dn} points at plane @var{z=zVal}. Parameter @var{dn} is arbitrary even integer. For example in 1D case, result is density plot of data @math{res[i,j]=|\sum_d^dn exp(I*j*d)*(re[i*dn+d]+I*im[i*dn+d])|/dn} with size @{int(nx/dn), dn, ny@}. At this array @var{re}, @var{im} parametrically depend on coordinates @var{x}, @var{y}. String @var{sch} sets the color scheme. Previous color scheme is used by default. The size of @var{re} and @var{im} must be the same. The minor dimensions of arrays @var{x}, @var{y}, @var{re} should be equal. Arrays @var{x}, @var{y} can be vectors (not matrix as @var{re}). @xref{Color scheme}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_stfa (@code{HMGL} gr, @code{const HMDT} re, @code{const HMDT} im, @code{int} dn, @code{const char *}sch, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn


@c ##################################################################
@node Vector fields (Pure C), Other plotting (Pure C), Dual plotting (Pure C), C interface
@section Vector fields (Pure C)

These functions perform plotting of 2D and 3D vector fields. There are 5 generally different types of vector fields representations: simple vector field (Vect), vector field with coloring (VectC), vector field by dew-drops (Dew), flow threads (Flow), flow pipes (Pipe). Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@menu
* Traj (Pure C)::               
* Vect (Pure C)::               
* VectC (Pure C)::              
* Dew (Pure C)::                
* Flow (Pure C)::               
* Pipe (Pure C)::               
@end menu

@c ==================================================================
@node Traj (Pure C), Vect (Pure C), , Vector fields (Pure C)
@subsection Traj (Pure C)
@cindex Traj

@deftypefn {C function} @code{void} mgl_traj_xyz (@code{HMGL} gr, @code{const HMDT}x, @code{const HMDT}y, @code{const HMDT}z, @code{const HMDT}ax, @code{const HMDT}ay, @code{const HMDT}az, @code{const char *}sch=@code{NULL}, @code{float} len=@code{0})
@deftypefnx {C function} @code{void} mgl_traj_xy (@code{HMGL} gr, @code{const HMDT}x, @code{const HMDT}y, @code{const HMDT}ax, @code{const HMDT}ay, @code{const char *}sch=@code{NULL}, @code{float} zVal=@code{NAN}, @code{float} len=@code{0})
The function draws vectors @{@var{ax}, @var{ay}, @var{az}@} along a curve @{@var{x}, @var{y}, @var{z}@}. The length and color of arrows are proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. The color is specified by the string argument @var{sch}. Previous color scheme is used by default. Parameter @var{len} set the vector length factor (if non-zero) or vector length to be proportional the distance between curve points (if @var{len}=0). The minor sizea of all arrays must be equal and large 2. Vectors are plotted for each column of the arrays. See also @ref{Vect}. @sref{Traj sample}
@end deftypefn

@c ==================================================================
@node Vect (Pure C), VectC (Pure C), Traj (Pure C), Vector fields (Pure C)
@subsection Vect (Pure C)
@cindex Vect

@deftypefn {C function} @code{void} mgl_vect_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch, @code{float} zVal, @code{int} flag)
The function draws plane vector field plot for the field @{@var{ax}, @var{ay}@} depending parametrically on coordinates @var{x}, @var{y} at level @var{z=zVal}. The length of hachures is proportional to @math{\sqrt@{ax^2+ay^2@}}. The number of hachures depend on @var{MeshNum} (@pxref{Other settings}). The color is specified by the string argument @var{sch}. Previous color scheme is used by default. Parameter @var{flag} setup the hachures (arrows). It is compination of vlaues: @code{MGL_VEC_COL} for drawing bi-color arrow, @code{MGL_VEC_LEN} for drawing fixed length arrows, @code{MGL_VEC_DOT} for drawing hachures with dots instead of arrows, @code{MGL_VEC_END} for drawing arrows to the cell point, @code{MGL_VEC_MID} for drawing arrows with center at cell point. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also VectC(), Flow(), Dew(). @sref{Vect sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_vect_2d (@code{HMGL} gr, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch, @code{float} zVal, @code{int} flag)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {C function} @code{void} mgl_vect_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} ax, @code{const HMDT} ay, @code{const HMDT} az, @code{const char *}sch, @code{int} flag)
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the length of hachures is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. @sref{Vect 3D sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_vect_3d (@code{HMGL} gr, @code{const HMDT} ax, @code{const HMDT} ay, @code{const HMDT} az, @code{const char *}sch, @code{int} flag)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node VectC (Pure C), Dew (Pure C), Vect (Pure C), Vector fields (Pure C)
@subsection VectC (Pure C)
@cindex VectC

These functions are obsolete -- use mgl_vect_*() functions instead.

@deftypefn {C function} @code{void} mgl_vectc_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch, @code{float} zVal)
The function draws plane vector field plot for the field @{@var{ax}, @var{ay}@} depending parametrically on coordinates @var{x}, @var{y} at level @var{z=zVal}. The color of hachures is proportional to @math{\sqrt@{ax^2+ay^2@}}. The number of hachures depend on @var{MeshNum} (@pxref{Other settings}). The color is specified by the string argument @var{sch}. Previous color scheme is used by default. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also Vect(), Flow(), Dew(). @sref{VectC sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_vectc_2d (@code{HMGL} gr, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {C function} @code{void} mgl_vectc_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} ax, @code{const HMDT} ay, @code{const HMDT} az, @code{const char *}sch)
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the color of hachures is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. @sref{VectC 3D sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_vectc_3d (@code{HMGL} gr, @code{const HMDT} ax, @code{const HMDT} ay, @code{const HMDT} az, @code{const char *}sch)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Dew (Pure C), Flow (Pure C), VectC (Pure C), Vector fields (Pure C)
@subsection Dew (Pure C)
@cindex Dew

@deftypefn {C function} @code{void} mgl_dew_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch, @code{float} zVal)
The function draws dew-drops for plane vector field @{@var{ax}, @var{ay}@} depending parametrically on coordinates @var{x}, @var{y} at level @var{z=zVal}. Note that this is very expensive plot in memory usage and creation time! The color of drops is proportional to @math{\sqrt@{ax^2+ay^2@}}. The number of drops depend on @var{MeshNum} (@pxref{Other settings}). The color is specified by the string argument @var{sch}. Previous color scheme is used by default. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also Vect(), VectC(). @sref{Dew sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_dew (@code{HMGL} gr, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Flow (Pure C), Pipe (Pure C), Dew (Pure C), Vector fields (Pure C)
@subsection Flow (Pure C)
@cindex Flow

@deftypefn {C function} @code{void} mgl_flow_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch, @code{int} num, @code{int} central, @code{float} zVal)
The function draws flow threads for the plane vector field @{@var{ax}, @var{ay}@} parametrically depending on coordinates @var{x}, @var{y} at level z = @var{zVal}. Number of threads is proportional to @var{num}. Parameter @var{central} sets the thread start from center (if true) or only from edges (if false). The color of lines is proportional to @math{\sqrt@{ax^2+ay^2@}}. Warm color corresponds to normal flow (like attractor). Cold one corresponds to inverse flow (like source). String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also Pipe(), VectC(), Vect(). @sref{Flow sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_flow_2d (@code{HMGL} gr, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch, @code{int} num, @code{int} central, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {C function} @code{void} mgl_flow_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} ax, @code{const HMDT} ay, @code{const HMDT} az, @code{const char *}sch, @code{int} num, @code{int} central)
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the color of line is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. @sref{Flow 3D sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_flow_3d (@code{HMGL} gr, @code{const HMDT} ax, @code{const HMDT} ay, @code{const HMDT} az, @code{const char *}sch, @code{int} num, @code{int} central)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn


@deftypefn {C function} @code{void} mgl_flowp_xy (@code{float} x0, @code{float} y0, @code{float} z0, @code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch)
The function draws flow threads for the plane vector field @{@var{ax}, @var{ay}@} parametrically depending on coordinates @var{x}, @var{y} from point @{@var{x0}, @var{y0}@} at level z = @var{z0}. The color of lines is proportional to @math{\sqrt@{ax^2+ay^2@}}. Warm color corresponds to normal flow (like attractor). Cold one corresponds to inverse flow (like source). String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also Pipe(), VectC(), Vect(). @sref{Flow sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_flowp_2d (@code{float} x0, @code{float} y0, @code{float} z0, @code{HMGL} gr, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch, @code{int} num, @code{int} central, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {C function} @code{void} mgl_flowp_xyz (@code{float} x0, @code{float} y0, @code{float} z0, @code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} ax, @code{const HMDT} ay, @code{const HMDT} az, @code{const char *}sch, @code{int} num, @code{int} central)
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the color of line is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. @sref{Flow 3D sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_flowp_3d (@code{float} x0, @code{float} y0, @code{float} z0, @code{HMGL} gr, @code{const HMDT} ax, @code{const HMDT} ay, @code{const HMDT} az, @code{const char *}sch, @code{int} num, @code{int} central)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn


@c ==================================================================
@node Pipe (Pure C), , Flow (Pure C), Vector fields (Pure C)
@subsection Pipe (Pure C)
@cindex Pipe

@deftypefn {C function} @code{void} mgl_pipe_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch, @code{float} r0, @code{int} num, @code{int} central, @code{float} zVal)
The function draws flow pipes for the plane vector field @{@var{ax}, @var{ay}@} parametrically depending on coordinates @var{x}, @var{y} at level z = @var{zVal}. Number of pipes is proportional to @var{num}. Parameter @var{central} sets the pipe start from center (if true) or only from edges (if false). The color of lines is proportional to @math{\sqrt@{ax^2+ay^2@}}. Warm color corresponds to normal flow (like attractor). Cold one corresponds to inverse flow (like source). String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. Parameter @var{r0} set the base pipe radius. If @var{r0}<0 then pipe radius is inverse proportional to amplitude. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also Pipe(), VectC(), Vect(). @sref{Pipe sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_pipe_2d (@code{HMGL} gr, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch, @code{float} r0, @code{int} num, @code{int} central, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {C function} @code{void} mgl_pipe_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} ax, @code{const HMDT} ay, @code{const HMDT} az, @code{const char *}sch, @code{float} r0, @code{int} num, @code{int} central)
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the color of line is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. @sref{Pipe 3D sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_pipe_3d (@code{HMGL} gr, @code{const HMDT} ax, @code{const HMDT} ay, @code{const HMDT} az, @code{const char *}sch, @code{float} r0, @code{int} num, @code{int} central)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn


@c ##################################################################
@node Other plotting (Pure C), Nonlinear fitting (Pure C), Vector fields (Pure C), C interface
@section Other plotting (Pure C)

These functions perform miscelaneous plotting. There is unstructured data points plots (Dots), surface reconstruction (Crust), surfaces on the triangular mesh (TriPlot), textual formula plotting (Plots by formula), data plots at edges (Dens[XYZ], Cont[XYZ], ContF[XYZ]), simple plot (SimplePlot). Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@menu
* DensXYZ (Pure C)::            
* ContXYZ (Pure C)::            
* ContFXYZ (Pure C)::           
* Dots (Pure C)::               
* Crust (Pure C)::              
* TriPlot (Pure C)::            
* Plots by formula (Pure C)::   
* SimplePlot (Pure C)::         
@end menu

@c ==================================================================
@node DensXYZ (Pure C), ContXYZ (Pure C), , Other plotting (Pure C)
@subsection DensXYZ (Pure C)
@cindex DensX
@cindex DensY
@cindex DensZ

These plotting functions draw density plot in x, y, or z plain. If @var{a} is a tensor (3-dimensional data) then interpolation to a given @var{sVal} is performed. These functions are useful for creating projections of the 3D data array to the bounding box. For example, code like
@example
mgl_dens_x(gr, mgl_data_sum(c,"x"),"BbcyrR",-1);
mgl_dens_y(gr, mgl_data_sum(c.Sum("y"),0,1);
mgl_dens_z(gr, mgl_data_sum(c.Sum("z"),0,-1);
@end example
will produce the following picture. See also Cont[XYZ](), ContF[XYZ](), Dens(). @sref{Dens projection sample}

@deftypefn {C function} @code{void} mgl_dens_x (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal)
Draws density plot for data @var{a} at x = @var{sVal}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_dens_y (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal)
Draws density plot for data @var{a} at y = @var{sVal}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_dens_z (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal)
Draws density plot for data @var{a} at z = @var{sVal}.
@end deftypefn

@c ==================================================================
@node ContXYZ (Pure C), ContFXYZ (Pure C), DensXYZ (Pure C), Other plotting (Pure C)
@subsection ContXYZ (Pure C)
@cindex ContX
@cindex ContY
@cindex ContZ

These plotting functions draw density plot in x, y, or z plain. If @var{a} is a tensor (3-dimensional data) then interpolation to a given @var{sVal} is performed. These functions are useful for creating projections of the 3D data array to the bounding box. For example, code like
@example
mgl_cont_x(gr, mgl_data_sum(c,"x"),"BbcyrR",-1,7);
mgl_cont_y(gr, mgl_data_sum(c.Sum("y"),0,1,7);
mgl_cont_z(gr, mgl_data_sum(c.Sum("z"),0,-1,7);
@end example
will produce the following picture. See also ContF[XYZ](), Dens[XYZ](), Cont(). @sref{Cont projection sample}

@deftypefn {C function} @code{void} mgl_cont_x (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal, @code{int} num)
Draws @var{num}-th contour lines for data @var{a} at x = @var{sVal}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_cont_y (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal, @code{int} num)
Draws @var{num}-th contour lines for data @var{a} at y = @var{sVal}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_cont_z (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal, @code{int} num)
Draws @var{num}-th contour lines for data @var{a} at z = @var{sVal}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_cont_x_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal)
Draws contour lines for data @var{a}=@var{v}[i] at x = @var{sVal}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_cont_y_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal)
Draws contour lines for data @var{a}=@var{v}[i] at y = @var{sVal}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_cont_z_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal)
Draws contour lines for data @var{a}=@var{v}[i] at z = @var{sVal}.
@end deftypefn

@c ==================================================================
@node ContFXYZ (Pure C), Dots (Pure C), ContXYZ (Pure C), Other plotting (Pure C)
@subsection ContFXYZ (Pure C)
@cindex ContFX
@cindex ContFY
@cindex ContFZ

These plotting functions draw density plot in x, y, or z plain. If @var{a} is a tensor (3-dimensional data) then interpolation to a given @var{sVal} is performed. These functions are useful for creating projections of the 3D data array to the bounding box. See also Cont[XYZ](), Dens[XYZ](), ContF().

@deftypefn {C function} @code{void} mgl_contf_x (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal, @code{int} num=@code{7})
Draws @var{num}-th solid contours for data @var{a} at x = @var{sVal}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_contf_y (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal, @code{int} num=@code{7})
Draws @var{num}-th solid contours for data @var{a} at y = @var{sVal}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_contf_z (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal, @code{int} num=@code{7})
Draws @var{num}-th solid contours for data @var{a} at z = @var{sVal}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_contf_x_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal)
Draws solid contours for data @var{a}=@var{v}[i] at x = @var{sVal}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_contf_y_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal)
Draws solid contours for data @var{a}=@var{v}[i] at y = @var{sVal}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_contf_z_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal)
Draws solid contours for data @var{a}=@var{v}[i] at z = @var{sVal}.
@end deftypefn

@c ==================================================================
@node Dots (Pure C), Crust (Pure C), ContFXYZ (Pure C), Other plotting (Pure C)
@subsection Dots (Pure C)
@cindex Dots

@deftypefn {C function} @code{void} mgl_dots (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch)
@deftypefnx {C function} @code{void} mgl_dots_a (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const char *}sch)
The function draws the arbitrary placed points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. If array @var{a} is specified then it define the transparency of dots. Arrays @var{x}, @var{y}, @var{z}, @var{a} must have equal sizes. See also Crust(), Mark(), Plot(). @sref{Dots sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_dots_tr (@code{HMGL} gr, @code{const HMDT} tr, @code{const char *}sch)
The same as previous with @var{x=tr}(0,:), @var{y=tr}(1,:), @var{z=tr}(2,:) and if @var{tr}.nx>3 then @var{a=tr}(3,:).
@end deftypefn

@c ==================================================================
@node Crust (Pure C), TriPlot (Pure C), Dots (Pure C), Other plotting (Pure C)
@subsection Crust (Pure C)
@cindex Crust

@deftypefn {C function} @code{void} mgl_crust (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch, @code{float} er)
The function reconstruct and draws the surface for arbitrary placed points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. Parameter @var{er} set relative radius for (increase it for removing holes). String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. Arrays @var{x}, @var{y}, @var{z} must have equal sizes. See also Dots(), TriPlot(). @sref{Crust sample}
@end deftypefn

@deftypefn {C function} @code{void} mgl_crust_tr (@code{HMGL} gr, @code{const HMDT} tr, @code{const char *}sch, @code{float} er)
The same as previous with @var{x=tr}(0,:), @var{y=tr}(1,:), @var{z=tr}(2,:).
@end deftypefn

@c ==================================================================
@node TriPlot (Pure C), Plots by formula (Pure C), Crust (Pure C), Other plotting (Pure C)
@subsection TriPlot (Pure C)
@cindex TriPlot

@deftypefn {C function} @code{void} mgl_triplot_xyz (@code{HMGL} gr, @code{const HMDT} id, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch)
@deftypefnx {C function} @code{void} mgl_triplot_xyzc (@code{HMGL} gr, @code{const HMDT} id, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} c, @code{const char *}sch)
The function draws the surface of triangles. Triangle vertexes are set by indexes @var{id} of data points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. String @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. First dimensions of @var{id} must be 3 or greater. Arrays @var{x}, @var{y}, @var{z} must have equal sizes. Parameter @var{c} set the colors of triangles (if @var{id}.ny=@var{c}.nx) or colors of vertexes (if @var{x}.nx=@var{c}.nx). See also Dots(), Crust().
@end deftypefn

@deftypefn {C function} @code{void} mgl_triplot_xy (@code{HMGL} gr, @code{const HMDT} id, @code{const HMDT} x, @code{const HMDT} y, @code{const char *}sch, @code{float} zVal)
The same as previous with @var{z}[i]=@var{zVal}.
@end deftypefn

@c ==================================================================
@node Plots by formula (Pure C), SimplePlot (Pure C), TriPlot (Pure C), Other plotting (Pure C)
@subsection Plots by formula (Pure C)
@cindex Plot
@cindex Surf

These functions perform plotting of 1D or 2D functions specified by textual formula. You do not need to create the data arrays to plot it. The parameter @var{stl} set the line style (@pxref{Line styles}) for @code{Plot()} or color scheme (@pxref{Color scheme}) for @code{Surf()}. The parameter @var{n} set the minimal number of points along coordinate(s) for plots. At this time (v. 1.8) there is no adaptive increase of data points numbers but in future it will appear.

@deftypefn {C function} @code{void} mgl_fplot (@code{HMGL} gr, @code{const char *}eqY, @code{const char *}stl, @code{float} zVal, @code{int} n)
The function draws function @samp{eqY(x)} at plane z=@var{zVal} where @samp{x} variable is changed in range [@var{Min}.x, @var{Max}.x]. See also @ref{Plot}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_fplot_xyz (@code{HMGL} gr, @code{const char *}eqX, @code{const char *}eqY, @code{const char *}eqZ, @code{const char *}stl, @code{float} zVal, @code{int} n)
The function draws parametrical curve @{@samp{eqX(t)}, @samp{eqY(t)}, @samp{eqZ(t)}@} where @samp{t} variable is changed in range [0, 1]. See also @ref{Plot}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_fsurf (@code{HMGL} gr, @code{const char *}eqZ, @code{const char *}stl, @code{int} n);
The function draws surface for function @samp{eqY(x,y)} where @samp{x}, @samp{y} variables are changed in range [@var{Min}, @var{Max}]. See also @ref{Surf}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_fsurf_xyz (@code{HMGL} gr, @code{const char *}eqX, @code{const char *}eqY, @code{const char *}eqZ, @code{const char *}stl, @code{int} n)
The function draws parametrical surface @{@samp{eqX(u,v)}, @samp{eqY(u,v)}, @samp{eqZ(u,v)}@} where @samp{u}, @samp{v} variables are changed in range [0, 1]. See also @ref{Surf}.
@end deftypefn

@c ==================================================================
@node SimplePlot (Pure C), , Plots by formula (Pure C), Other plotting (Pure C)
@subsection SimplePlot (Pure C)
@cindex SimplePlot

@deftypefn {C function} @code{void} mgl_simple_plot (@code{HMGL} gr, @code{const HMDT} a, @code{int} type, @code{const char *}stl)
Plots the array @var{a} depending on it's dimensions and @var{type} parameter. String @var{stl} specifies the style of plotting. For 1d data: @code{type=0} -- @ref{Plot}, @code{type=1} -- @ref{Area}, @code{type=2} -- @ref{Step}, @code{type=3} -- @ref{Stem}, @code{type=4} -- @ref{Bars}. For 2d data: @code{type=0} -- @ref{Surf}, @code{type=1} -- @ref{Dens}, @code{type=2} -- @ref{Mesh}, @code{type=3} -- @ref{Cont}. For 3d data: @code{type=0} -- @ref{Surf3}, @code{type=1} -- @ref{Dens3}, @code{type=2} -- @ref{Cont3}, @code{type=2} -- @ref{Cloud}.
@end deftypefn

@c ##################################################################
@node Nonlinear fitting (Pure C), Frames/Animation (Pure C), Other plotting (Pure C), C interface
@section Nonlinear fitting (Pure C)

These functions fit data to formula. Fitting goal is to find formula parameters for the best fit the data points, i.e. to minimize the sum @math{\sum_i (f(x_i, y_i, z_i) - a_i)^2/s_i^2}. At this, approximation function @samp{f} can depend only on one argument @samp{x} (1D case), on two arguments @samp{x,y} (2D case) and on three arguments @samp{x,y,z} (3D case). The function @samp{f} also may depend on parameters. Normally the list of fitted parameters is specified by @var{var} string (like, @samp{abcd}). Usually user should supply initial values for fitted parameters by @var{ini} variable. But if he/she don't supply it then the zeros are used.

Functions Fit() and FitS() do not draw the obtained data themselves. They fill the data @var{fit} by formula @samp{f} with found coefficients and return the @math{\chi^2} error of approximation. At this, the @samp{x,y,z} coordinates are equidistantly distributed in the interval @var{Min}--@var{Max}. Number of points in @var{fit} is selected as maximal value of @var{fit} size and the value of @var{FitPnts}. Note, that this functions use GSL library and do something only if MathGL was compiled with GSL support. @sref{Fitting sample}

@deftypefn {C function} @code{float} mgl_fit_xyzas (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const HMDT} s, @code{const char *}func, @code{const char *}var, @code{float *}ini)
@deftypefnx {C function} @code{float} mgl_fit_xyzas_d (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const HMDT} s, @code{const char *}func, @code{const char *}var, @code{HMDT} ini)
Fit data along x-, y- and z-directions for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]).
@end deftypefn

@deftypefn {C function} @code{float} mgl_fit_xyzs (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} a, @code{const HMDT} s, @code{const char *}func, @code{const char *}var, @code{float *}ini)
@deftypefnx {C function} @code{float} mgl_fit_xyzs_d (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} a, @code{const HMDT} s, @code{const char *}func, @code{const char *}var, @code{HMDT} ini)
Fit data along x-, and y-directions for 2d array specified parametrically @var{a}[i,j](@var{x}[i,j], @var{y}[i,j]) for each data slice.
@end deftypefn

@deftypefn {C function} @code{float} mgl_fit_xys (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} x, @code{const HMDT} a, @code{const HMDT} s, @code{const char *}func, @code{const char *}var, @code{float *}ini)
@deftypefnx {C function} @code{float} mgl_fit_xys_d (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} x, @code{const HMDT} a, @code{const HMDT} s, @code{const char *}func, @code{const char *}var, @code{HMDT} ini)
Fit data along x-direction for 1d array specified parametrically @var{a}[i](@var{x}[i]) for each data slice.
@end deftypefn

@deftypefn {C function} @code{float} mgl_fit_ys (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} a, @code{const HMDT} s, @code{const char *}func, @code{const char *}var, @code{float *}ini)
@deftypefnx {C function} @code{float} mgl_fit_ys_d (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} a, @code{const HMDT} s, @code{const char *}func, @code{const char *}var, @code{HMDT} ini)
Fit data along x-direction for 1d array with @var{x} equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn

@deftypefn {C function} @code{float} mgl_fit_xyza (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const char *}func, @code{const char *}var, @code{float *}ini)
@deftypefnx {C function} @code{float} mgl_fit_xyza_d (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini)
Fit data along x-, y- and z-directions for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) with @var{s}[i,j,k]=1.
@end deftypefn

@deftypefn {C function} @code{float} mgl_fit_xyz (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} a, @code{const char *}func, @code{const char *}var, @code{float *}ini)
@deftypefnx {C function} @code{float} mgl_fit_xyz_d (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini)
Fit data along x-, and y-directions for 2d array specified parametrically @var{a}[i,j](@var{x}[i,j], @var{y}[i,j]) with @var{s}[i,j]=1 for each data slice.
@end deftypefn

@deftypefn {C function} @code{float} mgl_fit_xy (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} x, @code{const HMDT} a, @code{const char *}func, @code{const char *}var, @code{float *}ini)
@deftypefnx {C function} @code{float} mgl_fit_xy_d (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} x, @code{const HMDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini)
Fit data along x-direction for 1d array specified parametrically @var{a}[i](@var{x}[i]) with @var{s}[i]=1 for each data slice.
@end deftypefn

@deftypefn {C function} @code{float} mgl_fit_1 (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} a, @code{const char *}func, @code{const char *}var, @code{float *}ini)
@deftypefnx {C function} @code{float} mgl_fit_1_d (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini)
Fit data along x-direction for 1d array @var{a} with @var{s}=1 and @var{x} equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn

@deftypefn {C function} @code{float} mgl_fit_2 (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} a, @code{const char *}func, @code{const char *}var, @code{float *}ini)
@deftypefnx {C function} @code{float} mgl_fit_2_d (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini)
Fit data along x-, and y-directions for 2d array @var{a} with @var{s}=1 and @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {C function} @code{float} mgl_fit_3 (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} a, @code{const char *}func, @code{const char *}var, @code{float *}ini)
@deftypefnx {C function} @code{float} mgl_fit_3_d (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini)
Fit data along x-, y- and z-directions for 3d array @var{a} with @var{s}=1 and @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {C function} @code{void} mgl_puts_fit (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z, @code{const char *}prefix, @code{const char *}font, @code{float} size=@code{-1})
Print last fitted formula with found coefficients (as numbers) at position @{@var{x}, @var{y}, @var{z}@}. The string @var{prefix} will be printed before formula. All other parameters are the same as in @ref{Text printing (Pure C)}.
@end deftypefn

@c ##################################################################
@node Frames/Animation (Pure C), Data import (Pure C), Nonlinear fitting (Pure C), C interface
@section Frames/Animation (Pure C)
@cindex NewFrame
@cindex EndFrame
@cindex GetNumFrame

These functions provide ability to create several pictures simultaneously. For most of cases it is useless but for widget classes (@pxref{Widget classes}) they can provide a way to show animation. Also you can write several frames into animated GIF file.

@deftypefn {C function} @code{int} mgl_new_frame (@code{HMGL} gr)
Creates new frame. Function returns current frame id. Zero or negative parameter @var{id} leads to automatic numbering frames. Positive one sets the new frame id directly. This is not thread safe function! Use direct list creation in multithreading drawing. The function @code{mgl_end_frame()} @strong{must} be call after the  finishing of the frame drawing for each call of this function.
@end deftypefn

@deftypefn {C function} @code{void} mgl_end_frame (@code{HMGL} gr)
Finishes the frame drawing.
@end deftypefn

@deftypefn {C function} @code{int} mgl_get_num_frame (@code{HMGL} gr)
Gets the number of created frames.
@end deftypefn

@deftypefn {C function} @code{int} mgl_resel_frames (@code{HMGL} gr)
Reset frames counter (start it from zero).
@end deftypefn

@deftypefn {C function} @code{void} mgl_start_gif (@code{HMGL} gr, @code{const char *}fname, @code{int} ms)
Start writing frames into animated GIF file @var{fname}. Parameter @var{ms} set the delay between frames in milliseconds. You @strong{should not} change the picture size during writing the cinema. Use mgl_close_gif() to finalize writing. Note, that this function is disabled in OpenGL mode.
@end deftypefn

@deftypefn {C function} @code{void} mgl_close_gif (@code{HMGL} gr)
Finish writing animated GIF and close connected pointers.
@end deftypefn


@c ##################################################################
@node Data import (Pure C), Data filling (Pure C), Frames/Animation (Pure C), C interface
@section Data import (Pure C)
@cindex Set

@deftypefn {C function} @code{void} mgl_data_create (@code{HMDT} dat, @code{int} mx, @code{int} my, @code{int} mz)
Creates or recreates the array with specified size and fills it by zero. This function does nothing if one of parameters @var{mx}, @var{my}, @var{mz} is zero or negative.
@end deftypefn

@deftypefn {C function} @code{void} mgl_data_set_float (@code{HMDT} dat, @code{const float *}A, @code{int} NX, @code{int} NY, @code{int} NZ)
@deftypefnx {C function} @code{void} mgl_data_set_double (@code{HMDT} dat, @code{const double *}A, @code{int} NX, @code{int} NY, @code{int} NZ)
Allocates memory and copies the data from the @strong{flat} array. 
@end deftypefn

@deftypefn {C function} @code{void} mgl_data_set_float2 (@code{HMDT} dat, @code{const float **}A, @code{int} N1, @code{int} N2)
@deftypefnx {C function} @code{void} mgl_data_set_double2 (@code{HMDT} dat, @code{const double **}A, @code{int} N1, @code{int} N2)
Allocates memory and copies the data from the @code{float**} array with dimensions @var{N1}, @var{N2}, i.e. from array defined like as @code{float a[N1][N2];}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_data_set_float3 (@code{HMDT} dat, @code{const float ***}A, @code{int} N1, @code{int} N2)
@deftypefnx {C function} @code{void} mgl_data_set_double3 (@code{HMDT} dat, @code{const double ***}A, @code{int} N1, @code{int} N2)
Allocates memory and copies the data from the @code{double***} array with dimensions @var{N1}, @var{N2}, @var{N3}, i.e. from array defined like as @code{float a[N1][N2][N3];}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_data_set_vector (@code{HMDT} dat, @code{gsl_vector *}v)
Allocates memory and copies the data from the @code{gsl_vector *} structure.
@end deftypefn
@deftypefn {C function} @code{void} mgl_data_set_matrix (@code{HMDT} dat, @code{gsl_matrix *}m)
Allocates memory and copies the data from the @code{gsl_matrix *} structure.
@end deftypefn

@deftypefn {C function} @code{void} mgl_data_set (@code{HMDT} dat, @code{const HMDT} d)
Copies the data from HMDT instance @var{d}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_data_set_values (@code{const char *}str, @code{int} NX, @code{int} NY, @code{int} NZ)
Allocates memory and scanf the data from the string.
@end deftypefn

@c ------------------------------------------------------------------
@node Data filling (Pure C), Rearrange data (Pure C), Data import (Pure C), C interface
@section Data filling (Pure C)
@cindex Fill
@cindex Modify

@deftypefn {C function} @code{void} mgl_data_fill (@code{HMDT} dat, @code{float} x1, @code{float} x2, @code{char} dir)
Equidistantly fills the data values to range [@var{x1}, @var{x2}] in direction @var{dir}=@{@samp{x},@samp{y},@samp{z}@}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_data_fill (@code{HMGL} gr, @code{HMDT} dat, @code{const char *}eq, @code{const HMDT *}vdat, @code{const HMDT *}wdat)
Fills the value of array according to the formula in string @var{eq}. Formula is an arbitrary expression depending  on variables @samp{x}, @samp{y}, @samp{z}, @samp{u}, @samp{v}, @samp{w}. Coordinates @samp{x}, @samp{y}, @samp{z} are supposed to be normalized in @emph{bounding box} of @var{gr} (in difference from @code{Modify} functions). Variable @samp{u} is the original value of the array. Variables @samp{v} and @samp{w} are values of @var{vdat}, @var{wdat} which can be @code{NULL} (i.e. can be omitted).
@end deftypefn

@deftypefn {C function} @code{void} mgl_data_modify (@code{HMDT} dat, @code{const char *}eq, @code{int} dim)
Function fills the value of array according to the formula in string @var{eq}. Formula is an arbitrary expression depending  on variables @samp{x}, @samp{y}, @samp{z}, @samp{u}. Coordinates @samp{x}, @samp{y}, @samp{z} are data indexes normalized in interval [0,1]. Variable @samp{u} is the original value of the array. Modification will be fulfilled only for slices >=@var{dim}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_data_modify_vw (@code{HMDT} dat, @code{const char *}eq, @code{const HMDT} v, @code{const HMDT} w)
Function fills the value of array according to the formula in string @var{eq}. Formula is an arbitrary expression depending  on variables @samp{x}, @samp{y}, @samp{z}, @samp{u}, @samp{v}, @samp{w}. Coordinates @samp{x}, @samp{y}, @samp{z} are data indexes normalized in interval [0,1]. Variable @samp{u} is the original value of the array. Variables @samp{v} and @samp{w} are values of @var{vdat}, @var{wdat} which can be @code{NULL} (i.e. can be ommited).
@end deftypefn

@deftypefn mglData @code{void} mgl_data_put_val (@code{HMDT} a, @code{float} val, @code{int} i, @code{int} j, @code{int} k)
Function sets value(s) of array a[@var{i}, @var{j}, @var{k}] = @var{val}. Negative indexes @var{i}, @var{j}, @var{k}=-1 set the value @var{val} to whole range in corresponding direction(s). For example, @code{mgl_data_put_val(a,val,-1,0,-1);} sets a[i,0,j]=@var{val} for i=0...(a.nx-1), j=0...(a.nz-1).
@end deftypefn

@deftypefn mglData @code{void} mgl_data_put_dat (@code{HMDT} a, @code{const HMDT} v, @code{int} i, @code{int} j, @code{int} k)
Function copies value(s) from array @var{v} to the range of array @var{a}. Negative indexes @var{i}, @var{j}, @var{k}=-1 set the range in corresponding direction(s). At this minor dimensions of array @var{v} should be large than corresponding dimensions of array @var{a}. For example, @code{mgl_data_put_dat(a,v,-1,0,-1);} sets a[i,0,j]=v.ny>nz ? v[i,j] : v[i], where i=0...(a.nx-1), j=0...(a.nz-1) and condition v.nx>=a.nx is true.
@end deftypefn


@deftypefn {C function} @code{void} mgl_data_set_value (@code{HMDT} dat, @code{float} v, @code{int} i, @code{int} j, @code{int} k)
Sets the value in specified cell of the data with border checking.
@end deftypefn

@deftypefn {C function} @code{float} mgl_data_get_value (@code{HMDT} dat, @code{int} i, @code{int} j, @code{int} k)
Gets the value in specified cell of the data with border checking.
@end deftypefn

@deftypefn {C function} @code{float} mgl_data_get_nx (@code{HMDT} dat)
Gets the x-size of the data.
@end deftypefn

@deftypefn {C function} @code{float} mgl_data_get_ny (@code{HMDT} dat)
Gets the y-size of the data.
@end deftypefn

@deftypefn {C function} @code{float} mgl_data_get_nz (@code{HMDT} dat)
Gets the z-size of the data.
@end deftypefn

@c ------------------------------------------------------------------
@node Rearrange data (Pure C), File I/O (Pure C), Data filling (Pure C), C interface
@section Rearrange data (Pure C)
@cindex Rearrange
@cindex Extend
@cindex Transpose
@cindex Squeeze
@cindex Crop
@cindex Delete
@cindex Insert

@deftypefn {C function} @code{void} mgl_data_rearrange (@code{HMDT} dat, @code{int} mx, @code{int} my, @code{int} mz)
Rearrange dimensions without changing data array so that resulting sizes should  be @var{mx}*@var{my}*@var{mz} < nx*ny*nz. If some of parameter @var{my} or @var{mz} are zero then it will be selected to optimal fill of data array. For example, if @var{my}=0 then it will be change to @var{my}=nx*ny*nz/@var{mx} and @var{mz} will be 1.
@end deftypefn
@deftypefn {C function} @code{void} mgl_data_extend (@code{HMDT} dat, @code{int} n1, @code{int} n2)
Increase the dimensions of the data by inserting new (|@var{n1}|+1)-th slices after (for @var{n1}>0) or before (for @var{n1}<0) of existed one. It is possible to insert 2 dimensions simultaneously for 1d data by using parameter @var{n2}. Data to new slices is copy from existed one. For example, for @var{n1}>0 new array will be 
@iftex
@math{a_{ij}^{new} = a_i^{old}} where j=0...@var{n1}. Correspondingly, for @var{n1}<0 new array will be @math{a_{ij}^{new} = a_j^{old}} where i=0...|@var{n1}|.
@end iftex
@ifnottex
a_ij^new = a_i^old where j=0...@var{n1}. Correspondingly, for @var{n1}<0 new array will be a_ij^new = a_j^old where i=0...|@var{n1}|.
@end ifnottex
@end deftypefn
@deftypefn {C function} @code{void} mgl_data_transpose (@code{const char *}dim)
Transposes (shift order of) dimensions of the data. New order of dimensions is specified int string @var{dim}. This function may be useful also for the reading of one-dimensional data.
@end deftypefn
@deftypefn {C function} @code{void} mgl_data_squeeze (@code{HMDT} dat, @code{int} rx, @code{int} ry, @code{int} rz, @code{int} smooth)
Reduces the data size by excluding data elements which indexes are not divisible by @var{rx}, @var{ry}, @var{rz} correspondingly.
@end deftypefn
@deftypefn {C function} @code{void} mgl_data_crop (@code{HMDT} dat, @code{int} n1, @code{int} n2, @code{char} dir)
Cuts off edges of the data @var{i}<@var{n1} and @var{i}>@var{n2} if @var{n2}>0 or @var{i}>@code{n[xyz]}-@var{n2} if @var{n2}<=0 along direction @var{dir}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_data_insert (@code{HMDT} dat, @code{char} dir, @code{int} pos, @code{char} num)
Insert @var{num} slices along @var{dir}-direction at position @var{pos} and fill it by zeros.
@end deftypefn
@deftypefn {C function} @code{void} mgl_data_delete (@code{HMDT} dat, @code{char} dir, @code{int} pos, @code{char} num)
Delete @var{num} slices along @var{dir}-direction at position @var{pos}.
@end deftypefn

@c ------------------------------------------------------------------
@node File I/O (Pure C), Make another data (Pure C), Rearrange data (Pure C), C interface
@section File I/O (Pure C)
@cindex Read
@cindex ReadMat
@cindex Save
@cindex Export
@cindex Import

@deftypefn {C function} @code{void} mgl_data_read (@code{HMDT} dat, @code{const char *}fname)
Reads data from tab-separated text file with auto determining sizes of the data.
@end deftypefn
@deftypefn {C function} @code{void} mgl_data_read_dim (@code{HMDT} dat, @code{const char *}fname, @code{int} mx, @code{int} my, @code{int} mz)
Reads data from text file with specified data sizes. This function does nothing if one of parameters @var{mx}, @var{my} or @var{mz} is zero or negative.
@end deftypefn
@deftypefn {C function} @code{void} mgl_data_read_mat (@code{HMDT} dat, @code{const char *}fname, @code{int} dim)
Read data from text file with size specified at beginning of the file by first @var{dim} numbers. At this, variable @var{dim} set data dimensions.
@end deftypefn

@deftypefn {C function} @code{void} mgl_data_save (@code{const HMDT} dat, @code{const char *}fname, @code{int} ns)
Saves the whole data array (for @var{ns}=@code{-1}) or only ns-th slice to text file. If @var{ns}>0 then only @var{ns}-th slice (or column for 2D array) will be saved.
@end deftypefn

@deftypefn {C function} @code{void} mgl_data_import (@code{HMDT} dat, @code{const char *}fname, @code{const char *}scheme, @code{float} v1, float v2)
Reads data from bitmap file (now support only PNG format). The RGB values of bitmap pixels are transformed to float values in range [@var{v1}, @var{v2}] using color scheme @var{scheme} (@pxref{Color scheme}).
@end deftypefn
@deftypefn {C function} @code{void} mgl_data_export (@code{HMDT} dat, @code{const char *}fname, @code{const char *}scheme, @code{float} v1, float v2, @code{int} ns) const
Saves data matrix (or @code{ns}-th slice for 3d data) to bitmap file (now support only PNG format). The data values are transformed from range [@var{v1}, @var{v2}] to RGB pixels of bitmap using color scheme @var{scheme} (@pxref{Color scheme}). If @var{v1}>=@var{v2} then the values of @var{v1}, @var{v2} are automatically determined as minimal and maximal value of the data array.
@end deftypefn

@c ------------------------------------------------------------------
@node Make another data (Pure C), Functions on direction (Pure C), File I/O (Pure C), C interface
@section Make another data (Pure C)
@cindex SubData
@cindex Column
@cindex SetColumnId
@cindex Hist
@cindex Momentum
@cindex Sum
@cindex Max
@cindex Min
@cindex Combine
@cindex Evaluate
@cindex Resize

@deftypefn {C function} @code{HMDT} mgl_data_subdata (@code{const HMDT} dat, @code{int} xx, @code{int} yy, @code{int} zz)
Extracts sub-array data from the original data array keeping fixed positive index. For example @code{SubData(-1,2)} extracts 3d row (indexes are zero based), @code{SubData(4,-1)} extracts 5th column, @code{SubData(-1,-1,3)} extracts 4th slice and so on.
@end deftypefn

@deftypefn {C function} @code{HMDT} mgl_data_subdata_ext (@code{const HMDT} dat, @code{const HMDT} xx, @code{const HMDT} yy, @code{const HMDT} zz)
Extracts sub-array data from the original data array for indexes specified by arrays @var{xx}, @var{yy}, @var{zz} (indirect access). The resulting array have the same dimensions as input arrays for 2D and 3D arguments. This function work like previous one for 1D arguments (or numbers). The dimensions of all argument must be the same if they are 2D or 3D arrays.
@end deftypefn

@deftypefn {C function} @code{HMDT} mgl_data_column (@code{const HMDT} dat, @code{const char *}eq)
Get column (or slice) of the data filled by formula @var{eq} of other named columns. For example, @code{Column("n*w^2/exp(t)");}. The column ids must be defined first by @code{SetColumnId()} function.
@end deftypefn
@deftypefn {C function} @code{void} mgl_data_set_id (@code{HMDT} dat, @code{const char *}ids)
Sets the symbol id for data columns. The string must contain one symbol 'a'...'z' per column (without spaces).
@end deftypefn

@deftypefn {C function} @code{HMDT} mgl_data_hist (@code{const HMDT} dat, @code{int} n, @code{float} v1, @code{float} v2, @code{int} nsub)
Creates @var{n}-th points distribution of the data values in range [@var{v1}, @var{v2}]. Parameter @var{nsub} define the number of additional interpolated points (for smoothness of histogram).
@end deftypefn
@deftypefn {C function} @code{HMDT} mgl_data_hist_w (@code{const HMDT} dat, @code{const HMDT} w, @code{int} n, @code{float} v1, @code{float} v2, @code{int} nsub)
Creates @var{n}-th points distribution of the data values in range [@var{v1}, @var{v2}]. Array @var{w} specifies weights of the data elements. Parameter @var{nsub} define the number of additional interpolated points (for smoothness of histogram).
@end deftypefn
@deftypefn {C function} @code{HMDT} mgl_data_momentum (@code{const HMDT} dat, @code{char} dir, @code{const char *}how)
Get momentum (1D-array) of the data along direction @var{dir}. String @var{how} contain kind of momentum. The momentum is defined like as
@iftex
@math{res_k = \sum_{ij} how(x_i,y_j,z_k) a_{ij}/\sum_{ij} a_{ij}}
@end iftex
@ifnottex
res_k = \sum_ij how(x_i,y_j,z_k) a_ij/ \sum_ij a_ij
@end ifnottex
if @var{var}=@samp{z} and so on. Coordinates @samp{x}, @samp{y}, @samp{z} are data indexes normalized in range [0,1].
@end deftypefn

@deftypefn {C function} @code{HMDT} mgl_data_sum (@code{const HMDT} dat, @code{const char *}dir)
Gets array which is the result of summation in given direction or direction(s).
@end deftypefn
@deftypefn {C function} @code{HMDT} mgl_data_max_dir (@code{const HMDT} dat, @code{const char *}dir)
Gets array which is the maximal data values in given direction or direction(s).
@end deftypefn
@deftypefn {C function} @code{HMDT} mgl_data_min_dir (@code{const HMDT} dat, @code{const char *}dir)
Gets array which is the minimal data values in given direction or direction(s).
@end deftypefn

@deftypefn {C function} @code{HMDT} mgl_data_combine (@code{const HMDT} dat, @code{const HMDT} a)
Returns direct multiplication of arrays (like, res[i,j] = this[i]*a[j] and so on).
@end deftypefn

@deftypefn {C function} @code{HMDT} mgl_data_evaluate_i (@code{const HMDT} dat, @code{const HMDT} idat, @code{int} norm)
@deftypefnx {C function} @code{HMDT} mgl_data_evaluate_ij (@code{const HMDT} dat, @code{const HMDT} idat, @code{const HMDT} jdat, @code{int} norm)
@deftypefnx {C function} @code{HMDT} mgl_data_evaluate_ijk (@code{const HMDT} dat, @code{const HMDT} idat, @code{const HMDT} jdat, @code{const HMDT} kdat, @code{int} norm)
Get array which values is result of interpolation of original array for coordinates from other arrays. All dimensions must be the same for data @var{idat}, @var{jdat}, @var{kdat}. Coordinates from @var{idat}, @var{jdat}, @var{kdat} are supposed to be normalized in range [0,1] (if @var{norm}=@code{true}) or in range [0,nx], [0,ny], [0,nz] correspondingly.
@end deftypefn

@deftypefn {C function} @code{HMDT} mgl_data_resize (@code{const HMDT} dat, @code{int} mx, @code{int} my, @code{int} mz)
@deftypefnx {C function} @code{HMDT} mgl_data_resize_box (@code{const HMDT} dat, @code{int} mx, @code{int} my, @code{int} mz, @code{float} x1, @code{float} x2, @code{float} y1, @code{float} y2, @code{float} z1, @code{float} z2)
Resizes the data to new size @var{mx}, @var{my}, @var{mz} from box (part) [@var{x1},@var{x2}] x [@var{y1},@var{y2}] x [@var{z1},@var{z2}] of original array. Initially x,y,z coordinates are supposed to be in [0,1].
@end deftypefn

@c ------------------------------------------------------------------
@node Functions on direction (Pure C), Interpolation (Pure C), Make another data (Pure C), C interface
@section Functions on direction (Pure C)
@cindex CumSum
@cindex Integral
@cindex Diff
@cindex Diff2
@cindex Swap
@cindex Mirror
@cindex Sew
@cindex Smooth
@cindex Envelop
@cindex Norm
@cindex NormSl

These functions change the data in some direction like differentiations, integrations and so on. The direction in which the change will applied is specified by the string parameter, which may contain @samp{x}, @samp{y} or @samp{z} characters for 1-st, 2-nd and 3-d dimension correspondengly.

@deftypefn {C function} @code{void} mgl_data_cumsum (@code{HMDT} dat, @code{const char *}dir)
Cumulative summation of the data in given direction or directions.
@end deftypefn
@deftypefn {C function} @code{void} mgl_data_integral (@code{HMDT} dat, @code{const char *}dir)
Integrates (like cumulative summation) the data in given direction or directions.
@end deftypefn
@deftypefn {C function} @code{void} mgl_data_diff (@code{HMDT} dat, @code{const char *}dir)
Differentiates the data in given direction or directions.
@end deftypefn
@deftypefn {C function} @code{void} mgl_data_diff_par (@code{HMDT} dat, @code{const HMDT} x, @code{const HMDT}y, @code{const HMDT}z)
Differentiates the data specified parametrically in direction @var{x} with @var{y}, @var{z}=constant. Parameter @var{z} can be @code{NULL} that correspond to 2D case. Parametrical differentiation uses the formula (for 2D case): @math{da/dx = (a_j*y_i-a_i*y_j)/(x_j*y_i-x_i*y_j)} where @math{a_i=da/di, a_j=da/dj} denotes usual differentiation along 1st and 2nd dimensions. The similar formula is used for 3D case. Note, that you may change the order of arguments -- for example, if you have 2D data a(i,j) which depend on coordinates @{x(i,j), y(i,j)@} then usual derivative along @samp{x} will be @code{Diff(x,y);} and usual derivative along @samp{y} will be @code{Diff(y,x);}.
@end deftypefn


@deftypefn {C function} @code{void} mgl_data_diff2 (@code{const char *}dir)
Double-differentiates (like Laplace operator) the data in given direction.
@end deftypefn
@deftypefn {C function} @code{void} mgl_data_swap (@code{HMDT} dat, @code{const char *}dir)
Swaps the left and right part of the data in given direction (useful for Fourier spectrum).
@end deftypefn
@deftypefn {C function} @code{void} mgl_data_mirror (@code{HMDT} dat, @code{const char *}dir)
Mirror the left-to-right part of the data in given direction. Looks like change the value index @var{i}->@var{n-i}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_data_sew (@code{HMDT} dat, @code{const char *}dir, @code{float} da)
Remove value steps (like phase jumps after inverse trigonometric functions) with period @var{da} in given direction.
@end deftypefn
@deftypefn {C function} @code{void} mgl_data_smooth (@code{HMDT} dat, @code{int} Type, @code{float} delt, @code{const char *}dira)
Smooths the data on specified direction or directions by method @var{Type}. Now 4 methods are supported: @code{SMOOTH_NONE} does nothing for @var{delta}=0 or approaches data to zero with the step @var{delta}, @code{SMOOTH_LINE_3} linear averaging by 3 points, @code{SMOOTH_LINE_5} linear averaging by 5 points, @code{SMOOTH_QUAD_5} quadratic averaging by 5 points. Parameter @var{delta} forbids to change values of array more than @var{delta} from the original ones. String @var{dirs} specifies the dimensions which will be smoothed. It may contain characters: 'x' for 1st dimension, 'y' for 2nd dimension, 'z' for 3d dimension.
@end deftypefn

@deftypefn {C function} @code{void} mgl_data_envelop (@code{HMDT} dat, @code{char} dir)
Find envelop for data values along direction @var{dir}.
@end deftypefn

@deftypefn {C function} @code{void} mgl_data_norm_slice (@code{HMDT} dat, @code{float} v1, @code{float} v2, @code{char} dir, @code{int} keep_en, @code{int} sym)
Normalizes data slice-by-slice along direction @var{dir} the data in slices to range [@var{v1},@var{v2}]. If flag @var{sym}=@code{true} then symmetrical interval [-max(|v1|,|v2|), max(|v1|,|v2|)] is used. If @var{keep_en} is set then maximal value of k-th slice will be limited by 
@iftex
@math{\sqrt{\sum a_{ij}(k)/\sum a_{ij}(0)}}.
@end iftex
@ifnottex
@math{\sqrt@{\sum a_ij(k)/\sum a_ij(0)@}}.
@end ifnottex
@end deftypefn
@deftypefn {C function} @code{void} mgl_data_norm (@code{HMDT} dat, @code{float} v1=@code{0}, @code{float} v2=@code{1}, @code{int} sym=@code{false}, @code{int} dim=@code{0})
Normalizes the data to range [@var{v1},@var{v2}]. If flag @var{sym}=@code{true} then symmetrical interval [-max(|v1|,|v2|), max(|v1|,|v2|)] is used. Modification will be applied only for slices >=@var{dim}.
@end deftypefn

@c ------------------------------------------------------------------
@node Interpolation (Pure C), Informational functions (Pure C), Functions on direction (Pure C), C interface
@section Interpolation (Pure C)
@cindex Spline
@cindex Spline1
@cindex Linear
@cindex Linear1
@cindex Spline5
@cindex v

@deftypefn {C function} @code{float} mgl_data_spline (@code{const HMDT} dat, @code{float} x, @code{float} y, @code{float} z)
Interpolates data by cubic spline to the given point @var{x} in [0...nx-1], @var{y} in [0...ny-1], @var{z} in [0...nz-1].
@end deftypefn
@deftypefn {C function} @code{float} mgl_data_spline1 (@code{const HMDT} dat, @code{float} x, @code{float} y, @code{float} z)
Interpolates data by cubic spline to the given point @var{x}, @var{y}, @var{z} which assumed to be normalized in range [0, 1].
@end deftypefn
@deftypefn {C function} @code{float} mgl_data_linear (@code{const HMDT} dat, @code{float} x, @code{float} y, @code{float} z)
Interpolates data by linear function to the given point @var{x} in [0...nx-1], @var{y} in [0...ny-1], @var{z} in [0...nz-1].
@end deftypefn
@deftypefn {C function} @code{float} mgl_data_linear11 (@code{const HMDT} dat, @code{float} x, @code{float} y, @code{float} z)
Interpolates data by linear function to the given point @var{x}, @var{y}, @var{z} which assumed to be normalized in range [0, 1].
@end deftypefn
@deftypefn {C function} @code{float} mgl_data_get_value (@code{const HMDT} dat, @code{int} i, @code{int} j, @code{int} k)
Gets the value in specified cell of the data with border checking.
@end deftypefn

@deftypefn {C function} @code{float *} mgl_data_value (@code{HMDT} dat, @code{int} i, @code{int} j, @code{int} k)
Gets the pointer to data element.
@end deftypefn
@deftypefn {C function} @code{const float *} mgl_data_data (@code{const HMDT} dat)
Gets the pointer to internal data array.
@end deftypefn


@c ------------------------------------------------------------------
@node Informational functions (Pure C), Operators (Pure C), Interpolation (Pure C), C interface
@section Informational functions (Pure C)
@cindex Maximal
@cindex Minimal

@deftypefn {C function} @code{float} mgl_data_max (@code{const HMDT} dat)
Gets maximal value of the data.
@end deftypefn
@deftypefn {C function} @code{float} mgl_data_min (@code{HMDT} dat) @code{const}
Gets minimal value of the data.
@end deftypefn

@c ------------------------------------------------------------------
@node Operators (Pure C), Global functions (Pure C), Informational functions (Pure C), C interface
@section Operators (Pure C)

@deftypefn {C function} @code{void} mgl_data_mul_dat (@code{HMDT} dat, @code{const HMDT} d)
Multiplies the data by the other one for each element.
@end deftypefn
@deftypefn {C function} @code{void} mgl_data_div_dat (@code{HMDT} dat, @code{const HMDT} d)
Divides the data by the other one for each element.
@end deftypefn
@deftypefn {C function} @code{void} mgl_data_add_dat (@code{HMDT} dat, @code{const HMDT} d)
Adds the other data.
@end deftypefn
@deftypefn {C function} @code{void} mgl_data_sub_dat (@code{HMDT} dat, @code{const HMDT} d)
Subtracts the other data.
@end deftypefn
@deftypefn {C function} @code{void} mgl_data_mul_num (@code{HMDT} dat, @code{float} d)
Multiplies each element by the number.
@end deftypefn
@deftypefn {C function} @code{void} mgl_data_div_num (@code{HMDT} dat, @code{float} d)
Divides each element by the number.
@end deftypefn
@deftypefn {C function} @code{void} mgl_data_add_num (@code{HMDT} dat, @code{float} d)
Adds the number to each element.
@end deftypefn
@deftypefn {C function} @code{void} mgl_data_sub_num (@code{HMDT} dat, @code{float} d)
Subtracts the number to each element.
@end deftypefn

@c ------------------------------------------------------------------
@node Global functions (Pure C), , Operators (Pure C), C interface
@section Global functions (Pure C)

These functions are not so common. So I put it in this chapter.

@deftypefn {C function} @code{HMDT} mgl_transform (@code{const HMDT} real, @code{const HMDT} imag, @code{const char *}type)
Do integral transformation of complex data @var{real}, @var{imag} on specified direction. Now only Fourier transformation is supported. The order of transformations is specified in string @var{type}: first character for x-dimension, second one for y-dimension, third one for z-dimension. The possible character are: @samp{f} is forward Fourier transformation, @samp{i} is inverse Fourier transformation, @samp{n} or @samp{ } is no transformation.
@end deftypefn

@deftypefn {C function} @code{HMDT} mgl_transform_a @code{const HMDT} ampl, @code{const HMDT} phase, @code{const char *}type)
Do integral transformation of complex data @var{ampl}, @var{phase} on specified direction. Now only Fourier transformation is supported. The order of transformations is specified in string @var{type}: first character for x-dimension, second one for y-dimension, third one for z-dimension. The possible character are: @samp{f} is forward Fourier transformation, @samp{i} is inverse Fourier transformation, @samp{n} or @samp{ } is no transformation.
@end deftypefn

@deftypefn {C function} @code{HMDT} mgl_data_stfa (@code{const HMDT} real, @code{const HMDT} imag, @code{int dn, }@code{char} dir=@code{'x'})
Short time Fourier analysis for real and imaginary parts. Output  is amplitude of partial Fourier of length @var{dn}. For example if @var{dir}=@samp{x}, result will have size @{int(nx/dn), dn, ny@} and it will contain @math{res[i,j,k]=|\sum_d^dn exp(I*j*d)*(real[i*dn+d,k]+I*imag[i*dn+d,k])|/dn}.
@end deftypefn

@deftypefn {C function} @code{HMDT} mgl_pde_solve (@code{const char *}ham, @code{const HMDT} ini_re, @code{const HMDT} ini_im, @code{mglPoint} Min, @code{mglPoint} Max, @code{float} dz=@code{0.1}, @code{float} k0=@code{100})
Solves equation du/dz = i*k0*@var{ham}(p,q,x,y,z,|u|)[u], where p=-i/k0*d/dx, q=-i/k0*d/dy are pseudo-differential operators. Parameters @var{ini_re}, @var{ini_im} specify real and imaginary part of initial field distribution. Parameters @var{Min}, @var{Max} set the bounding box for the solution. Note, that really this ranges are increased by factor 3/2 for purpose of reducing reflection from boundaries. Parameter @var{dz} set the step along evolutionary coordinate z. At this moment, simplified form of function @var{ham} is supported -- all ``mixed'' terms (like @samp{x*p}->x*d/dx) are excluded. For example, in 2D case this function is effectively @math{ham = f(p,z) + g(x,z,u)}. However commutable combinations (like @samp{x*q}->x*d/dy) are allowed. Here variable @samp{u} is used for field amplitude |u|. This allow one solve nonlinear problems -- for example, for nonlinear Shrodinger equation you may set @code{ham="p^2 + q^2 - u^2"}. You may specify imaginary part for wave absorption, like @code{ham = "p^2 + i*x*(x>0)"}, but only if dependence on variable @samp{i} is linear (i.e. @math{ham = hre+i*him}). @sref{PDE sample} 
@end deftypefn

@deftypefn {C function} @code{HMDT} mgl_ray_trace (@code{const char *}ham, @code{mglPoint} r0, @code{mglPoint} p0, @code{float} dt=@code{0.1}, @code{float} tmax=@code{10})
Solves GO ray equation like dr/dt = d @var{ham}/dp, dp/dt = -d @var{ham}/dr. This is Hamiltonian equations for particle trajectory in 3D case. Here @var{ham} is Hamiltonian which may depend on coordinates @samp{x}, @samp{y}, @samp{z}, momentums @samp{p}=px, @samp{q}=py, @samp{v}=pz and time @samp{t}: @math{ham = H(x,y,z,p,q,v,t)}. The starting point (at @code{t=0}) is defined by variables @var{r0}, @var{p0}. Parameters @var{dt} and @var{tmax} specify the integration step and maximal time for ray tracing. Result is array of @{x,y,z,p,q,v,t@} with dimensions @{7 * int(@var{tmax}/@var{dt}+1) @}.
@end deftypefn

@deftypefn {C function} @code{HMDT} mgl_qo2d_solve (@code{const char *}ham, @code{const HMDT} ini_re, @code{const HMDT} ini_im, @code{const HMDT} ray, @code{float} r, @code{float} k0, @code{HMDT} xx, @code{HMDT} yy)
Solves equation du/dt = i*k0*@var{ham}(p,q,x,y,|u|)[u], where p=-i/k0*d/dx, q=-i/k0*d/dy are pseudo-differential operators (see @code{mglPDE()} for details). Parameters @var{ini_re}, @var{ini_im} specify real and imaginary part of initial field distribution. Parameters @var{ray} set the reference ray, i.e. the ray around which the accompanied coordinate system will be maked. You may use, for example, the array created by @code{mglRay()} function. Note, that the reference ray @strong{must be} smooth enough to make accompanied coodrinates unambiguity. Otherwise errors in the solution may appear. If @var{xx} and @var{yy} are non-zero then Cartesian coordinates for each point will be written into them. @sref{Beam tracing sample} 
@end deftypefn

@deftypefn {C function} @code{HMDT} mgl_jacobian_2d (@code{const HMDT} x, @code{const HMDT} y)
@deftypefnx {C function} @code{HMDT} mgl_jacobian_3d (@code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z)
Computates the Jacobian for transformation @{i,j,k@} to @{@var{x},@var{y},@var{z}@} where initial coordinates  @{i,j,k@} are data indexes normalized in range [0,1]. The Jacobian is determined by formula det||@math{dr_\alpha/d\xi_\beta}|| where @math{r}=@{@var{x},@var{y},@var{z}@} and @math{\xi}=@{i,j,k@}. All dimensions must be the same for all data arrays. Data must be 3D if all 3 arrays @{@var{x},@var{y},@var{z}@} are specified or 2D if only 2 arrays @{@var{x},@var{y}@} are specified.
@end deftypefn

