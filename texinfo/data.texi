@c ------------------------------------------------------------------
@node mglData class, Other classes, Widget classes, Top
@chapter mglData class

Class for working with data array. This class is defined in @code{#include <mgl/mgl_data.h>}. The class has functions for easy and safe allocation, resizing, loading and saving, modifying of data arrays. Also it can numerically differentiate and integrate data, interpolate, fill data by formula and so on. Class supports data with dimensions up to 3 (like function of 3 variables - x,y,z). The internal representation of numbers is float. Float type was chosen because it has smaller size in memory and usually it has enough precision in plotting purposes.

@menu
* Public variables::            
* Create and delete::           
* Fill::                        
* Rearrange::                   
* File I/O::                    
* Make another data::           
* Functions on direction::      
* Interpolation::               
* Informational functions::     
* Operators::                   
* Global functions::            
@end menu

@c ------------------------------------------------------------------
@node Public variables, Create and delete, , mglData class
@section Public variables

@deftypecv {Variable} mglData @code{float *} a
Data array itself. The flat data representation is used. For example, matrix [nx x ny] is presented as flat (1d-) array with length nx*ny. The element with indexes @{i, j, k@} is a[i+nx*j+nx*ny*k] (indexes are zero based).
@end deftypecv
@deftypecv {Variable} mglData @code{int} nx
Number of points in 1st dimensions ('x' dimension).
@end deftypecv
@deftypecv {Variable} mglData @code{int} ny
Number of points in 2nd dimensions ('y' dimension).
@end deftypecv
@deftypecv {Variable} mglData @code{int} nz
Number of points in 3d dimensions ('z' dimension).
@end deftypecv
@deftypecv {Variable} mglData @code{char *} id
Column (or slice if nz>1) names -- one character per column.
@end deftypecv


@c ------------------------------------------------------------------
@node Create and delete, Fill, Public variables, mglData class
@section Create and delete
@cindex mglData
@cindex Set

@defop Constructor mglData @code{} mglData (@code{int} mx=@code{1}, @code{int} my=@code{1}, @code{int} mz=@code{1})
Default constructor. Allocates the memory for data array and initializes it by zero.
@end defop
@defop Constructor mglData @code{} mglData (@code{const char *}fname)
Initializes the data by reading from file.
@end defop
@defop Constructor mglData @code{} mglData (@code{const mglData} &dat)
Initiates by other @code{mglData} instance.
@end defop
@deftypemethod mglData @code{void} Create (@code{int} mx, @code{int} my=@code{1}, @code{int} mz=@code{1})
Creates or recreates the array with specified size and fills it by zero. This function does nothing if one of parameters @var{mx}, @var{my}, @var{mz} is zero or negative.
@end deftypemethod

@deftypemethod mglData @code{void} Set (@code{const float *}A, @code{int} NX, @code{int} NY=@code{1}, @code{int} NZ=@code{1})
Allocates memory and copies the data from the @strong{flat} @code{float*} array. 
@end deftypemethod
@deftypemethod mglData @code{void} Set (@code{const double *}A, @code{int} NX, @code{int} NY=@code{1}, @code{int} NZ=@code{1})
Allocates memory and copies the data from the @strong{flat} @code{double*} array.
@end deftypemethod
@deftypemethod mglData @code{void} Set (@code{const float **}A, @code{int} N1, @code{int} N2)
Allocates memory and copies the data from the @code{float**} array with dimensions @var{N1}, @var{N2}, i.e. from array defined as @code{float a[N1][N2];}.
@end deftypemethod
@deftypemethod mglData @code{void} Set (@code{const double **}A, @code{int} N1, @code{int} N2)
Allocates memory and copies the data from the @code{double**} array with dimensions @var{N1}, @var{N2}, i.e. from array defined as @code{double a[N1][N2];}.
@end deftypemethod
@deftypemethod mglData @code{void} Set (@code{const float ***}A, @code{int} N1, @code{int} N2)
Allocates memory and copies the data from the @code{float***} array with dimensions @var{N1}, @var{N2}, @var{N3}, i.e. from array defined as @code{float a[N1][N2][N3];}.
@end deftypemethod
@deftypemethod mglData @code{void} Set (@code{const double ***}A, @code{int} N1, @code{int} N2)
Allocates memory and copies the data from the @code{double***} array with dimensions @var{N1}, @var{N2}, @var{N3}, i.e. from array defined as @code{double a[N1][N2][N3];}.
@end deftypemethod

@deftypemethod mglData @code{void} Set (@code{gsl_vector *}v)
Allocates memory and copies the data from the @code{gsl_vector *} structure.
@end deftypemethod
@deftypemethod mglData @code{void} Set (@code{gsl_matrix *}m)
Allocates memory and copies the data from the @code{gsl_matrix *} structure.
@end deftypemethod
@deftypemethod mglData @code{inline void} Set (@code{const mglData &}dat)
Copies the data from mglData instance @var{dat}.
@end deftypemethod

@deftypemethod mglData @code{void} Set (@code{const std::vector<int> &}d)
@deftypemethodx mglData @code{void} Set (@code{const std::vector<float> &}d)
@deftypemethodx mglData @code{void} Set (@code{const std::vector<double> &}d)
Allocates memory and copies the data from the @code{std::vector<T>} array.
@end deftypemethod


@deftypemethod mglData @code{void} Set (@code{const char *}str, @code{int} NX, @code{int} NY=@code{1}, @code{int} NZ=@code{1})
Allocates memory and scanf the data from the string.
@end deftypemethod

@c ------------------------------------------------------------------
@node Fill, Rearrange, Create and delete, mglData class
@section Fill
@cindex Fill
@cindex Modify

@deftypemethod mglData @code{void} Fill (@code{float} x1, @code{float} x2, @code{char} dir=@code{'x'})
Equidistantly fills the data values to range [@var{x1}, @var{x2}] in direction @var{dir}=@{@samp{x},@samp{y},@samp{z}@}.
@end deftypemethod

@deftypemethod mglData @code{void} Fill (@code{const char *}eq, @code{mglPoint} Min, @code{mglPoint} Max, @code{const mglData *}vdat=0, @code{const mglData *}wdat=0)
Fills the value of array according to the formula in string @var{eq}. Formula is an arbitrary expression depending  on variables @samp{x}, @samp{y}, @samp{z}, @samp{u}, @samp{v}, @samp{w}. Coordinates @samp{x}, @samp{y}, @samp{z} are supposed to be normalized in range @var{Min} x @var{Max} (in difference from @code{Modify} functions). Variable @samp{u} is the original value of the array. Variables @samp{v} and @samp{w} are values of @var{vdat}, @var{wdat} which can be @code{NULL} (i.e. can be omitted).
@end deftypemethod

@deftypemethod mglData @code{void} Modify (@code{const char *}eq, @code{int} dim=@code{0})
Function fills the value of array according to the formula in string @var{eq}. Formula is an arbitrary expression depending  on variables @samp{x}, @samp{y}, @samp{z}, @samp{u}. Coordinates @samp{x}, @samp{y}, @samp{z} are data indexes normalized in range [0,1]. Variable @samp{u} is the original value of the array. Modification will be fulfilled only for slices >=@var{dim}.
@end deftypemethod

@deftypemethod mglData @code{void} Modify (@code{const char *}eq, @code{const mglData &}v)
@deftypemethodx mglData @code{void} Modify (@code{const char *}eq, @code{const mglData &}v, @code{const mglData &}w)
Function fills the value of array according to the formula in string @var{eq}. Formula is an arbitrary expression depending  on variables @samp{x}, @samp{y}, @samp{z}, @samp{u}, @samp{v}, @samp{w}. Coordinates @samp{x}, @samp{y}, @samp{z} are data indexes normalized in range [0,1]. Variable @samp{u} is the original value of the array. Variables @samp{v} and @samp{w} are values of @var{vdat}, @var{wdat}.
@end deftypemethod

@deftypemethod mglData @code{void} Put (@code{float} val, @code{int} i=@code{-1}, @code{int} j=@code{-1}, @code{int} k=@code{-1})
Function sets value(s) of array a[@var{i}, @var{j}, @var{k}] = @var{val}. Negative indexes @var{i}, @var{j}, @var{k}=-1 set the value @var{val} to whole range in corresponding direction(s). For example, @code{Put(val,-1,0,-1);} sets a[i,0,j]=@var{val} for i=0...(nx-1), j=0...(nz-1).
@end deftypemethod

@deftypemethod mglData @code{void} Put (@code{const mglData &}v, @code{int} i=@code{-1}, @code{int} j=@code{-1}, @code{int} k=@code{-1})
Function copies value(s) from array @var{v} to the range of original array. Negative indexes @var{i}, @var{j}, @var{k}=-1 set the range in corresponding direction(s). At this minor dimensions of array @var{v} should be large than corresponding dimensions of this array. For example, @code{Put(v,-1,0,-1);} sets a[i,0,j]=v.ny>nz ? v[i,j] : v[i], where i=0...(nx-1), j=0...(nz-1) and condition v.nx>=nx is true.
@end deftypemethod

@c ------------------------------------------------------------------
@node Rearrange, File I/O, Fill, mglData class
@section Rearrange
@cindex Rearrange
@cindex Extend
@cindex Transpose
@cindex Squeeze
@cindex Crop
@cindex InsertRows
@cindex InsertColumns
@cindex InsertSlices
@cindex DeleteRows
@cindex DeleteColumns
@cindex DeleteSlices
@cindex Insert
@cindex Delete

@deftypemethod mglData @code{void} Rearrange (@code{int} mx, @code{int} my=@code{0}, @code{int} mz=@code{0})
Rearrange dimensions without changing data array so that resulting sizes should  be @var{mx}*@var{my}*@var{mz} < nx*ny*nz. If some of parameter @var{my} or @var{mz} are zero then it will be selected to optimal fill of data array. For example, if @var{my}=0 then it will be change to @var{my}=nx*ny*nz/@var{mx} and @var{mz} will be 1.
@end deftypemethod
@deftypemethod mglData @code{void} Extend (@code{int} n1, @code{int} n2=@code{0})
Increase the dimensions of the data by inserting new (|@var{n1}|+1)-th slices after (for @var{n1}>0) or before (for @var{n1}<0) of existed one. It is possible to insert 2 dimensions simultaneously for 1d data by using parameter @var{n2}. Data to new slices is copy from existed one. For example, for @var{n1}>0 new array will be 
@iftex
@math{a_{ij}^{new} = a_i^{old}} where j=0...@var{n1}. Correspondingly, for @var{n1}<0 new array will be @math{a_{ij}^{new} = a_j^{old}} where i=0...|@var{n1}|.
@end iftex
@ifnottex
a_ij^new = a_i^old where j=0...@var{n1}. Correspondingly, for @var{n1}<0 new array will be a_ij^new = a_j^old where i=0...|@var{n1}|.
@end ifnottex
@end deftypemethod
@deftypemethod mglData @code{void} Transpose (@code{const char *}dim=@code{"yx"})
Transposes (shift order of) dimensions of the data. New order of dimensions is specified int string @var{dim}. This function may be useful also for the reading of one-dimensional data.
@end deftypemethod
@deftypemethod mglData @code{void} Squeeze (@code{int} rx, @code{int} ry=@code{1}, @code{int} rz=@code{1}, @code{bool} smooth=@code{true})
Reduces the data size by excluding data elements which indexes are not divisible by @var{rx}, @var{ry}, @var{rz} correspondingly.
@end deftypemethod
@deftypemethod mglData @code{void} Crop (@code{int} n1, @code{int} n2, @code{char} dir=@code{'x'})
		Cuts off edges of the data @var{i}<@var{n1} and @var{i}>@var{n2} if @var{n2}>0 or @var{i}>@code{n[xyz]}-@var{n2} if @var{n2}<=0 along direction @var{dir}.
@end deftypemethod

@deftypemethod mglData @code{void} InsertRows (@code{int} at, @code{int} num=@code{1}, @code{const char *}eq=@code{NULL})
Insert @var{num} rows (slice along y-direction) at position @var{at} and fill it by formula @var{eq} (if @var{eq}!=0) or by zeros.
@end deftypemethod
@deftypemethod mglData @code{void} InsertColumns (@code{int} at, @code{int} num=@code{1}, @code{const char *}eq=@code{NULL})
Insert @var{num} columns (slice along x-direction) at position @var{at} and fill it by formula @var{eq} (if @var{eq}!=0) or by zeros.
@end deftypemethod
@deftypemethod mglData @code{void} InsertSlices (@code{int} at, @code{int} num=@code{1}, @code{const char *}eq=@code{NULL})
Insert @var{num} slices (slice along z-direction) at position @var{at} and fill it by formula @var{eq} (if @var{eq}!=0) or by zeros.
@end deftypemethod

@deftypemethod mglData @code{void} DeleteRows (@code{int} at, @code{int} num=@code{1})
Delete @var{num} rows (slice along y-direction) at position @var{at}.
@end deftypemethod
@deftypemethod mglData @code{void} DeleteColumns (@code{int} at, @code{int} num=@code{1})
Delete @var{num} columns (slice along x-direction) at position @var{at}.
@end deftypemethod
@deftypemethod mglData @code{void} DeleteSlices (@code{int} at, @code{int} num=@code{1})
Delete @var{num} slices (slice along z-direction) at position @var{at}.
@end deftypemethod

@deftypemethod mglData @code{void} Insert (@code{char} dir, @code{int} pos=@code{0}, @code{int} num=@code{1})
Insert @var{num} slices along @var{dir}-direction at position @var{pos} and fill it by zeros.
@end deftypemethod
@deftypemethod mglData @code{void} Delete (@code{char} dir, @code{int} pos=@code{0}, @code{int} num=@code{1})
Delete @var{num} slices along @var{dir}-direction at position @var{pos}.
@end deftypemethod

@c ------------------------------------------------------------------
@node File I/O, Make another data, Rearrange, mglData class
@section File I/O
@cindex Read
@cindex ReadMat
@cindex ReadAll
@cindex ReadRange
@cindex ReadHDF
@cindex Save
@cindex SaveHDF
@cindex Export
@cindex Import

@deftypemethod mglData @code{void} Read (@code{const char *}fname)
Reads data from tab-separated text file with auto determining sizes of the data.
@end deftypemethod
@deftypemethod mglData @code{void} Read (@code{const char *}fname, @code{int} mx, @code{int} my=@code{1}, @code{int} mz=@code{1})
Reads data from text file with specified data sizes. This function does nothing if one of parameters @var{mx}, @var{my} or @var{mz} is zero or negative.
@end deftypemethod
@deftypemethod mglData @code{void} ReadMat (@code{const char *}fname, @code{int} dim=@code{2})
Read data from text file with size specified at beginning of the file by first @var{dim} numbers. At this, variable @var{dim} set data dimensions.
@end deftypemethod

@deftypemethod mglData @code{void} ReadRange (@code{const char *}templ, @code{float} from, @code{float} to, @code{float} step=@code{1.f}, @code{bool} as_slice=@code{false})
Join data arrays from several text files. The file names are determined by function call @code{sprintf(fname,templ,val);}, where @var{val} changes from @var{from} to @var{to} with step @var{step}. The data load one-by-one in the same slice if @var{as_slice}=@code{false} or as slice-by-slice if @var{as_slice}=@code{true}.
@end deftypemethod
@deftypemethod mglData @code{void} ReadAll (@code{const char *}templ, @code{bool} as_slice=@code{false})
Join data arrays from several text files which filenames satisfied the template @var{templ} (for example, @var{templ}=@code{"t_*.dat"}). The data load one-by-one in the same slice if @var{as_slice}=@code{false} or as slice-by-slice if @var{as_slice}=@code{true}.
@end deftypemethod

@deftypemethod mglData @code{void} Save (@code{const char *}fname, @code{int} ns=@code{-1}) @code{const}
Saves the whole data array (for @var{ns}=@code{-1}) or only ns-th slice to text file. If @var{ns}>0 then only @var{ns}-th slice (or column for 2D array) will be saved.
@end deftypemethod

@deftypemethod mglData @code{void} ReadHDF (@code{const char *}fname, @code{const char *}dname)
Reads data array named @var{dname} from HDF file. This function does nothing if NO_HDF5 was defined during library compilation.
@end deftypemethod
@deftypemethod mglData @code{void} SaveHDF (@code{const char *}fname, @code{const char *}dname, @code{bool} rewrite=@code{false}) @code{const}
Saves data array named @var{dname} from HDF file. This function does nothing if NO_HDF5 was defined during library compilation.
@end deftypemethod

@deftypemethod mglData @code{void} Import (@code{const char *}fname, @code{const char *}scheme, @code{float} v1=@code{0}, float v2=@code{1})
Reads data from bitmap file (now support only PNG format). The RGB values of bitmap pixels are transformed to float values in range [@var{v1}, @var{v2}] using color scheme @var{scheme} (@pxref{Color scheme}).
@end deftypemethod
@deftypemethod mglData @code{void} Export (@code{const char *}fname, @code{const char *}scheme, @code{float} v1=@code{0}, float v2=@code{0}, @code{int} ns=@code{-1}) const
Saves data matrix (or @code{ns}-th slice for 3d data) to bitmap file (now support only PNG format). The data values are transformed from range [@var{v1}, @var{v2}] to RGB pixels of bitmap using color scheme @var{scheme} (@pxref{Color scheme}). If @var{v1}>=@var{v2} then the values of @var{v1}, @var{v2} are automatically determined as minimal and maximal value of the data array.
@end deftypemethod

@c ------------------------------------------------------------------
@node Make another data, Functions on direction, File I/O, mglData class
@section Make another data
@cindex SubData
@cindex Column
@cindex SetColumnId
@cindex Hist
@cindex Momentum
@cindex Sum
@cindex Max
@cindex Min
@cindex Combine
@cindex Evaluate
@cindex Resize
@cindex Trace

@deftypemethod mglData @code{mglData} SubData (@code{int} xx, @code{int} yy=@code{-1}, @code{int} zz=@code{-1}) @code{const}
Extracts sub-array data from the original data array keeping fixed positive index. For example @code{SubData(-1,2)} extracts 3d row (indexes are zero based), @code{SubData(4,-1)} extracts 5th column, @code{SubData(-1,-1,3)} extracts 4th slice and so on. The most convenient way is to use this function as initialization of other @code{mglData} variable like @code{mglData a1(a.SubData(-1,-1,3))}.
@end deftypemethod

@deftypemethod mglData @code{mglData} SubData (@code{const mglData &}xx, @code{const mglData &}yy, @code{const mglData &}zz) @code{const}
Extracts sub-array data from the original data array for indexes specified by arrays @var{xx}, @var{yy}, @var{zz} (indirect access). The resulting array have the same dimensions as input arrays for 2D and 3D arguments. This function work like previous one for 1D arguments (or numbers). The dimensions of all argument must be the same if they are 2D or 3D arrays.
@end deftypemethod

@deftypemethod mglData @code{mglData} Column (@code{const char *}eq) @code{const}
Get column (or slice) of the data filled by formula @var{eq} of other named columns. For example, @code{Column("n*w^2/exp(t)");}. The column ids must be defined first by @code{SetColumnId()} function.
@end deftypemethod
@deftypemethod mglData @code{void} SetColumnId (@code{const char *}ids)
Set the symbol id for data columns. The string must contain one symbol 'a'...'z' per column (without spaces).
@end deftypemethod

@deftypemethod mglData @code{mglData} Trace () @code{const}
Gets array of diagonal elements a[i,i] (for 2D case) or a[i,i,i] (for 3D case) where i=0...nx-1. Function return copy of itself for 1D case. Data array must have dimensions ny,nz >= nx or ny,nz = 1.
@end deftypemethod

@deftypemethod mglData @code{mglData} Hist (@code{int} n, @code{float} v1=@code{0}, @code{float} v2=@code{1}, @code{int} nsub=@code{0}) @code{const}
Creates @var{n}-th points distribution of the data values in range [@var{v1}, @var{v2}]. Parameter @var{nsub} define the number of additional interpolated points (for smoothness of histogram).
@end deftypemethod
@deftypemethod mglData @code{mglData} Hist (@code{const mglData &}w, @code{int} n, @code{float} v1=@code{0}, @code{float} v2=@code{1}, @code{int} nsub=@code{0}) @code{const}
Creates @var{n}-th points distribution of the data values in range [@var{v1}, @var{v2}]. Array @var{w} specifies weights of the data elements. Parameter @var{nsub} define the number of additional interpolated points (for smoothness of histogram).
@end deftypemethod
@deftypemethod mglData @code{mglData} Momentum (@code{char} dir, @code{const char *}how) @code{const}
Get momentum (1D-array) of the data along direction @var{dir}. String @var{how} contain kind of momentum. The momentum is defined like as
@iftex
@math{res_k = \sum_{ij} how(x_i,y_j,z_k) a_{ij}/\sum_{ij} a_{ij}}
@end iftex
@ifnottex
res_k = \sum_ij how(x_i,y_j,z_k) a_ij/ \sum_ij a_ij
@end ifnottex
if @var{var}=@samp{z} and so on. Coordinates @samp{x}, @samp{y}, @samp{z} are data indexes normalized in range [0,1].
@end deftypemethod

@deftypemethod mglData @code{mglData} Sum (@code{const char *}dir) @code{const}
Gets array which is the result of summation in given direction or direction(s).
@end deftypemethod
@deftypemethod mglData @code{mglData} Max (@code{const char *}dir) @code{const}
Gets array which is the maximal data values in given direction or direction(s).
@end deftypemethod
@deftypemethod mglData @code{mglData} Min (@code{const char *}dir) @code{const}
Gets array which is the maximal data values in given direction or direction(s).
@end deftypemethod

@deftypemethod mglData @code{mglData} Combine (@code{const mglData &}a) @code{const}
Return direct multiplication of arrays (like, res[i,j] = this[i]*a[j] and so on).
@end deftypemethod
@deftypemethod mglData @code{mglData} Evaluate (@code{const mglData &}idat, @code{bool} norm=@code{true}) @code{const}
@deftypemethodx mglData @code{mglData} Evaluate (@code{const mglData &}idat, @code{const mglData &}jdat, @code{bool} norm=@code{true}) @code{const}
@deftypemethodx mglData @code{mglData} Evaluate (@code{const mglData &}idat, @code{const mglData &}jdat, @code{const mglData &}kdat, @code{bool} norm=@code{true}) @code{const}
Get array which values is result of interpolation of original array for coordinates from other arrays. All dimensions must be the same for data @var{idat}, @var{jdat}, @var{kdat}. Coordinates from @var{idat}, @var{jdat}, @var{kdat} are supposed to be normalized in range [0,1] (if @var{norm}=@code{true}) or in range [0,nx], [0,ny], [0,nz] correspondingly.
@end deftypemethod
@deftypemethod mglData @code{mglData} Resize (@code{int} mx, @code{int} my=@code{1}, @code{int} mz=@code{1}, @code{float} x1=@code{0}, @code{float} x2=@code{1}, @code{float} y1=@code{0}, @code{float} y2=@code{1}, @code{float} z1=@code{0}, @code{float} z2=@code{1}) @code{const}
Resizes the data to new size @var{mx}, @var{my}, @var{mz} from box (part) [@var{x1},@var{x2}] x [@var{y1},@var{y2}] x [@var{z1},@var{z2}] of original array. Initially x,y,z coordinates are supposed to be in [0,1].
@end deftypemethod

@c ------------------------------------------------------------------
@node Functions on direction, Interpolation, Make another data, mglData class
@section Functions on direction
@cindex CumSum
@cindex Integral
@cindex Diff
@cindex Diff2
@cindex Swap
@cindex Mirror
@cindex Sew
@cindex Smooth
@cindex Envelop
@cindex Norm
@cindex NormSl

These functions change the data in some direction like differentiations, integrations and so on. The direction in which the change will applied is specified by the string parameter, which may contain @samp{x}, @samp{y} or @samp{z} characters for 1-st, 2-nd and 3-d dimension correspondengly.

@deftypemethod mglData @code{void} CumSum (@code{const char *}dir)
Cumulative summation of the data in given direction or directions.
@end deftypemethod
@deftypemethod mglData @code{void} Integral (@code{const char *}dir)
Integrates (like cumulative summation) the data in given direction or directions.
@end deftypemethod
@deftypemethod mglData @code{void} Diff (@code{const char *}dir)
Differentiates the data in given direction or directions.
@end deftypemethod

@deftypemethod mglData @code{void} Diff (@code{const mglData &}x, @code{const mglData &}y)
@deftypemethodx mglData @code{void} Diff (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z)
Differentiates the data specified parametrically in direction @var{x} with @var{y}, @var{z}=constant. Parametrical differentiation uses the formula (for 2D case): @math{da/dx = (a_j*y_i-a_i*y_j)/(x_j*y_i-x_i*y_j)} where @math{a_i=da/di, a_j=da/dj} denotes usual differentiation along 1st and 2nd dimensions. The similar formula is used for 3D case. Note, that you may change the order of arguments -- for example, if you have 2D data a(i,j) which depend on coordinates @{x(i,j), y(i,j)@} then usual derivative along @samp{x} will be @code{Diff(x,y);} and usual derivative along @samp{y} will be @code{Diff(y,x);}.
@end deftypemethod


@deftypemethod mglData @code{void} Diff2 (@code{const char *}dir)
Double-differentiates (like Laplace operator) the data in given direction.
@end deftypemethod
@deftypemethod mglData @code{void} Swap (@code{const char *}dir)
Swaps the left and right part of the data in given direction (useful for Fourier spectrum).
@end deftypemethod
@deftypemethod mglData @code{void} Mirror (@code{const char *}dir)
Mirror the left-to-right part of the data in given direction. Looks like change the value index @var{i}->@var{n-i}.
@end deftypemethod
@deftypemethod mglData @code{void} Sew (@code{const char *}dir, @code{float} da=@code{2*M_PI})
Remove value steps (like phase jumps after inverse trigonometric functions) with period @var{da} in given direction.
@end deftypemethod
@deftypemethod mglData @code{void} Smooth (@code{int} Type, @code{const char *}dir, @code{float} delta=@code{0})
Smooths the data on specified direction or directions by method @var{Type}. Now 4 methods are supported: @code{SMOOTH_NONE} does nothing for @var{delta}=0 or approaches data to zero with the step @var{delta}, @code{SMOOTH_LINE_3} linear averaging by 3 points, @code{SMOOTH_LINE_5} linear averaging by 5 points, @code{SMOOTH_QUAD_5} quadratic averaging by 5 points. Parameter @var{delta} forbids to change values of array more than @var{delta} from the original ones. String @var{dirs} specifies the dimensions which will be smoothed. It may contain characters: 'x' for 1st dimension, 'y' for 2nd dimension, 'z' for 3d dimension.
@end deftypemethod
@deftypemethod mglData @code{void} Smooth (@code{const char *}dir)
Smooths the data on specified direction(s). This is the same as @code{Smooth()} but argument @var{Type} is specified in string as @samp{0} for @code{SMOOTH_NONE}, @samp{3} for @code{SMOOTH_LINE_3}, @samp{5} for @code{SMOOTH_LINE_5}. If string @var{dir} don't contain digits @samp{035} then @var{Type}=@code{SMOOTH_QUAD_5} is used.
@end deftypemethod
@deftypemethod mglData @code{void} Envelop (@code{char} dir=@code{'x'})
Find envelop for data values along direction @var{dir}.
@end deftypemethod

@deftypemethod mglData @code{void} NormSl (@code{float} v1=@code{0}, @code{float} v2=@code{1}, @code{char} dir=@code{'z'}, @code{bool} keep_en=@code{true}, @code{bool} sym=@code{false})
Normalizes data slice-by-slice along direction @var{dir} the data in slices to range [@var{v1},@var{v2}]. If flag @var{sym}=@code{true} then symmetrical interval [-max(|v1|,|v2|), max(|v1|,|v2|)] is used. If @var{keep_en} is set then maximal value of k-th slice will be limited by 
@iftex
@math{\sqrt{\sum a_{ij}(k)/\sum a_{ij}(0)}}.
@end iftex
@ifnottex
@math{\sqrt@{\sum a_ij(k)/\sum a_ij(0)@}}.
@end ifnottex
@end deftypemethod
@deftypemethod mglData @code{void} Norm (@code{float} v1=@code{0}, @code{float} v2=@code{1}, @code{bool} sym=@code{false}, @code{int} dim=@code{0})
Normalizes the data to range [@var{v1},@var{v2}]. If flag @var{sym}=@code{true} then symmetrical interval [-max(|v1|,|v2|), max(|v1|,|v2|)] is used. Modification will be applied only for slices >=@var{dim}.
@end deftypemethod

@c ------------------------------------------------------------------
@node Interpolation, Informational functions, Functions on direction, mglData class
@section Interpolation
@cindex Spline
@cindex Spline1
@cindex Linear
@cindex Linear1
@cindex Spline5
@cindex v

@deftypemethod mglData @code{float} Spline (@code{float} x, @code{float} y=@code{0}, @code{float} z=@code{0}) @code{const}
Interpolates data by cubic spline to the given point @var{x} in [0...nx-1], @var{y} in [0...ny-1], @var{z} in [0...nz-1].
@end deftypemethod
@deftypemethod mglData @code{float} Spline1 (@code{float} x, @code{float} y=@code{0}, @code{float} z=@code{0}) @code{const}
Interpolates data by cubic spline to the given point @var{x}, @var{y}, @var{z} which assumed to be normalized in range [0, 1].
@end deftypemethod
@deftypemethod mglData @code{float} Linear (@code{float} x, @code{float} y=@code{0}, @code{float} z=@code{0}) @code{const}
Interpolates data by linear function to the given point @var{x} in [0...nx-1], @var{y} in [0...ny-1], @var{z} in [0...nz-1].
@end deftypemethod
@deftypemethod mglData @code{float} Linear1 (@code{float} x, @code{float} y=@code{0}, @code{float} z=@code{0}) @code{const}
Interpolates data by linear function to the given point @var{x}, @var{y}, @var{z} which assumed to be normalized in range [0, 1].
@end deftypemethod
@deftypemethod mglData @code{float} v (@code{int} i, @code{int} j=@code{0}, @code{int} k=@code{0}) @code{const}
Gets the value in specified cell of the data with border checking.
@end deftypemethod
@deftypemethod mglData @code{float} Spline5 (@code{float} x, @code{float} y, @code{float} z, @code{float} &dx, @code{float} &dy, @code{float} &dz) @code{const}
Interpolate by 5-th order splain the data to given point @var{x}, @var{y}, @var{z} which normalized in range [0, 1] and evaluate its derivatives.
@end deftypemethod

@c ------------------------------------------------------------------
@node Informational functions, Operators, Interpolation, mglData class
@section Informational functions
@cindex PrintInfo
@cindex Maximal
@cindex Minimal
@cindex Momentum
@cindex Find
@cindex Last
@cindex FindAny

@deftypemethod mglData @code{void} PrintInfo (@code{char *}buf, @code{bool} all=@code{false}) @code{const}
Print information about the data (sizes and momentum) to string @var{buf}. Parameter @var{all} set to print most of information (if @code{true}) or just basic one like dimensions, maximal an minimal values.
@end deftypemethod
@deftypemethod mglData @code{void} PrintInfo (@code{FILE *}fp) @code{const}
Print information about the data (sizes and momentum) to FILE (for example, stdout)
@end deftypemethod

@deftypemethod mglData @code{float} Maximal () @code{const}
Gets maximal value of the data.
@end deftypemethod
@deftypemethod mglData @code{float} Minimal () @code{const}
Gets minimal value of the data.
@end deftypemethod

@deftypemethod mglData @code{float} Maximal (@code{int} &i, @code{int} &j, @code{int} &k) @code{const}
Gets maximal value of the data and its position in the array to variables @var{i}, @var{j}, @var{k}.
@end deftypemethod
@deftypemethod mglData @code{float} Minimal (@code{int} &i, @code{int} &j, @code{int} &k) @code{const}
Gets minimal value of the data and its position in the array to variables @var{i}, @var{j}, @var{k}.
@end deftypemethod
@deftypemethod mglData @code{float} Maximal (@code{float} &i, @code{float} &j, @code{float} &k) @code{const}
Gets maximal value of the data and its approximated (interpolated) position to variables @var{i}, @var{j}, @var{k}.
@end deftypemethod
@deftypemethod mglData @code{float} Minimal (@code{float} &i, @code{float} &j, @code{float} &k) @code{const}
Gets minimal value of the data and its approximated (interpolated) position to variables @var{i}, @var{j}, @var{k}.
@end deftypemethod

@deftypemethod mglData @code{float} Momentum (@code{char} dir, @code{float} &m, @code{float} &w) @code{const}
Gets zero-momentum (energy, @math{I=\sum a_i}) and write first momentum (median, @math{m = \sum \xi_i a_i/I}) and second momentum (width, @math{w^2 = \sum (\xi_i-m)^2 a_i/I}) to variables. Here @math{\xi} is corresponding coordinate if @var{dir} is @samp{'x'}, @samp{'y'} or @samp{'z'}. Otherwise median is @math{m = \sum a_i/N}, width is @math{w^2 = \sum (a_i-m)^2/N}.
@end deftypemethod
@deftypemethod mglData @code{float} Momentum (@code{char} dir, @code{float} &m, @code{float} &w, @code{float} &s, @code{float} &k) @code{const}
Gets zero-momentum (energy, @math{I=\sum a_i}) and write first momentum (median, @math{m = \sum \xi_i a_i/I}), second momentum (width, @math{w^2 = \sum (\xi_i-m)^2 a_i/I}, third momentum (skewness, @math{s = \sum (\xi_i-m)^3 a_i/ I w^3}) and fourth momentum (kurtosis, @math{k = \sum (\xi_i-m)^4 a_i / 3 I w^4})) to variables. Here @math{\xi} is corresponding coordinate if @var{dir} is @samp{'x'}, @samp{'y'} or @samp{'z'}. Otherwise median is @math{m = \sum a_i/N}, width is @math{w^2 = \sum (a_i-m)^2/N} and so on.
@end deftypemethod

@deftypemethod mglData @code{float} Find (@code{const char *}cond, @code{int} &i, @code{int} &j, @code{int} &k) @code{const}
Find position (after specified in @var{i}, @var{j}, @var{k}) of first nonzero value of formula @var{cond}. Function return the data value at found position.
@end deftypemethod
@deftypemethod mglData @code{float} Last (@code{const char *}cond, @code{int} &i, @code{int} &j, @code{int} &k) @code{const}
Find position (before specified in @var{i}, @var{j}, @var{k}) of last nonzero value of formula @var{cond}. Function return the data value at found position.
@end deftypemethod
@deftypemethod mglData @code{int} Find (@code{const char *}cond, @code{char} dir, @code{int} i=@code{0}, @code{int} j=@code{0}, @code{int} k=@code{0}) @code{const}
Return position of first in direction @var{dir} nonzero value of formula @var{cond}. The search is started from point @{i,j,k@}.
@end deftypemethod
@deftypemethod mglData @code{bool} FindAny (@code{const char *}cond) @code{const}
Determines if any nonzero value of formula in the data array.
@end deftypemethod

@c ------------------------------------------------------------------
@node Operators, Global functions, Informational functions, mglData class
@section Operators

@deftypemethod mglData @code{void} operator= (@code{const mglData &}d)
Copies data from other variable.
@end deftypemethod
@deftypemethod mglData @code{void} operator*= (@code{const mglData &}d)
Multiplies the data by the other one for each element.
@end deftypemethod
@deftypemethod mglData @code{void} operator/= (@code{const mglData &}d)
Divides the data by the other one for each element.
@end deftypemethod
@deftypemethod mglData @code{void} operator+= (@code{const mglData &}d)
Adds the other data.
@end deftypemethod
@deftypemethod mglData @code{void} operator-= (@code{const mglData &}d)
Subtracts the other data.
@end deftypemethod
@deftypemethod mglData @code{void} operator*= (@code{float} d)
Multiplies each element by the number.
@end deftypemethod
@deftypemethod mglData @code{void} operator/= (@code{float} d)
Divides each element by the number.
@end deftypemethod
@deftypemethod mglData @code{void} operator+= (@code{float} d)
Adds the number to each element.
@end deftypemethod
@deftypemethod mglData @code{void} operator-= (@code{float} d)
Subtracts the number to each element.
@end deftypemethod


@deftypefn {Library Function} mglData operator+ (@code{const mglData &}a, @code{const mglData &}b)
Adds the other data.
@end deftypefn
@deftypefn {Library Function} mglData operator+ (@code{float} a, @code{const mglData &}b)
Adds the number.
@end deftypefn
@deftypefn {Library Function} mglData operator+ (@code{const mglData &}a, @code{float} b)
Adds the number.
@end deftypefn

@deftypefn {Library Function} mglData operator- (@code{const mglData &}a, @code{const mglData &}b)
Subtracts the other data.
@end deftypefn
@deftypefn {Library Function} mglData operator- (@code{float} a, @code{const mglData &}b)
Subtracts from the number.
@end deftypefn
@deftypefn {Library Function} mglData operator- (@code{const mglData &}a, @code{float} b)
Subtracts the number.
@end deftypefn

@deftypefn {Library Function} mglData operator* (@code{const mglData &}a, @code{const mglData &}b)
Multiplies by the other data.
@end deftypefn
@deftypefn {Library Function} mglData operator* (@code{float} a, @code{const mglData &}b)
Multiplies by the number.
@end deftypefn
@deftypefn {Library Function} mglData operator* (@code{const mglData &}a, @code{float} b)
Multiplies by the number.
@end deftypefn

@deftypefn {Library Function} mglData operator/ (@code{const mglData &}a, @code{const mglData &}b)
Divides by the other data.
@end deftypefn
@deftypefn {Library Function} mglData operator/ (@code{const mglData &}a, @code{float} b)
Divides by the number.
@end deftypefn

@c ------------------------------------------------------------------
@node Global functions, , Operators, mglData class
@section Global functions

These functions are not methods of @code{mglData} class. However it have additional functionality to handle data. So I put it in this chapter.

@deftypefn {Global function} @code{mglData} mglTransform (@code{const mglData &}real, @code{const mglData &}imag, @code{const char *}type)
Do integral transformation of complex data @var{real}, @var{imag} on specified direction. Now only Fourier transformation is supported. The order of transformations is specified in string @var{type}: first character for x-dimension, second one for y-dimension, third one for z-dimension. The possible character are: @samp{f} is forward Fourier transformation, @samp{i} is inverse Fourier transformation, @samp{n} or @samp{ } is no transformation.
@end deftypefn

@deftypefn {Global function} @code{mglData} mglTransformA @code{const mglData &}ampl, @code{const mglData &}phase, @code{const char *}type)
Do integral transformation of complex data @var{ampl}, @var{phase} on specified direction. Now only Fourier transformation is supported. The order of transformations is specified in string @var{type}: first character for x-dimension, second one for y-dimension, third one for z-dimension. The possible character are: @samp{f} is forward Fourier transformation, @samp{i} is inverse Fourier transformation, @samp{n} or @samp{ } is no transformation.
@end deftypefn

@deftypefn {Global function} @code{mglData} mglSTFA (@code{const mglData &}real, @code{const mglData &}imag, @code{int dn, }@code{char} dir=@code{'x'})
Short time Fourier analysis for real and imaginary parts. Output  is amplitude of partial Fourier of length @var{dn}. For example if @var{dir}=@samp{x}, result will have size @{int(nx/dn), dn, ny@} and it will contain @math{res[i,j,k]=|\sum_d^dn exp(I*j*d)*(real[i*dn+d,k]+I*imag[i*dn+d,k])|/dn}.
@end deftypefn

@deftypefn {Global function} @code{mglData} mglPDE (@code{const char *}ham, @code{const mglData &}ini_re, @code{const mglData &}ini_im, @code{mglPoint} Min, @code{mglPoint} Max, @code{float} dz=@code{0.1}, @code{float} k0=@code{100})
Solves equation du/dz = i*k0*@var{ham}(p,q,x,y,z,|u|)[u], where p=-i/k0*d/dx, q=-i/k0*d/dy are pseudo-differential operators. Parameters @var{ini_re}, @var{ini_im} specify real and imaginary part of initial field distribution. Parameters @var{Min}, @var{Max} set the bounding box for the solution. Note, that really this ranges are increased by factor 3/2 for purpose of reducing reflection from boundaries. Parameter @var{dz} set the step along evolutionary coordinate z. At this moment, simplified form of function @var{ham} is supported -- all ``mixed'' terms (like @samp{x*p}->x*d/dx) are excluded. For example, in 2D case this function is effectively @math{ham = f(p,z) + g(x,z,u)}. However commutable combinations (like @samp{x*q}->x*d/dy) are allowed. Here variable @samp{u} is used for field amplitude |u|. This allow one solve nonlinear problems -- for example, for nonlinear Shrodinger equation you may set @code{ham="p^2 + q^2 - u^2"}. You may specify imaginary part for wave absorption, like @code{ham = "p^2 + i*x*(x>0)"}, but only if dependence on variable @samp{i} is linear (i.e. @math{ham = hre+i*him}). @sref{PDE sample} 
@end deftypefn

@deftypefn {Global function} @code{mglData} mglRay (@code{const char *}ham, @code{mglPoint} r0, @code{mglPoint} p0, @code{float} dt=@code{0.1}, @code{float} tmax=@code{10})
Solves GO ray equation like dr/dt = d @var{ham}/dp, dp/dt = -d @var{ham}/dr. This is Hamiltonian equations for particle trajectory in 3D case. Here @var{ham} is Hamiltonian which may depend on coordinates @samp{x}, @samp{y}, @samp{z}, momentums @samp{p}=px, @samp{q}=py, @samp{v}=pz and time @samp{t}: @math{ham = H(x,y,z,p,q,v,t)}. The starting point (at @code{t=0}) is defined by variables @var{r0}, @var{p0}. Parameters @var{dt} and @var{tmax} specify the integration step and maximal time for ray tracing. Result is array of @{x,y,z,p,q,v,t@} with dimensions @{7 * int(@var{tmax}/@var{dt}+1) @}.
@end deftypefn

@deftypefn {Global function} @code{mglData} mglQO2d (@code{const char *}ham, @code{const mglData &}ini_re, @code{const mglData &}ini_im, @code{const mglData &}ray, @code{float} r=@code{1}, @code{float} k0=@code{100}, @code{mglData *}xx=@code{0}, @code{mglData *}yy=@code{0}, @code{bool} UseR=@code{true})
Solves equation du/dt = i*k0*@var{ham}(p,q,x,y,|u|)[u], where p=-i/k0*d/dx, q=-i/k0*d/dy are pseudo-differential operators (see @code{mglPDE()} for details). Parameters @var{ini_re}, @var{ini_im} specify real and imaginary part of initial field distribution. Parameters @var{ray} set the reference ray, i.e. the ray around which the accompanied coordinate system will be maked. You may use, for example, the array created by @code{mglRay()} function. Note, that the reference ray @strong{must be} smooth enough to make accompanied coodrinates unambiguity. Otherwise errors in the solution may appear. If @var{xx} and @var{yy} are non-zero then Cartesian coordinates for each point will be written into them. @sref{Beam tracing sample} 
@end deftypefn

@deftypefn {Global function} @code{mglData} mglJacobian (@code{const mglData &}x, @code{const mglData &}y)
@deftypefnx {Global function} @code{mglData} mglJacobian (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z)
Computates the Jacobian for transformation @{i,j,k@} to @{@var{x},@var{y},@var{z}@} where initial coordinates  @{i,j,k@} are data indexes normalized in range [0,1]. The Jacobian is determined by formula det||@math{dr_\alpha/d\xi_\beta}|| where @math{r}=@{@var{x},@var{y},@var{z}@} and @math{\xi}=@{i,j,k@}. All dimensions must be the same for all data arrays. Data must be 3D if all 3 arrays @{@var{x},@var{y},@var{z}@} are specified or 2D if only 2 arrays @{@var{x},@var{y}@} are specified.
@end deftypefn

