
@node Overview, Examples, , Top
@chapter Overview

@cindex MathGL overview

MathGL is ...
@itemize @bullet
@item
a library for making high-quality scientific graphics under Linux and Windows;
@item
a library for the fast data plotting and handling of large data arrays;
@item
a library for working in window and console modes and for easy embedding into other programs;
@item
a library with large and growing set of graphics.
@end itemize

@menu
* Why I have written MathGL?::  
* MathGL features::             
* Installation and using::      
* General concepts::            
* FAQ::                         
* Thanks::                      
@end menu

@node Why I have written MathGL?, MathGL features, , Overview
@section Why I have written MathGL?

The code for making high-quality scientific graphics under Linux and Windows. The  code for the fast handling and plotting of large data arrays. The code for working in window and console regimes and for easy including into another program. The code with large and renewal set of graphics. Exactly such code I was looking for during last years. Exactly such code I tried to realize in MathGL library.

At this version (@value{VERSION}) MathGL has more than 20000 code strings, more than 40 general types of graphics for 1d, 2d and 3d data arrays. It can export graphics to bitmap and vector (EPS or SVG) files. It has OpenGL interface and can be used from console programs. It has functions for data handling and script MGL language for simplification of data plotting. Also it has several types of transparency and smoothed lightning, vector fonts and TeX-like symbol parsing, arbitrary curvilinear coordinate system and many over useful things (see pictures section at @uref{http://mathgl.sf.net/, homepage}). Finally it is a platform independent and free (under GPL v.2.0 or later license).

@node MathGL features, Installation and using, Why I have written MathGL?, Overview
@section MathGL features

MathGL can plot wide range of graphics. It includes:
@itemize @bullet
@item
one-dimensional (Plot, Area, Bars, Step, Stem, Torus, Chart, Error, Tube, Mark, @pxref{1D plotting});

@item
two-dimensional plots (Mesh, Surf, Dens, Cont, ContF, Boxs, Axial, Fall, Belt, Tile, @pxref{2D plotting});

@item
three-dimensional plots (Surf3, Dens3, Cont3, ContF3, Cloud-like, @pxref{3D plotting});

@item
dual data plots: vector fields Vect and VectC, flow threads Flow, mapping chart Map, surfaces and isosurfaces transpared  or colored (i.e. its transparency or color is depend on) by other data SurfA, SurfC, Surf3A, Surf3C (@pxref{Dual plotting});

@item
and so on. For detail @xref{MathGL core}.
@end itemize

In fact, I created functions for drawing of all scientific plots that I know. The list of plots is enlarging, so if you need some special type of plot then write me @email{mathgl.abalakin@@gmail.com, e-mail} and it will appear in new version.

I tried to make plots as well-looking as possible: surface can be transparent and highlighted by several (up to 10) light sources. Most of drawing functions have 2 variants: simple one for the fast plotting of data, complex one for specifying of the exact position of plot (including parametric representation). Resulting image can be saved in bitmap (with the help of mglGraphZB, mglGraphGL) PNG, JPEG, TIFF, BMP format or in vector EPS or SVG format (with the help of mglGraphPS), or in IDTF format (with the help of mglGraphIDTF) which can be converted in U3D.

All text are drawn by vector font, that allows high scalability and portability. Text may contain commands for: some of TeX-like symbols, changing index (upper or lower indexes) and style of font inside the text string (@pxref{mglFont class}). Texts of ticks are rotated with axis rotation. It is possible to create a legend of plot and put text in arbitrary position of plot. An arbitrary text encoding (by help of function @code{setlocale()}) and UTF-16 encoding are supported.

Special mglData class is used for data encapsulation (@pxref{mglData class}). Except safe creation and deletion of data arrays it includes functions for data processing (smoothing, differentiating, integrating, interpolating and so on) and reading of data files with automatic size determination. Class mglData can handle arrays with up to three dimensions (arrays which depend up to 3 independent indexes @math{a_@{ijk@}}). Using an array with higher number of dimensions is not reasonable because I do not know how it can be plotted. Data filling and modifying may be fulfilled manually or by textual formulas.

Class mglFormula class allows the fast evaluation of a textual mathematical expression (@pxref{mglFormula class}). It is based on string precompilation to tree-like code at creation of class instance. At evaluation stage code performs only fast tree-walk and returns the value of the expression. Except changing data values, textual formulas are used for drawing in @emph{arbitrary} curvilinear coordinates. A set of such curvilinear coordinates is limited only by user imagination but not a fixed list like polar, parabolic, spherical and so on.

@node Installation and using, General concepts, MathGL features, Overview
@section Installation and using

MathGL can be installed by 3 ways.
@enumerate
@item
Compile from sources. The standard script for autoconf/automake tools is included in library beginning from version 1.2.1. For its running one should execute 3 commands: @code{./configure} after it @code{make} and @code{make install} with root/sudo rights. Script @code{./configure} have several additional options which is switched off by default. They are: @code{--enable-fltk, --enable-glut, --enable-qt} for ebabling FLTK, GLUT and/or Qt windows; @code{--enable-jpeg, --enable-tiff, --enable-hdf5} for enabling corresponded file formats; @code{--enable-all} for enabling all additional features. The full list of options can be viewed by command @code{./configure --help}.
@item
Use precompiled binary. There are binaries for MinGW (platform Win32). For precompiled variant one needs only to unpack the archive to the compiler location (or in any other folder and setup paths). By default precompiled versions include the support of GSL (www.gsl.org) and PNG. So, one needs to have these libraries installed on system.
@item
Install precompiled versions from standard packages (RPM, deb, DevPak and so on, see @uref{http://mathgl.sf.net/download.html, Download} section at homepage).
@end enumerate

At the own program compilation one needs to specify the linker key @code{-lmgl} for compilation in console program or with the external (not MathGL) window library. If one wants to use FLTK or GLUT windows then he needs to add the keys @code{-lmgl-fltk} or @code{-lmgl-glut}. Fortran users also should add C++ library by option @code{-lstdc++}.

@node General concepts, FAQ, Installation and using, Overview
@section General concepts

The set of MathGL features is rather reach -- just the number of basic graphics types is more than 40. Also there are functions for data handling, plot setup and so on. In spite of it I tried to keep the similar style in function names and in the order of arguments. Mostly it is regarded for different drawing functions.

There are six most general (base) concepts:
@enumerate
@item
@strong{Any picture is created in memory firstly.} The internal (memory) representation can be different: bitmap picture or the list of vector primitives. After it user may decide what he want: save to file, display on the screen, run animation, do additional editing and so on. This approach provides high portability of the program -- the source code will produce exactly the same picture in @emph{any} OS. Another big positive consequence is the ability to create the picture in console program (without window creating)!
@item
@strong{Every plot settings (style of lines, font, color scheme) are specified by string.} It provides convenience for user/programmer -- short string with parameters is more comprehensible than a large set of parameters. Also it provides portability -- the strings are the same in any OS so that it is not comprehensible to think about type of arguments.
@item
@strong{All functions have ``simplified'' and ``advanced'' forms.} It is done for user convenience. One needs to specify the only one data array in ``simplified'' form and will see the result. But one may set parametric dependence of coordinates and produce rather complex curves and surfaces in ``advanced'' form. In both cases the order of function arguments are the same: firstly data arrays, secondly the string with plot parameters, and later optional arguments for plot tunning.
@item
@strong{All data arrays for plotting are encapsulated in class mglData class.} It reduces the number of errors with memory working and provide the uniform interface for data of different types (float, double and so on) or for formulas plotting.
@item
@strong{All plots are vector plot.} The MathGL library is intended for handling scientific data which have vectorial nature (there are lines, faces, matrices and so on). As result vectorial representation is used in any cases! In addition the vectorial representation allows one to scale easily the plot -- change the canvas size by 2 times and the picture will proportionally scaled.
@item
@strong{New drawing never clears things drawn already.} This, in some sense, is unexpected, idea allows to create a lot of ``combined'' graphics. For example, for making a surface with contour lines one need to call the function of surface plotting and the function of contour lines plotting (in any order). At this the special functions (as it done in Matlab and some other plotting system) for making this ``combined'' plots are useless. Much more examples of such plots can be found in section @ref{Hints} and in home site (@uref{http://mathgl.sf.net/index.html}).
@end enumerate

Except general concept I want consider on some non-trivial or non-usual general ideas -- plot positioning, axis specification and curvilinear coordinates, styles for lines, text and color scheme.

@menu
* Coordinate axes::             
* Line styles::                 
* Color scheme::                
* Font style::                  
@end menu


@node Coordinate axes, Line styles, , General concepts
@subsection Coordinate axes

There is twofold axes representation in MathGL. First one consists in normalizing of the data point coordinates in box @var{Min}x@var{Max} (@pxref{Axis settings}). If @var{Cut} is @code{true} then the outlied points are omitted otherwise they are projected to the bounding box (@pxref{Cutting}). Also, the point will be omitted if it lies inside the box defined by @var{CutMin}x@var{CutMax} or if the value of formula @code{CutOff}() is nonzero for its cooridnates. After it transformation formulas are applied to the data point (@pxref{Transformation}). Finally, the data point is plotted by one of function.

There is possibility to set members @var{Max}, @var{Min} directly but one should call @code{RecalcBorder()} function to setup plotting routines. The more safe way is to set these values by calling @code{Axis()} function. In this case the function @code{RecalcBorder()} is called automatically. Another way to specify the size of axis is to set it as a minimal or maximal value of data array. Functions @code{XRange(), YRange(), ZRange()} do it. The second (optional) argument sets to replace the axis range or to join with the existed range.

The axis origin is defined by variable @var{Org} and is applied for all consequent calls of axes or grid drawing. By default, if this point lies outside the bounding box then it is projected to the one (variable @var{AutoOrg} control it). In the case if one of values of @var{Org} is equal to NAN then the corresponding value will be selected automatically.

There is 4-th axis @emph{c} (color axis or colorbar) in addition to usual axes @emph{x, y, z}. It sets the range of values for the surface coloring. Its borders are automatically set to values of Min.z, Max.z during the call of @code{Axis()} function. Also, there are direct change of the color range by setting of variables @var{Cmax}, @var{Cmax}, or calling functions @code{CAxis()} or @code{CRange()}. Use @code{Colorbar()} function for showing the colorbar.

The form (appearence) of tick labels is controlled by @code{SetTicks()} function and few variables (@pxref{Ticks}). It have 3 arguments: first one @var{d} set the tick step (if positive) or tick number (if negative) or switch logarithmic ticks on (if zero); second one @var{ns} set the number of subticks; last one is the starting point for ticks (default is axis origin). The variable @var{TuneTicks} switches on/off ticks enhancing by the detaching of the common multiplier (for small, like from 0.001 to 0.002, or large, like from 1000 to 2000, coordinate values) or common component (for narrow range, like from 0.999 to 1.000). Finally, you may use variables @var{xtt}, @var{ytt}, @var{ztt}, @var{ctt} for setting templates for tick labels (it supports TeX symbols). Also, there is a possibility to print arbitrary text as tick labels if one defines the pointer (name) of function @var{TickStr}.

@node Line styles, Color scheme, Coordinate axes, General concepts
@subsection Line styles

@cindex Line style
@cindex Mark style
@cindex Arrows

The line style is defined by the string which may contain specifications for color (@samp{wkrgbcymhRGBCYMHWlenupqLENUPQ}), dashing style (@samp{-|;:ji} or space), width (@samp{0123456789}) and marks (@samp{o+xsd.^v} and @samp{#} modifier). If one of type of information is omitted then default values with the previous color are used.

The color types are the same as described in mglColor class (@pxref{mglColor class}): @samp{k} -- black, @samp{r} -- red, @samp{R} -- dark red, @samp{g} -- green, @samp{G} -- dark green, @samp{b} -- blue, @samp{B} -- dark blue, @samp{c} -- cyan, @samp{C} -- dark cyan, @samp{m} -- magenta, @samp{M} -- dark magenta, @samp{y} -- yellow, @samp{Y} -- dark yellow (gold), @samp{h} -- gray, @samp{H} -- dark gray, @samp{w} -- white, @samp{W} -- bright gray, @samp{l} -- green-blue, @samp{L} -- dark green-blue, @samp{e} -- green-yellow, @samp{E} -- dark green-yellow, @samp{n} -- sky-blue, @samp{N} -- dark sky-blue, @samp{u} -- blue-violet, @samp{U} -- dark blue-violet, @samp{p} -- purple, @samp{P} -- dark purple, @samp{q} -- orange, @samp{Q} -- dark orange (brown).

Dashing styles has the following meaning: space -- no line (usable for plotting only marks), @samp{-} -- solid line (################), @samp{|} -- dashed line (########________), @samp{;} -- small dashed line (####____####____), @samp{:} -- dotted line (#___#___#___#___), @samp{j} -- dash-dotted line (#######____#____), @samp{i} -- small dash-dotted line (###__#__###__#__).

Marker types are: @samp{o} -- circle, @samp{+} -- cross, @samp{x} -- skew cross, @samp{s} - square, @samp{d} - rhomb (or diamond), @samp{.} -- point, @samp{^} -- triangle up, @samp{v} -- triangle down. If string contain symbol @samp{#} then the solid versions of markers are used.

@float
@image{png/sample5, 7cm}
@caption{Styles of lines and marks.}
@end float

One may specify to draw a special symbol (an arrow) at the beginning and at the end of line. It is possible if the specification string contains one of the following symbols: @samp{A} -- outer arrow, @samp{V} -- inner arrow, @samp{I} -- transverse hachures, @samp{K} -- arrow with hachures, @samp{T} -- triangle, @samp{S} -- square, @samp{D} -- rhomb, @samp{O} -- circle, @samp{_} -- nothing (it is default). At this, there is a rule: first symbol specifies the arrow at the end of line, second one  specifies the arrow at the beginning of line. For example, @samp{r-A} defines a red solid line with usual arrow at the end, @samp{b|AI} defines a blue dash line with an arrow at the end and with hachures at the start, @samp{_O} defines a line with the current style and with a circle at the start. These styles are applicable during the graphics plotting too (for example, @ref{Plot}).

@float
@image{png/sampled, 7cm}
@caption{Arrow styles.}
@end float

@node Color scheme, Font style, Line styles, General concepts
@subsection Color scheme

@cindex Color scheme

The color scheme is used for determining the color of surfaces, isolines, isosurfaces and so on. The color scheme is defined by the string which may contain several characters that are color id (@pxref{mglColor class} or @pxref{Line styles}) or characters @samp{d#:|}. Symbol @samp{d} denotes interpolation by 3d position instead of the coloring by amplitude. Symbol @samp{#} switch to mesh drawing or to wire plot. Symbol @samp{|} disable color interpolation in color scheme which can be usefull, for example, for sharp colors during matrix plotting. Symbol @samp{:} finishes the color scheme parsing. After it the user may put styles for text, rotation axis for curves/isolines and so on. Color scheme may contain up to 32 color values.

Also you may use ``lighted'' colors in color scheme specification (@emph{not in line style!}). The ``lighted'' color contain 2 symbols: first one is usual symbol for color specification, second one is digit for its brightness. The digit can be in range @samp{1}...@samp{9}. At this @samp{5} correspond to normal color, @samp{1} is very dark version of the color (practically black), @samp{9} is very bright version of the color (practically white).

@float
@image{png/colors, 7cm}
@caption{Colors and its ids.}
@end float

For coloring by @emph{amplitude} (most common) the final color is linear interpolation of color array. The color array is constructed from the string ids. The argument is the amplitude normalized between @var{Cmin} -- @var{Cmax} (@pxref{Ranges (bounding box)}). For example, string containing 4 characters @samp{bcyr} corresponds to colorbar from blue (lowest value) through cyan (next value) through yellow (next value) to the red (highest value). String @samp{kw} corresponds to colorbar from black (lowest value) to white (highest value). String @samp{m} corresponds to a simple magenta color.

There are several useful combinations. String @samp{kw} corresponds to the simplest gray color scheme when higher values are brighter. String @samp{wk} presents the inverse gray color scheme when higher value is darker. Strings @samp{kRryw}, @samp{kGgw}, @samp{kBbcw} present  well-known @emph{hot}, @emph{summer} and @emph{winter} color schemes. Strings @samp{BbwrR} and @samp{bBkRr} allow to view bicolor figure on white or black background when negative values are blue and positive values are red. String @samp{BbcyrR} gives color scheme similar to well-known @emph{jet} color scheme.

Examples of the most popular color schemes:
@table @samp
@item kw
@image{png_static/kw}
@item wk
@image{png_static/wk}
@item hHCcw
@image{png_static/kHCcw}

@item kRryw
@image{png_static/kRryw}
@item kGgew
@image{png_static/kGgew}
@item kBbcw
@image{png_static/kBbcw}

@item BbwrR
@image{png_static/BbwrR}
@item BbwgG
@image{png_static/BbwgG}
@item GgwmM
@image{png_static/GgwmM}

@item bcwyr
@image{png_static/bcwyr}
@item QqwcC
@image{png_static/QqwcC}
@item CcwyY
@image{png_static/CcwyY}

@item BbcyrR
@image{png_static/BbcyrR}
@item BbcwyrR
@image{png_static/BbcwyrR}
@item bwr
@image{png_static/bwr}

@item bcyr
@image{png_static/bcyr}
@item bgr
@image{png_static/bgr}
@item BbcyrR|
@image{png_static/sharp}
@end table

For the coloring by @emph{coordinate} the final color is determined by position of the point in 3d space and is calculated by formula c=x*c[1] + y*c[2] + z*c[3]. Here c[1], c[2], c[3] are the first three elements of color array; x, y, z are normalized to @var{Min} -- @var{Max} coordinates of the point. This type of coloring is useful for isosurface plot when color may show the exact position of the peace of surface. For example, @pxref{Surf3}.

Also you may use ``lighted'' colors in color scheme specification (@emph{not in line style!}). The ``lighted'' color contain 2 symbols: first one is usual symbol for color specification, second one is digit for its brightness. The digit can be in range '1'...'9'. At this @samp{5} correspond to normal color, @samp{1} is very dark version of the color (practically black), @samp{9} is very bright version of the color (practically white). For example, the color scheme can be @samp{b2b7wr7r2}.

@node Font style, , Color scheme, General concepts
@subsection Font style

@cindex Font style

Text style is specified by the string which may contain several characters of font (@samp{ribwou}) and/or align (@samp{LRC}) specifications. The string also may contain the color id characters @samp{wkrgbcymhRGBCYMHW} (@pxref{mglColor class}) after the symbol @samp{:}. For example, @samp{biC:b} sets the bold italic font text aligned at the center and with blue color.

The font types are: @samp{r} -- roman font, @samp{i} -- italic style, @samp{b} -- bold style. By default roman roman font is used. The align types are: @samp{L} -- align left (default), @samp{C} -- align center, @samp{R} -- align right. Additional font effects are: @samp{w} -- wired, @samp{o} -- over-lined, @samp{u} -- underlined. Also a parsing of the LaTeX-like syntax is provided (for detail, @pxref{mglFont class} and @ref{Font settings}).

The font size can be defined explicitly (if @var{size}>0) or relatively the base font size as |@var{size}|*@var{FontSize} (if @var{size}<0). The value @var{size}=0 specifies that the string will not be printed. The base font size is measured in internal ``MathGL'' units. Special functions @code{SetFontSizePT(), SetFontSizeCM(), SetFontSizeIN()} allow one to set it in more ``common'' variables for given dpi of the picture.

@node FAQ, Thanks, General concepts, Overview
@section FAQ

@table @strong
@item The plot does not appear
Check that points of the plot lie  inside the bounding box and resize the bounding box by @code{Axis()} function. Check that the data have correct dimensions for selected type of plot. Be sure that  @code{Finish()} is called after the plotting functions (or be sure that the plot is saved to file).

@item I can not find some special kind of plot.
Most of ``new'' type of plot can be created by using of the existing drawing functions. For example, the surface of curve rotation can be created by special function @code{Torus()} or as parametrically specified surface @code{Surf()}. See also, @ref{Hints} and @ref{Examples} of MathGL. If you can not find some type of plot then e-mail me and this plot will appear in the next version of MathGL library.

@item Should I know some graphical libraries (like OpenGL) for the using of MathGL library?
No. The MathGL library is self-consistent and does not require the knowledge of external libraries.

@item In which language the library is written? For which languages the library has interface?
The core of MathGL library is written on C++. But there are interfaces for pure C, Fortran, Pascal, Forth languages and its own command language MGL. Also there are a large set of interpreter languages support (Python, Java,  ALLEGROCL, CHICKEN, Lisp, CFFI, C#, Guile, Lua, Modula 3, Mzscheme, Ocaml, Octave, Perl, PHP, Pike, R, Ruby, Tcl). These interfaces are written via SWIG (both pure C functions and classes) but only interface for Python and Octave is included in autoconf/automake script. The matter that I don't know any other interpreter languages :(. Note, the most of other languages can use (can link) pure C functions.

@item How I can use MathGL with Fortran?
You can use MathGL as is with @code{gfortran} because it use by default AT&T notation for external functions. For other compilers (like, Visual Fortran) you have to switch on AT&T notation manually. The AT&T notation require that symbol @samp{_} is added at the end of function name, function argument(s) is passed by pointers and string length(s) is passed at the end of argument list. For example:

@emph{C function} -- @code{void mgl_fplot(HMGL graph, const char *fy, const char *stl, int n);}

@emph{AT&T function} -- @code{void mgl_fplot_(uintptr_t *graph, const char *fy, const char *stl, int *n, int ly, int ls);}

@item I have class Foo and drawing method Foo::draw(mglGraph *gr). How I can use it in FLTK or GLUT window?
The member-functions of classes have hidden parameter (the pointer to a class instance) in C++. So, their direct usage is impossible. The solution is to write interface function:
@example
int foo_draw(mglGraph *gr, void *par)
@{   ((Foo *)foo)->draw(gr);    @}
@end example
and to use it in the call of @code{Window()} function:
@example
gr->Window(argc,argv,foo_draw,"Title",this);
@end example

Alternatively you can inherit yours class from @code{mglDraw} class and use functions like @code{gr->Window(argc, argv, foo, "Title");}.

@item How can I print in Russia/Spanish/Arabian/Japanese and so on?
The standard way is the using of Unicode encoding for the text output. But MathGL library also has interface for 8-bit (char *) strings with internal conversion to Unicode. This conversion depends on the current locale OS. You may change it by @code{setlocale()} function. For example, for Russian text in CP1251 encoding you may use @code{setlocale(LC_CTYPE, "ru_RU.cp1251");} (under MS Windows the name of locale may differ -- @code{setlocale(LC_CTYPE, "russian_russia.1251")}). I strongly recommend not to use the constant @code{LC_ALL} in conversion. Because it also changes the number format that may lead to mistakes in formulas writing and reading textual data files. For example, the program will await a @samp{,} as a decimal point but the user will enter @samp{.}.

@item How can I exclude a point or a region of plot from the drawing?
There are 3 general ways. First, the point with @code{NAN} value of one of coordinate will never be plotted. Second, special variables @var{CutMin}, @var{CutMax} or function @code{CutOff}() define the condition when the points should be omitted (@pxref{Cutting}). Last, you may change the transparency of part of the plot by the help of functions @code{SurfA()}, @code{Surf3A()} (@pxref{Dual plotting}). In last case the transparency is switched on smoothly.

@item I use VisualStudio, CBuilder or some other compiler (not MinGW/gcc). How can I link MathGL library?
There are 2 ways. First is use the precompiled binary (*.dll). In this case you should make libraries for yours compiler from *.dll and *.def files. The corresponding command may look like @code{lib.exe /def:libmgl.def}. But such way provide you only pure C functions, not C++ classes. The matter is that there is no standard for C++ functions naming in object files. The standard was accepted only for C functions.

The second way is to compile the library from sources. MathGL library have some external dependencies (PNG, GSL, JPEG, TIFF, FLTK, GLUT, HDF5), but most of them is optional. Some libraries can be found @uref{https://sourceforge.net/project/showfiles.php?group_id=152187&package_id=267177, here}. But also you may exclude from the project the corresponding files to disable usage of JPEG, TIFF, FLTK, GLUT, HDF5 libraries. Also you may define @code{NO_GSL} at compilation stage for disabling GSL support. At this some special functions in formulas, Fourier transform and nonlinear fitting will be disabled also.

For excluding PNG support just comment the body of functions @code{mgl_pnga_save(), mgl_png_save()} in @code{mgl_export.cpp}. After it MathGL library will not depend on any external libraries. But in this case you should redirect the output to some window (as bitmap drawing from mglGraphZB|PS::GetBits() or mglGraphZB|PS::GetRGBA()) and save this bitmap to a file by yourself.

@strong{Finally!} Please @emph{do not} ask me Windows-specific questions. I do not use Windows. I know nothing about Visual Basic, Visual C++, CBuiled or .NET. Please find the appropriate Usenet discussion group and ask your question there.

@item How many people write this library?
The most of the library was written by one person. This is result of near a year of work (mostly in the  evening and in holidays): half-year I spent for writing the kernel and half-year or year I spent for extending, improving and documentation writing. This process continues now :). The autoconf/automake script was written mostly by D.Kulagin, and export to IDTF was written mostly by M.Vidassov. Packages to particular platform (RPM or DEB) are prepared by other people (thanks to D. Kulagin, S. Plis, V. Lipatov and N. Troitsky).

@end table

@node Thanks, , FAQ, Overview
@section Thanks

@itemize @bullet
@item
My special thanks to Marina Balakina for the patience during library writing and for the help in documentation writing and spelling.
@item
I'm thankful to D. Kulagin and S.M. Plis for making Debian packages.
@item
I'm thankful to M. Vidassov for the help in handling solid UTF-8 fonts.
@item
I'm thankful to N. Troickiy and V. Lipatov for making RPM packages.
@item
I'm thankful to S. Skobelev, A. Korotkevich, V. Onuchin, S.M. Plis, R. Kiselev, A. Ivanov, M. Vidiassov and V. Lipatov for fruitful comments.
@end itemize
