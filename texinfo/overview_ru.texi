
@node Overview, Examples, , Top
@chapter Overview

@cindex Обзор MathGL

MathGL это ...
@itemize @bullet
@item
библиотека для создания высококачественной научной графики под Linux и Windows;
@item
библиотека для быстрого обработки и отображения больших массивов данных;
@item
библиотека для работы в оконном и консольном режимах;
@item
библиотека с большим набором базовых типов графиков.
@end itemize

@menu
* Зачем написана MathGL?::  
* Возможности MathGL::             
* Установка MathGL::      
* Основные принципы::
* FAQ::
* Интерфейсы::
* Благодарности::                      
@end menu

@node Зачем написана MathGL?, Возможности MathGL, , Overview
@section Зачем написана MathGL?

Код для создания качественной научной графики на различных платформах. Код для быстрой обработки и отображения больших массивов данных. Код для работы в графическом и консольном режимах и легкого интегрирования в другие программы. Код с большим обновляемым набором графиков и инструментами обработки данных. Именно такого кода мне не хватало в последние годы при работе на персональных компьютерах и на кластерах. И именно такой код я постарался создать в библиотеке MathGL.

На данный момент (версия @value{VERSION}) MathGL это более 20000 строк кода, более 40 основных типов графиков для одно-, двух- и трехмерных массивов, возможность экспорта в растровые и векторные (EPS или SVG) файлы, интерфейс для OpenGL и возможность запуска в консольном режиме, функции для обработки данных и даже простейший командный (интерпретируемый) язык MGL для упрощения построения графиков. Кроме того, есть несколько типов прозрачности, гладкое освещение, векторные шрифты, TeX-ие команды в надписях, произвольные криволинейные системы координат и прочие полезные мелочи (см. раздел pictures на @uref{http://mathgl.sf.net/, домашней странице}). Ну, и, естественно, полная переносимость библиотеки и ее свободное распространение под лицензией GPL v.2.0 или более поздней.

@node Возможности MathGL, Установка MathGL, Зачем написана MathGL?, Overview
@section Возможности MathGL

Библиотека MathGL позволяет строить широкий класс графиков, включая:
@itemize @bullet
@item
рисование одномерных массивов (Plot, Area, Bars, Step, Stem, Torus, Chart, Error, Tube, Mark, @pxref{1D plotting});

@item
рисование двумерных массивов (Mesh, Surf, Dens, Cont, ContF, Boxs, Axial, Fall, Belt, Tile, @pxref{2D plotting});

@item
рисование трехмерных массивов (Surf3, Dens3, Cont3, ContF3, Cloud-like, @pxref{3D plotting});

@item
рисование нескольких связанных массивов: векторные поля Vect и VectC, линии тока Flow, точечное отображение Map, поверхности с прозрачностью или цветом, определяемым другим массивом SurfA, SurfC, Surf3A, Surf3C (@pxref{Dual plotting});

@item
и другие (см. @pxref{MathGL core}).
@end itemize

Фактически, я постарался реализовать все известные мне типы научных графиков. Список графиков постоянно пополняется, и если Вам нужен какой-то новый вариант, пишите на @email{mathgl.abalakin@@gmail.com, e-mail}, и в новой версии библиотеки этот график появится.

Я постарался сделать графики максимально красивыми -- поверхности могут быть прозрачными и освещены произвольно расположенными источниками света (максимальное их количество 10). Большинство функций рисования имеет два варианта: простой для быстрого построения картинки и более сложный для детальной настройки отображения, включающего в том числе возможность параметрического задания всех массивов. Получившееся изображение можно сохранить в растровом (с помощью классов mglGraphZB, mglGraphGL) формате PNG, JPEG, GIF, TIFF или BMP; в векторном EPS или SVG формате (с помощью класса mglGraphPS) и в IDTF формате (с помощью класса mglGraphIDTF), который можно конвертировать в U3D формат.

Все надписи выводятся векторным шрифтом, что обеспечивает их хорошую масштабируемость и переносимость. Текст может содержать команды для большинства ТеХ-их символов, изменения положения (верхний и нижний индексы) и стиля шрифта внутри строки текста (@pxref{mglFont class}). Текст меток поворачивается вместе с осями. На график можно вывести описание кривых (легенду) и поместить надпись в произвольную точку экрана или пустить ее вдоль кривой. Поддерживаются произвольные кодировки текста (с помощью стандартной функции @code{setlocale()}) и текст в кодировке UTF-16.

Для представления данных используется специальный класс mglData (@pxref{mglData class}). Помимо безопасного создания и удаления массивов, он включает функции по их обработке (дифференцированию, интегрированию, сглаживанию, интерполяции и т.д.) и чтению текстового файла с автоматическим определением размеров данных. Класс mglData позволяет работать с массивами размерности вплоть до 3 (массивы, зависящие от трех независимых индексов @math{a_@{ijk@}}). Использование массивов с большим числом размерностей нецелесообразно, поскольку я не представляю, как их можно отобразить на экране. Заполнение или изменение значений массива можно выполнить как вручную, так и по формуле, заданной текстовой строкой.

Для @emph{быстрого} вычисления значения выражения, заданного текстовой строкой, используется класс mglFormula (@pxref{mglFormula class}). Он основан на компиляции строки в древоподобную структуру при создании экземпляра класса. На этапе вычисления происходит быстрый обход дерева с выдачей результата для конкретных значений переменных. Помимо изменения значений массива данных, текстовые формулы используются для рисования в @emph{произвольной} криволинейной системе координат. Набор таких координат ограничивается только фантазией пользователя, а не фиксированным числом (типа полярной, параболической, цилиндрической и т.д.).

@node Установка MathGL, Основные принципы, Возможности MathGL, Overview
@section Установка MathGL

Установка библиотеки возможна тремя способами.
@enumerate
@item
Скомпилировать библиотеку непосредственно из исходных файлов. С библиотекой поставляется стандартный скрипт для autoconf/automake. Для его запуска достаточно в командной строке выполнить 3 команды: сначала @code{./configure} далее @code{make} и, наконец, с правами суперпользователя @code{make install}. Скрипт @code{./configure} имеет несколько дополнительных опций, которые по умолчанию отключены. К их числу относятся: @code{--enable-fltk, --enable-glut, --enable-qt} для поддержки FLTK, GLUT и/или Qt окон; @code{--enable-jpeg, --enable-tiff, --enable-hdf5} для поддержки соответствующих форматов; @code{--enable-all} для включения всех возможностей. Для создания интерфейсов к другим языкам (кроме С/Фортран/MGL) используйте опции @code{--enable-python, --enable-octave} или @code{--enable-langall} для всех поддерживаемых языков. Полный список опций можно увидеть, выполнив @code{./configure --help}.
@item
Использовать предварительно скомпилированные файлы -- с библиотекой поставляются файлы для MinGW (платформа Win32). В скомпилированной версии достаточно распаковать заголовочные файлы в папку с заголовочными файлами и библиотеку libmgl.a в папку с библиотеками. По умолчанию, скомпилированная версия включают поддержку GSL (www.gsl.org) и PNG. Соответственно, при сборке программы эти библиотеки должны быть установлены.
@item
Установить из стандартных пакетов (RPM, deb, DevPak и пр.). 
@end enumerate

При сборке пользовательской программы достаточно указать ключ @code{-lmgl} для компиляции в консольной программе или с использованием внешней графической библиотеки. При использовании окон FLTK или GLUT надо указать/добавить ключи, включающие соответствующие библиотеки -- @code{-lmgl-fltk} или @code{-lmgl-glut}. Для использования в Фортране дополнительно надо указать опцию @code{-lstdc++} для библиотек C++.

@node Основные принципы, FAQ, Установка MathGL, Overview
@section Основные принципы

Возможности библиотеки MathGL довольно богаты -- число только основных типов графиков превышает 50 видов. Кроме того, есть функции для обработки данных, настройки вида графика и пр. и пр. Тем не менее, я старался придерживаться единого стиля в порядке аргументов функций и способе их ``настройки''. В основном все ниже сказанное относится к функциям рисования различных графиков.

Всего основных концепций (базисных идей) шесть:
@enumerate
@item
@strong{Все рисунки создаются в памяти.} Это могут быть как растровые картинки, так и векторные списки примитивов. Дальнейшая судьба рисунков определяется пользователем: можно сохранить в файл, вывести на экран, создать анимацию/кино, дополнительно отредактировать и т.д. Такой подход обеспечивает высокую переносимость библиотеки -- один и тот же программный код создаст в точности одинаковый рисунок на @emph{любой} операционной системе. Кроме того, при таком подходе рисунки можно создавать непосредственно в консольной программе -- графическое окно не нужно!
@item
@strong{Все настройки графиков (стиль линий, цветовые схемы поверхностей, стиль и цвет текста) задаются строками.} Это обеспечивает: удобство для пользователя -- короткую строку легче читать и здесь тяжелее ошибиться, чем в большом списке параметров; переносимость -- строки выглядят одинаково на всех платформах и не надо заботиться о типе и числе аргументов.
@item
@strong{Все функции имеют ``упрощенный'' и ``продвинутый'' варианты.} Сделано опять из-за удобства. В ``упрощенном'' варианте для построения графика нужны только один-два массив(а) данных, которые автоматически равнораспределяются в заданном диапазоне осей координат. В ``продвинутой'' версии можно не только указать явно диапазон построения графика, но и задать его параметрически. Последнее позволяет легко строить довольно сложные кривые и поверхности. В обоих вариантах функций порядок аргументов стандартен: сначала идут массивы данных, потом необязательный строковый параметр стиля графика, а далее -- второстепенные необязательные параметры для более точной настройки графика.
@item
@strong{Все данные передаются через экземпляры класса mglData.} Такой подход позволяет избежать ошибок при работе с памятью и единообразно передавать данные разных типов (float, double, данные из файла, заполненных пользователем и пр.) в функции рисования.
@item
@strong{Все элементы рисунков векторные.} Изначально библиотека MathGL была ориентированна на работу с научными данными, которые по своей природе векторные (линии, грани, матрицы и т.д.). Поэтому векторность используется во всех рисунках! Причем иногда даже в ущерб производительности (например, при выводе шрифтов). Помимо всего прочего, векторность позволяет легко масштабировать рисунок -- измените размер картинки в 2 раза, и рисунок пропорционально растянется.
@item
@strong{Новые графики не удаляют уже нарисованное.} Этот, в чем-то неожиданный, подход позволяет создавать огромное количество ``комбинированных'' графиков. Например, поверхность с наложенными линиями уровня строится двумя последовательными вызовами функций рисования поверхности и линий уровня (в любом порядке). И совершенно не надо писать специальную функцию (как в Matlab и некоторых других программах) для рисования этого графика. Примеров таких графиков можно привести множество (см. раздел @ref{Hints} и сайт программы @uref{http://mathgl.sf.net/index.html}).
@end enumerate

Кроме основных концепций я хотел бы остановиться на нескольких, как оказалось, нетривиальных моментах -- способе указания положения графика, осей координат и строковых параметров линий, поверхностей, текста.

@menu
* Оси координат::             
* Стиль линий::                 
* Цветовая схема::                
* Стиль текста::                  
@end menu


@node Оси координат, Стиль линий, , Основные принципы
@subsection Оси координат

Представление системы координат в MathGL состоит из двух частей. Вначале координаты нормируются в интервал @var{Min}x@var{Max} (@pxref{Axis settings}). Если флаг @var{Cut} установлен, то точки вне интервала отбрасываются, в противном случае, они проецируются на ограничивающий параллелепипед (@pxref{Cutting}). Кроме того, отбрасываются точки внутри границ, определенных переменными @var{CutMin}x@var{CutMax} и точки, для которых значение функции @code{CutOff}() не равно нулю. После этого формулы перехода в криволинейную систему координат @code{SetFunc()}применяются к каждой точке. Наконец, точка данных отображается с помощью одной из графических функций.

Величины @var{Max}, @var{Min} можно изменять вручную. Однако, после этого необходимо вызвать функцию @code{RecalcBorder()} для настройки графика. Более удобный и безопасный путь состоит в вызове функций @code{Axis(), SetRanges()} и др. В последнем случае функция @code{RecalcBorder()} вызывается автоматически. Размеры осей можно задавать и автоматически по минимальному и максимальному значениям массива данных. Для этого предназначены функции @code{XRange(), YRange(), ZRange()}. Второй не обязательный аргумент указывает, заменять ли новые значения диапазона изменения оси координат (по умолчанию) или только расширить уже существующий диапазон.

Точка пересечения осей координат задается переменной @var{Org} и действует на последующие вызовы функций рисования осей координат и сетки. По умолчанию, если точка пересечения осей координат попадает вне диапазона осей координат, то она проецируется на границу области. Изменить такое поведение можно, задав @var{AutoOrg}=@code{false}. В случае, если одно из значений @var{Org} равно NAN, то соответствующее значение будет выбрано автоматически.

Кроме привычных осей @emph{x, y, z} есть еще одна ось -- цветовая шкала -- ось @emph{c}. Она используется при окрашивании поверхностей и задает границы изменения функции при окрашивании. При вызове @code{Axis()} ее границы автоматически устанавливаются равными Min.z и Max.z. Возможно и ручное изменение границ цветового интервала посредством вызова функции @code{CAxis()} или изменение границ по заданному массиву @code{CRange()}. Используйте @code{Colorbar()} для отображения цветовой шкалы.

Вид меток по осям определяется функцией @code{SetTicks()} (@pxref{Ticks}). Она имеет 3 аргумента: первый @var{d} задает шаг меток (если положительны) или их число (если отрицательны) или логарифмические метки (если равны нулю); второ @var{ns} задает число "подметок"; последний определяет начальную точку для меток (по умолчанию это точка пересечения осей). Функция @var{SetTuneTicks} включает/выключает выделение общего множителя (большого или малого факторов в диапазоне) для меток осей координат. Наконец, если стандартный вид меток не устраивает пользователя, то их шаблон можно задать явно (можно использовать и ТеХ символы), воспользовавшись функциями  @code{SetXTT(), SetYTT(). SetZTT(). SetCTT()}. Кроме того, в качестве меток можно вывести произвольный текст использовав функцию @code{SetTicksVal()}.

@node Стиль линий, Цветовая схема, Оси координат, Основные принципы
@subsection Стиль линий

@cindex Стиль линий
@cindex Стиль маркеров
@cindex Стиль стрелок

Стиль линии задается строкой, которая может содержать символ цвета (@samp{wkrgbcymhRGBCYMHWlenupqLENUPQ}), тип пунктира (@samp{-|;:ji} или пробел), ширину линии (@samp{0123456789}) и тип маркера (@samp{o+xsd.^v} и модификатор @samp{#}). Если пропущен цвет или тип пунктира, то используется значение по умолчанию с последним указанным цветом.

Символы цвета те же, что и в классе mglColor (@pxref{mglColor class}): @samp{k} -- черный, @samp{r} -- красный, @samp{R} -- темно красный, @samp{g} -- зеленый, @samp{G} -- темно зеленый, @samp{b} -- синий, @samp{B} -- темно синий, @samp{c} -- голубой, @samp{C} -- темно голубой, @samp{m} -- пурпурный, @samp{M} -- темно пурпурный, @samp{y} -- желтый, @samp{Y} -- темно желтый (золотой), @samp{h} -- серый, @samp{H} -- темно серый, @samp{w} -- белый, @samp{W} -- светло серый, @samp{l} -- сине-зеленый, @samp{L} -- темно сине-зеленый, @samp{e} -- желто-зеленый, @samp{E} -- темно желто-зеленый, @samp{n} -- небесно-синий, @samp{N} -- темно небесно-синий, @samp{u} -- сине-фиолетовый, @samp{U} -- темно сине-фиолетовый, @samp{p} -- фиолетовый, @samp{P} -- темно фиолетовый, @samp{q} -- оранжевый, @samp{Q} -- темно оранжевый (коричневый).

Тип пунктира: пробел -- нет линии (для рисования только маркеров), @samp{-} -- сплошная линия (################), @samp{|} -- пунктир (########________), @samp{;} -- мелкий пунктир (####____####____), @samp{:} -- точки (#___#___#___#___), @samp{j} -- пунктир с точками  (#######____#____), @samp{i} -- мелкий пунктир с точками (###__#__###__#__).

Типы маркеров: @samp{o} -- окружность, @samp{+} -- крест, @samp{x} -- косой крест, @samp{s} - квадрат, @samp{d} - ромб, @samp{.} -- точка, @samp{^} -- треугольник вверх, @samp{v} -- треугольник вниз. Если в строке присутствует символ @samp{#}, то используются символы с заполнением.

@float
@image{png/sample5, 7cm}
@caption{Стили линий и маркеров.}
@end float

На конце и в начале линии можно выводить специальный символ (стрелку), если в строке указать один из символов: @samp{A} -- стрелка наружу, @samp{V} -- стрелка внутрь, @samp{I} -- поперечная черта, @samp{K} -- стрелка с чертой, @samp{T} -- треугольник, @samp{S} -- квадрат, @samp{D} -- ромб, @samp{O} -- круг, @samp{_} -- нет стрелки (по умолчанию). При этом действует следующее правило: первый символ определяет стрелку на конце линии, второй символ -- стрелку в начале линии. Например, @samp{r-A} -- красная сплошная линия со стрелкой на конце, @samp{b|AI} -- синий пунктир со стрелкой на конце и чертой вначале, @samp{_O} -- линия с текущим стилем и кружком вначале. Эти стили действуют и при построении графиков (например, @ref{Plot}).

@float
@image{png/sampled, 7cm}
@caption{Стили стрелок.}
@end float

@node Цветовая схема, Стиль текста, Стиль линий, Основные принципы
@subsection Цветовая схема

@cindex Цветовая схема

Цветовая схема используется для определения цвета поверхностей, линий уровня и пр. Цветовая схема задается строкой @emph{s}, которая содержит символы цвета (@pxref{Line styles}) или символы @samp{d#:|}. Символ @samp{d} указывает на определение цвета в зависимости от положения точки в пространстве, а не по амплитуде данных. Символ @samp{#} переключает рисование поверхности на сетчатое (для трехмерных поверхностей) или включает рисование сетки на поверхности. Символ @samp{|} отключает интерполяцию цвета в цветовой схеме. Это может быть полезно для ``резких'' цветов, например, при рисовании матриц. Если в строке встречается символ @samp{:}, то он принудительно заканчивает разбор строки для стиля поверхности. После этого символа могут идти описание стиля текста или оси вращения кривой/линий уровня. Цветовая схема может содержать до 32 значений цвета.

В цветовой схеме можно использовать тональные (``подсвеченные'') цвета (@emph{не в стиле линий!}). Тональный цвет задается двумя символами: первый -- обычный цвет, второй -- его яркость цифрой. Цифра может быть в диапазоне @samp{1}...@samp{9}. При этом @samp{5} соответствует нормальному цвету, @samp{1} -- очень темная версия цвета (почти черный), @samp{9} -- очень светлая версия цвета (почти белый). Например цветовая схема может быть @samp{b2b7wr7r2}.

@float
@image{png/colors, 7cm}
@caption{Цвета и их идентификаторы.}
@end float

При определении цвета по @emph{амплитуде} (наиболее часто используется) окончательный цвет определяется путем линейной интерполяции массива цветов. Массив цветов формируется из цветов, указанных в строке спецификации. Аргумент -- амплитуда, нормированная между @var{Cmin} -- @var{Cmax} (@pxref{Ranges (bounding box)}). Например, строка из 4 символов @samp{bcyr} соответствует изменению цвета от синего (минимальное значение) через голубой и желтый (промежуточные значения) к красному (максимальное значение). Строка @samp{kw} соответствует изменению цвета от черного (минимальное значение) к белому (максимальное значение). Строка из одного символоа (например, @samp{g}) соответствует однотонному цвету (в данному случае зеленому).

Есть несколько полезных цветовых схем. Строка @samp{kw} дает обычную серую (черно-белую) схему, когда большие значения светлее. Строка @samp{wk} представляет обратную серую схему, когда большие значения темнее. Строки @samp{kRryw}, @samp{kGgw}, @samp{kBbcw} представляют собой хорошо известные схемы @emph{hot}, @emph{summer} и @emph{winter}. Строки @samp{BbwrR} и @samp{bBkRr} позволяют рисовать двухцветные фигуры на белом или черном фоне, когда отрицательные значения показаны синим цветом, а положительные -- красным. Строка @samp{BbcyrR} дает цветовую схему, близкую к хорошо известной схеме @emph{jet}.

Примеры наиболее популярных цветовых схем:
@table @samp
@item kw
@image{png_static/kw}
@item wk
@image{png_static/wk}
@item hHCcw
@image{png_static/kHCcw}

@item kRryw
@image{png_static/kRryw}
@item kGgew
@image{png_static/kGgew}
@item kBbcw
@image{png_static/kBbcw}

@item BbwrR
@image{png_static/BbwrR}
@item BbwgG
@image{png_static/BbwgG}
@item GgwmM
@image{png_static/GgwmM}

@item bcwyr
@image{png_static/bcwyr}
@item QqwcC
@image{png_static/QqwcC}
@item CcwyY
@image{png_static/CcwyY}

@item BbcyrR
@image{png_static/BbcyrR}
@item BbcwyrR
@image{png_static/BbcwyrR}
@item bwr
@image{png_static/bwr}

@item bcyr
@image{png_static/bcyr}
@item bgr
@image{png_static/bgr}
@item BbcyrR|
@image{png_static/sharp}
@end table

При определении цвета по @emph{положению точки в пространстве} окончательный цвет определяется по формуле c=x*c[1] + y*c[2] + z*c[3]. Здесь c[1], c[2], c[3] -- первые три цвета в цветовом массиве; x, y, z -- координаты точки, нормированные на @var{Min}x@var{Max}. Такой тип определения цвета полезен, например, при построении поверхностей уровня, когда цвет дает представление о положении точки в пространстве. Например, @pxref{Surf3}.

@node Стиль текста, , Цветовая схема, Основные принципы
@subsection Стиль текста

@cindex Стиль текста

Стиль текста задается строкой, которая может содержать несколько символов: тип шрифта (@samp{ribwou}) и/или выравнивания (@samp{LRC}), а также цвет текста @samp{wkrgbcymhRGBCYMHW} (@pxref{mglColor class}) после символа @samp{:}. Например, @samp{biC:b} соответствует жирному курсиву с выравниванием по центру синего цвета.

Начертания шрифта: @samp{r} -- прямой шрифт, @samp{i} -- курсив, @samp{b} -- жирный. По умолчанию используется прямой шрифт. Типы выравнивания текста: @samp{L} -- по левому краю (по умолчанию), @samp{C} -- по центру, @samp{R} -- по правому краю. Дополнительные эффекты шрифта: @samp{w} -- контурный, @samp{o} -- надчеркнутый, @samp{u} -- подчеркнутый. Синтаксический разбор LaTeX-их команд по умолчанию включен (подробнее см. @pxref{mglFont class} и @ref{Font settings}).

Размер текста может быть задан явно (если @var{size}>0) или относительно базового размера шрифта для рисунка |@var{size}|*@var{FontSize} при @var{size}<0. Значение @var{size}=0 указывает, что соответствующая строка выводиться не будет. Базовый размер шрифта измеряется во внутренних единицах. Специальные функции @code{SetFontSizePT(), SetFontSizeCM(), SetFontSizeIN()} позволяют задавать его в более ``привычных'' единицах.

@node FAQ, Интерфейсы, Основные принципы, Overview
@section FAQ

@table @strong
@item График не рисуется?!
Проверьте, что точки графика находятся внутри ограничивающего параллелепипеда, при необходимости увеличьте его с помощью функции @code{Axis()}. Проверьте, что размерность массива правильная для выбранного типа графика. Убедитесь, что функция  @code{Finish()} была вызвана после построения графика (или график был сохранен в файл). Иногда отражение света от плоских поверхностей (типа, @code{Dens()}) может выглядеть как отсутствие графика.

@item Не нашел нужного графика?!
Многие ``новые'' графики можно строить, используя уже существующие функции. Например, поверхность вращения кривой относительно оси можно построить, используя специальную функцию @code{Torus()}, а можно построить как параметрически заданную поверхность @code{Surf()}. См. также @ref{Hints} и @ref{Examples} MathGL. Если же нужного типа графика все равно нет, то пишите мне @email{mathgl.abalakin@@gmail.com, e-mail} и в следующей версии этот график появится.

@item Требуется ли знание сторонних библиотек (например, OpenGL) для использования библиотеки MathGL?
Нет. Библиотека MathGL самодостаточна и не требует знания сторонних библиотек.

@item На каком языке написана библиотека? Для каких языков у нее есть интерфейсы?
Ядро библиотеки написано на С++. Кроме него, есть интерфейсы для чистого С, фортрана, паскаля, форта и собственный командный язык MGL. Также есть поддержка большого числа интерпретируемых языков (Python, Java,  ALLEGROCL, CHICKEN, Lisp, CFFI, C#, Guile, Lua, Modula 3, Mzscheme, Ocaml, Octave, Perl, PHP, Pike, R, Ruby, Tcl). Эти интерфейсы написаны с помощью SWIG (и функции чистого С и классы). Однако на данный момент только интерфейсы для Python и Octave включены в скрипты сборки. Причина в том, что я не знаю других языков, чтобы проверить качество интерфейса :(. Замечу, что большинство прочих языков могут использовать С функции напрямую.

@item Как мне использовать MathGL с Фортраном?
Библиотеку MathGL можно использовать как есть с компилятором @code{gfortran} поскольку он использует по умолчанию AT&T нотацию для внешних функций. Для других компиляторов (например, Visual Fortran) необходимо включить использование AT&T нотации вручную. AT&T нотация требует, чтобы имя функции завершалось символом @samp{_}, аргументы функции передавались по указателю и длины строк передавались в конце списка аргументов. Например:

@emph{C функция} -- @code{void mgl_fplot(HMGL graph, const char *fy, const char *stl, int n);}

@emph{AT&T функция} -- @code{void mgl_fplot_(uintptr_t *graph, const char *fy, const char *stl, int *n, int ly, int ls);}

@item У меня есть класс Foo и в нем метод рисования Foo::draw(mglGraph *gr). Как мне нарисовать что-то в окне FLTK, GLUT или Qt?
Функции-члены класса в С++ имеют ``скрытый'' параметр -- указатель на экземпляр класса и их прямое использование невозможно. Решением будет определение интерфейсной функции:
@example
int foo_draw(mglGraph *gr, void *par)
@{   ((Foo *)foo)->draw(gr);    @}
@end example
и подстановка именно ее в вызов функции @code{Window()}:
@example
gr->Window(argc,argv,foo_draw,"Title",this);
@end example

Можно также наследовать Ваш класс от класса @code{mglDraw} и использовать функцию типа @code{gr->Window(argc, argv, foo, "Title");}.

@item Как мне вывести текст на русском/испанском/арабском/японском и т.д.?
Стандартный путь состоит в использовании кодировки UTF-8 для вывода текста. Кроме того, все функции вывода текста имеют интерфейс для 8-битных (char *) строк. Однако в последнем случае Вам может потребоваться установить используемую в исходном тексте локаль. Например, для русского языка в кодировке CP1251 можно использовать @code{setlocale(LC_CTYPE, "ru_RU.cp1251");} (под MS Windows имена локали другие --  @code{setlocale(LC_CTYPE, "russian_russia.1251")}). Настоятельно не рекомендую использовать константу @code{LC_ALL}, поскольку при этом меняется и формат чисел (в частности, десятичная точка), что может, например, вызвать сложности (неудобство) при написании формул и чтении текстовых файлов. Например, программа ожидает @samp{,} в качестве разделителя целой и дробной части, а пользователь вводит @samp{.}.

@item Как мне вырезать (исключить из рисования) точку или область на графике?
Есть три основных способа. Во-первых, можно вырезать точку, задав одну из ее координат равной @code{NAN}. Во-вторых, можно воспользоваться функцией @code{SetCutBox()} или @code{CutOff()} для удаления точек из некоторой области (@pxref{Cutting}). Наконец, можно сделать эти точки прозрачными (невидимыми) с помощью функций @code{SurfA()}, @code{Surf3A()} (@pxref{Dual plotting}). В последнем случае обеспечивается еще и плавность включения прозрачности.

@item Я использую VisualStudio, CBuilder или другой компилятор (не MinGW/gcc). Как мне подключить библиотеку MathGL?
Есть 2 пути. Первый -- использовать уже скомпилированные бинарники (*.dll). В этом случае Вам надо подготовить библиотеки для вашего компилятора из *.dll файлов. Команда может выглядеть как-нибудь типа @code{lib.exe /def:libmgl.def}. Но этот путь обеспечит доступ только к чистым функциям С, а не к классам С++. Причина в том, что нет общепринятого стандарта для имен С++ функций/методов в объектных файлах. Такой стандарт принят только для функций С.

Второй путь состоит в компиляции библиотеки из исходных текстов. MathGL имеет внешние зависимости (PNG, GSL, JPEG, FLTK, GLUT, HDF5), но большинство из них опциональные. Часть библиотек можно найти @uref{https://sourceforge.net/project/showfiles.php?group_id=152187&package_id=267177, здесь}. Также Вы можете исключить из проекта соответствующие файлы для выключения поддержки JPEG, TIFF, FLTK, GLUT, HDF5 библиотек. Кроме того, можно определить define @code{NO_GSL} при компиляции для выключения GSL. Однако часть спец. функций в формулах, Фурье преобразования и подбор функции будет недоступен.

Для выключения PNG просто закоментируйте тело функций @code{mgl_pnga_save(), mgl_png_save()} в файле @code{mgl_export.cpp}. После этого MathGL не будет иметь внешних зависимостей. Но в этом случае Вам придется перенаправлять графический вывод в окно (растровой картинкой из mglGraphZB|PS::GetBits() или mglGraphZB|PS::GetRGBA()) или сохранять в несжатый *.bmp файл. Возможность сохранения в векторные EPS, SVG файлы при этом сохранится.

@strong{Наконец!} Пожалуйста @emph{не спрашивайте} меня вопросы про Windows. Я не использую Windows. Я ничего не знаю о Visual Basic, Visual C++, CBuiled или .NET. Найдите подходящие форумы в интернете и задайте свой вопрос там.

@item Сколько человек участвовало в создании библиотеки?
Большую часть библиотеки написал один человек. Это результат примерно года работы на написание ядра библиотеки и базовых функций (в основном вечерами и по выходным). Процесс усовершенствования продолжается и теперь :). Скрипты сборки в основном написаны Д.Кулагиным, а экспорт в IDTF написан М.Видассовым.

@item Как мне показать растровую картинку на рисунке?
Можно импортировать ее в экземпляр @code{mglData} и построить с помощью функции @code{Dens()}. Например, для черно-белого рисунка можно использовать код: @code{mglData bmp; bmp.Import("fname.png","wk"); gr->Dens(bmp,"wk");}.

@item Как использовать MathGL в Qt, FLTK, wxWidgets ...?
Есть специальные классы (виджеты) для этих библиотек: QMathGL для Qt, Fl_MathGL для FLTK и т.д. Если Вы не нашли подходящий класс, то можете создать свой собственный виджет, рисующий растровое изображение из mglGraphAB::GetBits().

@item Как мне создать U3D файл (3D in PDF)?
Процедура состоит из двух шагов: создания файла IDTF и его конвертация в U3D. Можно использовать @uref{http://sourceforge.net/project/showfiles.php?group_id=152187&package_id=300628, U3D tools} для конвертации IDTF в U3D. Ему требуется библиотека @uref{http://libharu.org, libharu} 2.1.0 или более поздняя. Для установки используйте обычную процедуру @code{./bootstrap, ./configure, make, sudo make install}. В результате появится программа IDTFConverter для конвертации файлов *.idtf в бинарные файлы *.u3d. Последние можно включить в PDF.

@item Как сменить шрифт (семейство шрифтов)?
Во-первых, надо загрузить файлы @uref{http://mathgl.sourceforge.net/download.html, отсюда} или @uref{http://sourceforge.net/project/showfiles.php?group_id=152187&package_id=267177, отсюда}. Далее, в экземпляре mglGraph загружаем шрифты: @code{gr->SetFont(new mglFont(fontname,path));}. Здесь @var{fontname} -- базовое имя шрифта, например @samp{STIX}, и @var{path} -- путь к папке с файлами шрифтов. Вызовите @code{gr->SetFont(NULL);} для использования шрифта по умолчанию.

@item Как нарисовать метки оси снаружи от графика?
Просто используйте отрицательные значения длины меток, например @code{gr->SetTickLen(-0.1);}.

@end table

@node Интерфейсы, Благодарности, FAQ, Overview
@section Интерфейсы

Библиотека MathGL имеет интерфейсы к целому ряду языков программирования. Большинство из них базируется на С интерфейсе и построены с помощью инструментария SWIG. Сюда входят Python, Java, Octave, Lisp, C#, Guile, Lua, Modula 3, Ocaml, Perl, PHP, Pike, R, Ruby, Tcl. Кроме того, есть отдельный интерфейс к Фортрану, имеющий похожий набор функций, но со слегка различным типом аргументов (использованы целые вместо указателей). Функции С и Фортран интерфейса помечены [функции С].
@c ++++++++++
Некоторое из языков представленных выше поддерживают объектное программирование (классы). Для них написан собственная оболочка и соответствующие функции/методы помечены (Python). Функции и методы доступные в С++ помечены (С++).
@c ++++++++++
Наконец, специальный командный язык MGL был написан для быстрого доступа к функциям C++ со всеми их возможностями. Скрипты MGL могут быть выполнены как из внешних программ (UDAV, mgl2png, mgl2eps и т.д.) так и из кода на C++/C/Python и пр. (@pxref{mglParse class}). Подробно эти команды описаны в @ref{MGL interface}.

@menu
* C интерфейс::
* Python интерфейс::
@end menu

@node C интерфейс, Python интерфейс, , Интерфейсы
@subsection C интерфейс

C интерфейс является базовым для большинства других интерфейсов. Он содержит функции на чистом C для большинства методов классов MathGL. В отличие от членов-функций C++ классов, C функции в качестве аргументов должны явно иметь переменные типа HMGL (для графики) и/или HMDT (для массивов данных) для указания объекта рисования или данных. Таким образом, первым вызовом пользователя должно быть создание этих объектов с помощью функций @code{mgl_create_*()}, а последним -- их удаление с помощью функций @code{mgl_delete_*()}.

Все функции описанны в заголовочном файле @code{#include <mgl/mgl_c.h>} и используют переменные для идентификаторов объектов рисования/данных следующих типов:
@itemize
@item 
@code{HMGL} --- Указатель на класс @code{mglGraph} (@pxref{MathGL core}).
@item 
@code{HMDT} --- Указатель на класс @code{mglData} (@pxref{mglData class}).
@item 
@code{HMPR} --- Указатель на класс @code{mglParse} (@pxref{mglParse class})..
@end itemize
Эти переменные содержат идентификаторы объектов графики или данных. 

Фортрановские функции имеют те же имена, что и функции C. Однако, есть различие: переменные типов @code{HMGL, HMDT} должны быть объявлены как целые достаточной разрядности (integer*4 на 32-битных системах или integer*8 на 64-битных системах). Все С функции являются процедурами для Фортрана (должны вызываться с помощью оператора call). Исключение составляют функции, возвращающие переменные типа @code{HMGL} или @code{HMDT}. Последние должны быть объявлены целыми  для использования в фортрановском коде. Также помните, что строки в фортране обозначаются одинарной кавычкой @code{'}, а не двойной @code{"} как в С/С++.

@strong{Создание и удаление графического объекта}

@itemize
@item Функции для рисования в памяти:
@deftypefn {C function} @code{HMGL} mgl_create_graph_gl ()
Создает экземпляр класса mglGraphGL.
@end deftypefn
@deftypefn {C function} @code{HMGL} mgl_create_graph_zb (@code{int} width, @code{int} height)
Создает экземпляр класса mglGraphZB с указанными размерами.
@end deftypefn
@deftypefn {C function} @code{HMGL} mgl_create_graph_ps (@code{int} width, @code{int} height)
Создает экземпляр класса mglGraphPS с указанными размерами.
@end deftypefn
@deftypefn {C function} @code{HMGL} mgl_create_graph_idtf ()
Создает экземпляр класса mglGraphIDTF.
@end deftypefn

@item Функции для рисования в окне:
@deftypefn {C function} @code{HMGL} mgl_create_graph_glut (@code{int (*}draw@code{)(HMGL gr, void *p)}, @code{const char *}title, @code{void *}par)
Создает экземпляр класса mglGraphGLUT  и связанное с ним окно. Одновременно может быть открыто только одно окно. Описание аргументов функции см. в @ref{mglGraphAB class}.
@end deftypefn
@deftypefn {C function} @code{HMGL} mgl_create_graph_fltk (@code{int (*}draw@code{)(HMGL gr, void *p)}, @code{const char *}title, @code{void *}par)
Создает экземпляр класса mglGraphFLTK и связанное с ним окно. Одновременно может быть открыто несколько окно. Однако Вы должны вызвать функцию @code{mgl_fltk_run()} для начала обработки сообщений окну. Описание аргументов функции см. в @ref{mglGraphAB class}. Замечу, что параметр @var{draw} может быть равным @code{NULL} для отображения текущей статической картинки (анимация и слайды не доступны).
@end deftypefn
@deftypefn {C function} @code{HMGL} mgl_create_graph_qt (@code{int (*}draw@code{)(HMGL gr, void *p)}, @code{const char *}title, @code{void *}par)
Создает экземпляр класса mglGraphQT и связанное с ним окно. Одновременно может быть открыто несколько окно. Однако Вы должны вызвать функцию @code{mgl_qt_run()} для начала обработки сообщений окну. Описание аргументов функции см. в @ref{mglGraphAB class}. Замечу, что параметр @var{draw} может быть равным @code{NULL} для отображения текущей статической картинки (анимация и слайды не доступны).
@end deftypefn
@deftypefn {C function} @code{void} mgl_fltk_run ()
Запускает цикл обработки сообщений FLTK. Обычно программа завершает функцию main() вызовом @code{return mgl_fltk_run();}.
@end deftypefn
@deftypefn {C function} @code{void} mgl_fltk_thread ()
Запускает цикл обработки сообщений FLTK. В отличие от @code{mgl_fltk_run()} цикл запускается в отдельном потоке, так что основная программа продолжает выполнение сразу.
@end deftypefn
@deftypefn {C function} @code{void} mgl_qt_run ()
Запускает цикл обработки сообщений Qt. Обычно программа завершает функцию main() вызовом @code{return mgl_qt_run();}.
@end deftypefn
@deftypefn {C function} @code{void} mgl_qt_thread ()
Запускает цикл обработки сообщений Qt. В отличие от @code{mgl_qt_run()} цикл запускается в отдельном потоке, так что основная программа продолжает выполнение сразу.
@end deftypefn
@deftypefn {C function} @code{void} mgl_update (@code{HMGL} graph)
Обновляет содержимое экрана.
@end deftypefn

@deftypefn {C function} @code{void} mgl_set_show_mouse_pos (@code{HMGL} graph, @code{int} enable)
Switch to show or not in the widget the last mouse click position.
@end deftypefn
@deftypefn {C function} @code{void} mgl_get_last_mouse_pos (@code{HMGL} graph, @code{float *}x, @code{float *}y, @code{float *}z)
Last position of mouse click.
@end deftypefn
@deftypefn {C function} @code{void} mgl_calc_xyz (@code{HMGL} graph, @code{int} xs, @code{int} ys, @code{float *}x, @code{float *}y, @code{float *}z)
Calculate 3D coordinate @{x,y,z@} for screen point @{xs,ys@}. At this moment it ignore perspective and transformation formulas (curvilinear coordinates). The calculation are done for the last used InPlot (@pxref{Transformation matrix}).
@end deftypefn


@item Functions for data creation:
@deftypefn {C function} @code{HMDT} mgl_create_data ()
Create simple instance of class mglData.
@end deftypefn
@deftypefn {C function} @code{HMDT} mgl_create_data_size (@code{int} nx, @code{int} ny, @code{int} nz)
Create instance of class mglData with specified sizes.
@end deftypefn
@deftypefn {C function} @code{HMDT} mgl_create_data_file (@code{const char *}fname)
Create instance of class mglData and fill it by data from text file.
@end deftypefn

@item Each created object @strong{must} be deleted after usage by functions:
@deftypefn {C function} @code{void} mgl_delete_graph (@code{HMGL} graph)
Delete the instance of class. Must be used after plotting for every created graphical object.
@end deftypefn
@deftypefn {C function} @code{void} mgl_delete_data (@code{HMDT} dat)
Delete the instance of class. Must be used after using for every created data object.
@end deftypefn
@end itemize

@node Python интерфейс, , C интерфейс, Интерфейсы
@subsection Python интерфейс

MathGL provide the interface to a set of languages via SWIG library. Some of these languages support classes. The typical example is Python -- which is denoted in the chapter title.

To use Python classes just execute @samp{import mathgl}. The simplest example will be:
@verbatim
import mathgl
a=mathgl.mglGraph()
a.Box()
a.WritePNG('test.png')
@end verbatim
Alternatively you can import all classes from @code{mathgl} module and easily access MathGL classes: 
@verbatim
from mathgl import *
a=mglGraph()
a.Box()
a.WritePNG('test.png')
@end verbatim
It become useful if you will create many @code{mglData} object, for example.

There are 2 classes in Python interface:
@itemize 
@item @code{mglGraph}
-- provide practically the same functionality as C++ class @code{mglGraph} (@pxref{MathGL core}). But it is not abstract class and it allows one to select at construction stage which plotter (ZB or PS and so on) will be used.
@item @code{mglData}
-- is absolutely the same class as C++ @code{mglData} (@pxref{mglData class}). But an additional feature to acess data values is added. You can use construction like this: @code{dat[i]=sth;} or @code{sth=dat[i]} at this flat representation of data is used (i.e., @var{i} can be in range 0...nx*nx*nz-1. Also you can import NumPy arrays as input arguments: @code{mgl_dat = mglData(numpy_dat);}.
@c @item @code{mglParse} -- practically the same as C++ class @code{MathGL provide the interface to a set of languages via SWIG library. Some of these languages support classes. The typical example is Python -- which is denoted in the chapter title.

To use Python classes just execute @samp{import mathgl}. The simplest example will be:
@verbatim
import mathgl
a=mathgl.mglGraph()
a.Box()
a.WritePNG('test.png')
@end verbatim
Alternatively you can import all classes from @code{mathgl} module and easily access MathGL classes: 
@verbatim
from mathgl import *
a=mglGraph()
a.Box()
a.WritePNG('test.png')
@end verbatim
It become useful if you will create many @code{mglData} object, for example.

There are 2 classes in Python interface:
@itemize 
@item @code{mglGraph}
-- provide practically the same functionality as C++ class @code{mglGraph} (@pxref{MathGL core}). But it is not abstract class and it allows one to select at construction stage which plotter (ZB or PS and so on) will be used.
@item @code{mglData}
-- is absolutely the same class as C++ @code{mglData} (@pxref{mglData class}). But an additional feature to acess data values is added. You can use construction like this: @code{dat[i]=sth;} or @code{sth=dat[i]} at this flat representation of data is used (i.e., @var{i} can be in range 0...nx*nx*nz-1.
@c @item @code{mglParse} -- practically the same as C++ class @code{mglParse} (@pxref{mglParse class}).
@end itemize

There is main difference from C++ classes -- Python class @code{mglGraph} don't have variables (options). All corresponding features are moved to methods.
The core of MathGL Python class is @strong{mglGraph} class. It contains a lot of plotting functions for 1D, 2D and 3D plots. So most of sections is describe its methods. Its constructor have following arguments:

@defop Constructor {mglGraph (Python)} @code{} mglGraph (@code{int} kind=@code{0}, @code{int} width=@code{600}, @code{int} height=@code{400})
Create the instance of class mglGraph with specified sizes @var{width} and @var{height}. Parameter @var{type} may have following values: @samp{0} -- use @code{mglGraphZB} plotter (default), @samp{1} -- use @code{mglGraphPS} plotter, @samp{2} -- use @code{mglGraphGL} plotter, @samp{3} -- use @code{mglGraphIDTF} plotter.
@end defop
@end itemize

There is main difference from C++ classes -- Python class @code{mglGraph} don't have variables (options). All corresponding features are moved to methods. The core of MathGL Python class is @strong{mglGraph} class. It contains a lot of plotting functions for 1D, 2D and 3D plots. So most of sections is describe its methods. Its constructor have following arguments:

@defop Constructor {mglGraph (Python)} @code{} mglGraph (@code{int} kind=@code{0}, @code{int} width=@code{600}, @code{int} height=@code{400})
Create the instance of class mglGraph with specified sizes @var{width} and @var{height}. Parameter @var{type} may have following values: @samp{0} -- use @code{mglGraphZB} plotter (default), @samp{1} -- use @code{mglGraphPS} plotter, @samp{2} -- use @code{mglGraphGL} plotter, @samp{3} -- use @code{mglGraphIDTF} plotter.
@end defop


@node Благодарности, , Интерфейсы, Overview
@section Благодарности

@itemize @bullet
@item
My special thanks to Marina Balakina for the patience during library writing and for the help in documentation writing and spelling.
@item
I'm thankful to D. Kulagin and S.M. Plis for making Debian packages.
@item
I'm thankful to M. Vidassov for the help in handling solid UTF-8 fonts.
@item
I'm thankful to N. Troickiy and V. Lipatov for making RPM packages.
@item
I'm thankful to S. Skobelev, A. Korotkevich, V. Onuchin, S.M. Plis, R. Kiselev, A. Ivanov, M. Vidiassov and V. Lipatov for fruitful comments.
@end itemize
