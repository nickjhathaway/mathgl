@c ------------------------------------------------------------------
@chapter Язык MGL

MathGL имеет встроенный скриптовый язык MGL для обработки и отображения данных. Скрипты MGL можно использовать как независимо (программами UDAV, mgl2png, mgl2eps, mgl2svg и пр., @pxref{Utilities}) так и вызовами библиотеки.

Язык MGL достаточно простой. Каждая строка -- отдельная команда. Первое слово -- имя команды, а все остальные ее аргументы. Команда может иметь до 1000 аргументов (по крайней мере сейчас). Слова разделяются одно от другого пробелом или символом табуляции. Различий между верхним и нижним индексом нет, т.е. переменные @var{a} и @var{A} идентичны. Символ @samp{#} начинает комментарий -- все символы после него игнорируются до конца строки. Исключением является случай, когда @samp{#} входит в строку. Опции команды указываются после символа @samp{;} (@pxref{Command options @MGL{}}). Символ @samp{:} начинает новую команду (подобно переводу строки) если он расположен не внутри скобок или строки.

Если строка содержит ссылки на внешние параметры (@samp{$0}, @samp{$1} ... @samp{$9}), то текущие значения параметров подставляются в строку вместо ссылки до выполнением команды. Это позволяет использовать один и тот же скрипт при различных входных параметрах командной строки или вводить макроопределения по ходу исполнения команд скрипта.

Аргументы команды могут быть строками, переменными или числами. 
@itemize @bullet
@item 
Строка -- произвольный набор символов между метками @samp{'}.

@item 
Обычно переменная имеет имя, состоящее из букв и чисел (должно начинаться с буквы и не быть длиннее 64 символов). В качестве переменной можно использовать временные массивы, включающие в себя:
@itemize @bullet
@item 
срезы (``подмассивы'') массивов данных (подобно команде @ref{subdata}). Например, @code{a(1)} или @code{a(1,:)} или @code{a(1,:,:)} -- вторая строка массива @var{a}, @code{a(:,2)} или @code{a(:,2,:)} -- третий столбец, @code{a(:,:,0)} -- первый срез и т.д. Также можно выделить часть массива с m-го по n-ый элемент @code{a(m:n,:,:)} или просто @code{a(m:n)}.

@item 
произвольные комбинации столбцов данных (например, @code{a('n*w^2/exp(t)')}), если столбцы данных были именованы командой @ref{idset} или в файле данных (в строке начинающейся с @code{##}).

@item 
произвольное выражение из существующих переменных и констант. Например, @samp{sqrt(dat(:,5)+1)} даст временный массив данных с элементами равными @code{tmp[i,j] = sqrt(dat[i,5,j]+1)}.

@item 
массивы с элементами заданными в квадратных скобках [], разделенные @samp{,}. При этом внутри выражения не должно быть пробелов! Например, @samp{[1,2,3]} даст временный массив из 3 элементов @{1, 2, 3@}; @samp{[[11,12],[21,22]]} даст матрицу 2*2 и т.д. Элементами такой конструкции могут быть и массивы если их размерности одинаковые, например @samp{[v1,v2,...,vn]}.

@item 
результат команд построения новых данных (@pxref{Make another data}), если они заключены в фигурные скобки @{@}. Например, @samp{@{sum dat 'x'@}} даст временный массив, который есть результат суммирования @var{dat} вдоль 'x'. Это такой же массив как и @var{tmp}, полученный командой @samp{sum tmp dat 'x'}. При этом можно использовать вложенные конструкции, например @samp{@{sum @{max dat 'z'@} 'x'@}}.
@end itemize
Временные массивы не могут стоять в качестве первого аргумента команд, создающих массивы (например, @samp{new}, @samp{read}, @samp{hist} и т.д.).

@item 
К скалярным переменным, кроме собственно чисел, относятся: специальные переменные @code{nan=#QNAN, pi=3.1415926..., on=1, off=0, :=-1}, переменные с суффиксами (@pxref{Suffixes}), переменные определенные командой @ref{define}. Также массивы размером 1x1x1 считаются скалярами (например, @samp{pi/dat.nx}).
@end itemize
Перед первым использованием все переменные должны быть определены с помощью команд, создающих массивы (@ref{new}, @ref{var}, @ref{list}, @ref{copy}, @ref{read}, @ref{hist}, @ref{sum} и др., @pxref{Data create @MGL{}} и @ref{Make another data @MGL{}}). 

Команды могут иметь несколько наборов аргументов (например, @code{plot ydat} и @code{plot xdat ydat}). Все аргументы команды для выбранного набора должны быть указаны, однако часть из них могут иметь значения по умолчанию. Такие аргументы в описании команд будут помещены в квадратные скобки [], например @code{plot ydat ['stl'='' zval=nan]}. При этом запись @code{[arg1 arg2 arg3 ...]} подразумевает @code{[arg1 [arg2 [arg3 ...]]]}, т.е. опускать можно только аргументы с конца, если вы согласны с их значениями по умолчанию. Например, @code{plot ydat '' 1} или @code{plot ydat ''} правильно, а @code{plot ydat 1} не правильно (аргумент @code{'stl'} пропущен).

Все команды MGL можно разделить на несколько групп. В дальнейшем будет использованы следующие обозначения при описании команд: имя команды выделено жирным, строки заключены в одинарные кавычки '', переменные выделены курсивом, числа (скаляры) выделены моноширинным шрифтом. Необязательные аргументы будут помещены в квадратные скобки [] и показаны их значения по умолчанию. Подробную информацию о цвете и стиле линий (@pxref{Line styles}), цветовых схемах (@pxref{Color scheme}), стиле текста и символах TeX (@pxref{Font styles}), текстовых формулах (@pxref{Textual formulas}) можно найти в соответствующих разделах.

@menu
@ifset UDAV
* General concepts::             
@end ifset
* Graphics setup @MGL{}::        
* Axis settings @MGL{}::         
* Transformation matrix @MGL{}::  
* Export to file @MGL{}::        
* Primitives drawing @MGL{}::    
* Text printing @MGL{}::         
* Axis and Colorbar @MGL{}::     
* Legend @MGL{}::                
* 1D plotting @MGL{}::           
* 2D plotting @MGL{}::           
* 3D plotting @MGL{}::           
* Dual plotting @MGL{}::         
* Vector fields @MGL{}::         
* Other plotting @MGL{}::        
* Nonlinear fitting @MGL{}::     
* Data create @MGL{}::           
* Data filling @MGL{}::          
* Rearrange data @MGL{}::        
* File I/O @MGL{}::              
* Make another data @MGL{}::     
* Commands on direction @MGL{}::  
* Operators @MGL{}::             
* Program flow @MGL{}::          
* Command options @MGL{}::       
* Suffixes::                    
* Utilities::                   
@end menu

@c ##################################################################
@ifset UDAV
@node  General concepts, , Utilities, MGL interface
@section Основные принципы

Возможности библиотеки MathGL довольно богаты -- число только основных типов графиков превышает 50 видов. Кроме того, есть функции для обработки данных, настройки вида графика и пр. и пр. Тем не менее, я старался придерживаться единого стиля в порядке аргументов функций и способе их ``настройки''. В основном все ниже сказанное относится к функциям рисования различных графиков.

Всего основных концепций (базисных идей) четыре:
@enumerate
@item
@strong{Все настройки графиков (стиль линий, цветовые схемы поверхностей, стиль и цвет текста) задаются строками.} Это обеспечивает: удобство для пользователя -- короткую строку легче читать и здесь тяжелее ошибиться, чем в большом списке параметров; переносимость -- строки выглядят одинаково на всех платформах и не надо заботиться о типе и числе аргументов.
@item
@strong{Все функции имеют ``упрощенный'' и ``продвинутый'' варианты.} Сделано опять из-за удобства. В ``упрощенном'' варианте для построения графика нужны только один-два массив(а) данных, которые автоматически равнораспределяются в заданном диапазоне осей координат. В ``продвинутой'' версии можно не только указать явно диапазон построения графика, но и задать его параметрически. Последнее позволяет легко строить довольно сложные кривые и поверхности. В обоих вариантах функций порядок аргументов стандартен: сначала идут массивы данных, потом необязательный строковый параметр стиля графика, а далее -- второстепенные необязательные параметры для более точной настройки графика.
@item
@strong{Все элементы рисунков векторные.} Изначально библиотека MathGL была ориентированна на работу с научными данными, которые по своей природе векторные (линии, грани, матрицы и т.д.). Поэтому векторность используется во всех рисунках! Причем иногда даже в ущерб производительности (например, при выводе шрифтов). Помимо всего прочего, векторность позволяет легко масштабировать рисунок -- измените размер картинки в 2 раза, и рисунок пропорционально растянется.
@item
@strong{Новые графики не удаляют уже нарисованное.} Этот, в чем-то неожиданный, подход позволяет создавать огромное количество ``комбинированных'' графиков. Например, поверхность с наложенными линиями уровня строится двумя последовательными вызовами функций рисования поверхности и линий уровня (в любом порядке). И совершенно не надо писать специальную функцию (как в Matlab и некоторых других программах) для рисования этого графика. Примеров таких графиков можно привести множество (см. раздел @ref{Hints} и сайт программы @uref{http://mathgl.sf.net/index.html}).
@end enumerate

Кроме основных концепций я хотел бы остановиться на нескольких, как оказалось, нетривиальных моментах -- способе указания положения графика, осей координат и строковых параметров линий, поверхностей, текста.

@menu
* Coordinate axes::             
* Line styles::                 
* Color scheme::                
* Font styles::                  
* Textual formulas::            
@end menu

@include concept_ru.texi

@node Graphics setup @MGL{}, Axis settings @MGL{}, General concepts, MGL interface
@end ifset
@ifclear UDAV

@c ##################################################################
@node Graphics setup @MGL{}, Axis settings @MGL{}, , MGL interface
@end ifclear
@section Настройка графика @MGL{}

Команды в этой группе влияют на вид всего рисунка. Соответственно они должны располагаться @emph{перед} вызовом функций непосредственно рисующих графики.

@menu
* Transparency @MGL{}::          
* Lighting @MGL{}::              
* Fog @MGL{}::                   
* Default sizes @MGL{}::         
* Zooming @MGL{}::               
* Cutting @MGL{}::               
* Other settings @MGL{}::        
@end menu

@c ==================================================================
@node Transparency @MGL{}, Lighting @MGL{}, , Graphics setup @MGL{}
@subsection Прозрачность @MGL{}

Эти команды настраивают тип и степень прозрачности поверхностей. Главной является функция @ref{alpha}, которая включает/выключает прозрачность для всех графиков, созданных после вызова @ref{alpha}. Функция @ref{alphadef} устанавливает величину alpha-канала по умолчанию. Прозрачность можно выключить для отдельного графика с помощью @ref{transparent}. Наконец, функция @ref{transptype} задает тип прозрачности. @sref{Transparent surface sample}

@cindex alpha
@anchor{alpha}
@deffn {MGL command} alpha @code{[val=on]}
Включает/выключает прозрачность для @emph{всего} рисунка. По умолчанию прозрачность выключена. Используйте @code{transparent off} для конкретного графика для выключения прозрачности.
@end deffn
@cindex alphadef
@anchor{alphadef}
@deffn {MGL command} alphadef @code{val}
Задает значение прозрачности по умолчанию для всех графиков. Начальное значение 0.5.
@end deffn
@cindex transparent
@anchor{transparent}
@deffn {MGL command} transparent @code{val}
Временно включает/возвращает прозрачность графиков.
@end deffn
@cindex transptype
@anchor{transptype}
@deffn {MGL command} transptype @code{val}
Задает тип прозрачности. Обычная прозрачность (@samp{0}) -- "закрытые" объекты видны меньше чем закрывающие. "Стеклянная" прозрачность (@samp{1}) -- закрытые и закрывающие объекты единообразно ослабляют интенсивность света (по RGB каналам). "Ламповая" прозрачность (@samp{2}) -- закрытые и закрывающие объекты являются источниками дополнительного освещения (рекомендую установить @code{alphadef 0.3} или меньше в этом случае).
@end deffn

@c ==================================================================
@node Lighting @MGL{}, Fog @MGL{}, Transparency @MGL{}, Graphics setup @MGL{}
@subsection Освещение @MGL{}

Эти функции настраивают освещение графика. Главная функция @ref{light} включает/выключает освещение графиков построенных после ее вызова. MathGL  поддерживает до 10 независимых источников света. Положение, цвет, яркость каждого источника света можно задавать по отдельности. По умолчанию включен только первый (с порядковым номером @code{0}) источник света белого цвета, расположенный сверху.

@cindex light
@anchor{light}
@deffn {MGL command} light @code{[val=on]}
Включает/выключает освещение графика. По умолчанию освещение выключено.
@end deffn
@deffn {MGL command} light @code{n val}
Включает/выключает @var{n}-ый источник света.
@end deffn

@deffn {MGL command} light @code{n xpos ypos zpos} ['col'='w' @code{br=0.5}]
Добавляет источник света с номером @var{n} в положение @{@var{xpos}, @var{ypos}, @var{zpos}@} с цветом @var{col} и яркостью @var{br}, которая должна быть в диапазоне [0,1].
@end deffn

@cindex ambient
@anchor{ambient}
@deffn {MGL command} ambient @code{val}
Задает яркость рассеянного освещения. Значение должно быть в диапазоне [0,1].
@end deffn

@c ==================================================================
@node Fog @MGL{}, Default sizes @MGL{}, Lighting @MGL{}, Graphics setup @MGL{}
@subsection Туман @MGL{}

@cindex fog
@anchor{fog}
@deffn {MGL command} fog @code{val [dz=0.25]}
Имитирует туман на графике. Туман начинается на относительном расстоянии @var{dz} от точки обзора и его плотность растет экспоненциально вглубь по закону ~@math{1-exp(-d*z)}. Здесь @emph{z} -- нормализованная на 1 глубина графика. Если @var{d}=@code{0} то туман отсутствует. @sref{Surface in fog sample}
@end deffn

@c ==================================================================
@node Default sizes @MGL{}, Zooming @MGL{}, Fog @MGL{}, Graphics setup @MGL{}
@subsection Базовые размеры @MGL{}

Эти команды задают величины большинства параметров графика, включая размеры маркеров, стрелок, толщину линий и т.д. Как и любые другие настройки, они подействуют только на графики созданные после изменения настроек.

@cindex barwidth
@anchor{barwidth}
@deffn {MGL command} barwidth @code{val}
Относительный размер прямоугольников в @code{bars, barh, boxplot}. Значение по умолчанию @code{0.7}.
@end deffn

@cindex marksize
@anchor{marksize}
@deffn {MGL command} marksize @code{val}
Размер маркеров для @ref{1D plotting}. Значение по умолчанию @code{1}.
@end deffn

@cindex arrowsize
@anchor{arrowsize}
@deffn {MGL command} arrowsize @code{val}
Размер стрелок для @ref{1D plotting}, линий и кривых (@pxref{Primitives drawing}). Значение по умолчанию @code{1}.
@end deffn

@cindex linewidth
@anchor{linewidth}
@deffn {MGL command} linewidth @code{val}
Базовая толщина линий. Значения <1 игнорируются. Для значений >1 реальная толщина получается перемножением указанной ширины линии на данное значение. Увеличение ширины линии актуально для больших растровых рисунков. Значение по умолчанию @code{1}.
@end deffn

@cindex ticklen
@anchor{ticklen}
@deffn {MGL command} ticklen @code{val} [@code{stt=1}]
Относительная длина меток осей координат. Значение по умолчанию @code{0.1}. Параметр @var{stt}>0 задает относительную длину подметок, которые в @code{sqrt(1+stt)} раз меньше.
@end deffn

@cindex tickstl
@anchor{tickstl}
@deffn {MGL command} tickstl 'stl' ['sub'='']
Стиль меток (@var{stl}) и подметок (@var{sub}) осей координат. Если @code{stl=''}, то используется стиль по умолчанию (@samp{k} или @samp{w} в зависимости от типа прозрачности). Если @code{sub=''}, то используется стиль меток (т.е. @var{stl}).
@end deffn

@c ==================================================================
@node Zooming @MGL{}, Cutting @MGL{}, Default sizes @MGL{}, Graphics setup @MGL{}
@subsection Масштабирование @MGL{}

Эти команды управляют масштабированием всего рисунка (@ref{zoom}) или отдельной картинки (@ref{plotfactor}). Обычно эти функции используются для удаления пустого места вокруг графиков.

@cindex plotfactor
@anchor{plotfactor}
@deffn {MGL command} plotfactor @code{val}
Масштаб картинки (значение должно быть больше 1). Не рекомендуется устанавливать значения меньше 1.5. Это аналог @ref{zoom}, но применяется только к конкретной картинке, заданной @ref{inplot}. Используйте ноль для включения автоматического масштабирования.
@end deffn

@cindex zoom
@anchor{zoom}
@deffn {MGL command} zoom @code{x1 y1 x2 y2}
Масштабирует весь рисунок. После вызова функции текущий график будет очищен и в дальнейшем рисунок будет содержать только область [x1,x2]*[y1,y2] от исходного рисунка. Координаты @var{x1}, @var{x2}, @var{y1}, @var{y2} меняются в диапазоне от 0 до 1. Внимание! эти настройки не могут быть переписаны никакими другими функциями. Используйте @code{zoom 0 0 1 1} для перехода в масштаб по умолчанию.
@end deffn

@c ==================================================================
@node Cutting @MGL{}, Other settings @MGL{}, Zooming @MGL{}, Graphics setup @MGL{}
@subsection Обрезание @MGL{}

Эти команды задают условия когда точка будет исключена (вырезана) из рисования. Замечу, что все точки со значением(-ями) @code{nan} по одной из координат или амплитуде автоматически исключаются из рисования.

@cindex cut
@anchor{cut}
@deffn {MGL command} cut @code{val}
Задает обрезание точек за пределами осей координат. Если @code{on} то такие точки исключаются из рисования (это по умолчанию) иначе они проецируются на ограничивающий прямоугольник.
@end deffn

@deffn {MGL command} cut @code{x1 y1 z1 x2 y2 z2}
Задает границы параллелепипеда внутри которого точки не рисуются. Если границы одинаковы (переменные равны), то параллелепипеда считается пустым. @sref{CutMinMax sample}
@end deffn

@deffn {MGL command} cut 'cond'
Задает условие обрезания по формуле @var{cond}. Это условие исключает точки из рисования если результат вычисления формулы не равен нулю. Установите аргумент @code{''} для выключения условия обрезания. @sref{CutOff sample}
@end deffn

@c ==================================================================
@node Other settings @MGL{}, , Cutting @MGL{}, Graphics setup @MGL{}
@subsection Прочие настройки @MGL{}

@cindex font
@anchor{font}
@deffn {MGL command} font 'fnt' [@code{val=6}]
Задает стиль и размер шрифта (@pxref{Text printing}). Вначале используется @samp{rC} -- прямой шрифт с выравниванием по центру. По умолчанию размер подписей оси координат в 1.4 раза больше.
@end deffn

@cindex rotatetext
@anchor{rotatetext}
@deffn {MGL command} rotatetext @code{val}
Включает/выключает вращение меток и подписей осей координат вдоль оси. Начальное значение @code{on}.
@end deffn

@cindex palette
@anchor{palette}
@deffn {MGL command} palette 'colors'
Задает палитру как последовательность цветов. Значение по умолчанию @code{"Hbgrcmyhlnqeup"}, что соответствует цветам: темно серый @samp{H}, синий @samp{b}, зеленый @samp{g}, красный @samp{r}, голубой @samp{c}, малиновый @samp{m}, желтый @samp{y}, серый @samp{h}, сине-зеленый  @samp{l}, небесно-голубой @samp{n}, оранжевый @samp{q}, желто-зеленый @samp{e}, сине-фиолетовый @samp{u}, фиолетовый @samp{p}. Палитра в основном используется в 1D графиках (@pxref{1D plotting}) для кривых с неопределенным стилем линии.
@end deffn

@cindex meshnum
@anchor{meshnum}
@deffn {MGL command} meshnum @code{num}
Задает ориентировочное число линий в @ref{mesh}, @ref{fall}, @ref{grid}, число стрелок (штрихов) в @ref{vect}, @ref{dew} и число ячеек в @ref{cloud}. По умолчанию (=0) рисуются все линии, стрелки, ячейки.
@end deffn

@cindex axialdir
@anchor{axialdir}
@deffn {MGL command} axialdir 'dir'
Задает ось вращения для @ref{axial}, @ref{torus}. По умолчанию это 'z'.
@end deffn

@c ==================================================================
@node Axis settings @MGL{}, Transformation matrix @MGL{}, Graphics setup @MGL{}, MGL interface
@section Параметры осей координат @MGL{}

Этот большой набор команд определяет вид осей и меток координат. Перед построением для каждой точки выполняются 3 преобразования: сначала определяется возможность рисования точки (@pxref{Cutting @MGL{}}), далее применяются формулы перехода к криволинейным координатам и наконец точка отображается.

@cindex axis
@anchor{axis}
@deffn {MGL command} axis @code{x1 y1 x2 y2}
@deffnx {MGL command} axis @code{x1 y1 z1 x2 y2 z2}
@cindex ranges
@anchor{ranges}
@deffnx {MGL command} ranges @code{x1 x2 y1 y2 [z1=0 z2=0]}
Задает диапазон изменения координат. Если минимальное и максимальное значение координаты равны, то они игнорируются по данному направлению. Также устанавливает размер цветовой шкалы, аналогично команде  @code{caxis z1 z2}. Начальные диапазоны равны [-1, 1].
@end deffn

@deffn {MGL command} axis 'fx' 'fy' ['fz'='' 'fa'='']
Задает формулы перехода к криволинейным координатам. Каждая строка является математическим выражением, зависящим от старых координат @samp{x}, @samp{y}, @samp{z} и @samp{a} или @samp{c} для цветовой шкалы. Например, для цилиндрических координат будет @code{axis 'x*cos(y)' 'x*sin(y)' 'z'}. Для удаления формул соответствующий параметр должен быть пустым @code{''}. Использование формул преобразования слегка замедляет программу, т.е.. @code{axis '' '' ''} быстрее чем @code{axis '1*x' '1*y' '1*z'}. Параметр @var{fa} задает аналогичную формулу для цветовой шкалы. @xref{Textual formulas}.
@end deffn

@deffn {MGL command} axis @code{how}
Устанавливает одну из предопределенных систем криволинейных координат в зависимости от параметра @var{how}: @samp{0} -- декартова система (нет преобразования координат, наиболее быстрая); @samp{1} -- полярные координаты @math{x_n=x*cos(y),y_n=x*sin(y), z_n=z}; @samp{2} -- сферические координаты @math{x_n=x*sin(y)*cos(z), y_n=x*sin(y)*sin(z), z_n=x*cos(y)}; @samp{3} -- параболические координаты @math{x_n=x*y, y_n=(x*x-y*y)/2, z_n=z}; @samp{4} -- Paraboloidal coordinates @math{x_n=(x*x-y*y)*cos(z)/2, y_n=(x*x-y*y)*sin(z)/2, z_n=x*y}; @samp{5} -- Oblate coordinates @math{x_n=cosh(x)*cos(y)*cos(z), y_n=cosh(x)*cos(y)*sin(z), z_n=sinh(x)*sin(y)}; @samp{6} -- Prolate coordinates @math{x_n=sinh(x)*sin(y)*cos(z), y_n=sinh(x)*sin(y)*sin(z), z_n=cosh(x)*cos(y)}; @samp{7} -- эллиптические координаты @math{x_n=cosh(x)*cos(y), y_n=sinh(x)*sin(y), z_n=z}; @samp{8} -- тороидальные координаты @math{x_n=sinh(x)*cos(z)/(cosh(x)-cos(y)), y_n=sinh(x)*sin(z)/(cosh(x)-cos(y)), z_n=sin(y)/(cosh(x)-cos(y))}; @samp{9} -- бисферические координаты @math{x_n=sin(y)*cos(z)/(cosh(x)-cos(y)), y_n=sin(y)*sin(z)/(cosh(x)-cos(y)), z_n=sinh(x)/(cosh(x)-cos(y))}; @samp{10} -- биполярные координаты @math{x_n=sinh(x)/(cosh(x)-cos(y)), y_n=sin(y)/(cosh(x)-cos(y)), z_n=z}.
@end deffn

@cindex caxis
@anchor{caxis}
@deffn {MGL command} caxis @code{z1 z2}
Задает масштаб цветовой шкалы (c-координаты). Эти значения используются для определения цвета поверхностей и прочих 2D и 3D графиков. Начальный диапазон равен [-1, 1].
@end deffn

@cindex origin
@anchor{origin}
@deffn {MGL command} origin @code{x0 y0 [z0=nan]}
Задает центр пересечения осей координат. Если одно из значений равно @code{nan}, то выбрается оптимальное положение осей координат по этому направлению.
@end deffn

@cindex ternary
@anchor{ternary}
@deffn {MGL command} ternary @code{val}
Задает рисование треугольных (Ternary) осей координат. Это специальный тип графика для 3 зависимых координат (компонент) @var{a}, @var{b}, @var{c} таких, что @var{a}+@var{b}+@var{c}=1. MathGL использует только 2 независимые координаты @var{a}=x и @var{b}=y поскольку их достаточно для построения всех графиков. При этом третья координата z является независимым параметром для построения линий уровня, поверхностей и т.д. @sref{Ternary plot sample}
@end deffn

@cindex xrange
@anchor{xrange}
@deffn {MGL command} xrange dat [@code{add=off fact=0}]
@cindex yrange
@anchor{yrange}
@deffnx {MGL command} yrange dat [@code{add=off fact=0}]
@cindex zrange
@anchor{zrange}
@deffnx {MGL command} zrange dat [@code{add=off fact=0}]
@cindex crange
@anchor{crange}
@deffnx {MGL command} crange dat [@code{add=off fact=0}]
Задает диапазон изменения x-,y-,z-,c- координат как минимальное и максимальное значение массива @var{dat}. Параметр @var{add} указывает добавлять новый диапазон к существующему или заменять его. Параметр @var{fact} дополнительно расширяет диапазон на величину (@var{Max}-@var{Min})*@var{fact}.
@end deffn

@deffn {MGL command} xrange @code{x1 x2}
@deffnx {MGL command} yrange @code{x1 x2}
@deffnx {MGL command} zrange @code{x1 x2}
@deffnx {MGL command} crange @code{x1 x2}
Задает диапазон изменения x-,y-,z-,c- координат. См. также @ref{axis}.
@end deffn

@cindex xtick
@anchor{xtick}
@deffn {MGL command} xtick @code{val [sub=0 org=nan]}
@cindex ytick
@anchor{ytick}
@deffnx {MGL command} ytick @code{val [sub=0 org=nan]}
@cindex ztick
@anchor{ztick}
@deffnx {MGL command} ztick @code{val [sub=0 org=nan]}
@cindex ctick
@anchor{ctick}
@deffnx {MGL command} ctick @code{val}
Задает шаг меток осей @var{val}, число подметок @var{ns} и начальное положение меток @var{org}. Переменная @var{val} задает шаг меток (если положительна) или их число на оси (если отрицательна). Нулевое значение задает логарифмические метки. Если @var{org}=@code{NAN}, то используется значение из @ref{origin}.
@end deffn

@deffn {MGL command} xtick 'templ'
@deffnx {MGL command} ytick 'templ'
@deffnx {MGL command} ztick 'templ'
@deffnx {MGL command} ctick 'templ'
Задает шаблоны для меток вдоль x-,y-,z-оси или colorbar. Шаблон может содержать и символы TeX. Если @var{xtt}, @var{ytt}, @var{ztt}, @var{ctt}=@code{''}, то используется шаблон по умолчанию (в простейшем случае @samp{%.2g}). Установка шаблона выключает автоматическое улучшение вида меток.
@end deffn

@deffn {MGL command} xtick @code{val1} 'lbl1' [@code{val2} 'lbl2' ...]
@deffnx {MGL command} ytick @code{val1} 'lbl1' [@code{val2} 'lbl2' ...]
@deffnx {MGL command} ztick @code{val1} 'lbl1' [@code{val2} 'lbl2' ...]
Задает явное положение @var{val} и подписи @var{lbl} для меток вдоль оси. Метки могут содержать и символы TeX.
@end deffn

@cindex adjust
@anchor{adjust}
@deffn {MGL command} adjust ['dir'='xyzc']
Автоматически задает шаг меток осей, число подметок и начальное положение меток для осей координат @var{dir} в виде наиболее удобном для человека.
@end deffn


@c ##################################################################
@node Transformation matrix @MGL{}, Export to file @MGL{}, Axis settings @MGL{}, MGL interface
@section Матрица преобразования @MGL{}

Эти команды контролируют где и как график будет расположен. Существует определенный порядок вызова этих функций для лучшего вида графика. Вначале должны вызываться команды @ref{subplot} или @ref{inplot} для указания местоположения вывода. После них -- команды вращения @ref{rotate} и сжатия @ref{aspect}. И наконец любые другие функции для рисования графика. Вместо вращения графика можно вызвать команды @ref{columnplot} для расположения графиков в столбец одного над другим или @ref{stickplot} для расположения в линейку.

@cindex subplot
@anchor{subplot}
@deffn {MGL command} subplot @code{nx ny m [dx=0 dy=0]}
Помещает последующий вывод в @var{m}-ую ячейку сетки размером @var{nx}*@var{ny} от всего рисунка. Функция сбрасывает матрицу трансформации (повороты и сжатие графика) и должна вызываться первой для создания "подграфика". С эстетической точки зрения не рекомендуется вызывать эту функцию с различными (или не кратными) размерами сетки. Ячейка может быть дополнительно сдвинута относительно своего обычного положения на относительный размер @var{dx}, @var{dy}.
@end deffn

@deffn {MGL command} subplot @code{nx ny m} 'style'
Аналогично предыдущему, но место для осей/colorbar резервируется только если строка @var{style} содержит: @samp{L} или @samp{<} -- с левого края, @samp{R} или @samp{>} -- с правого края, @samp{A} или @samp{^} -- с верхнего края, @samp{U} или @samp{_} -- с нижнего края.
@end deffn

@cindex inplot
@anchor{inplot}
@deffn {MGL command} inplot @code{x1 x2 y1 y2 [rel=off]}
Помещает последующий вывод в прямоугольную область [@var{x1}, @var{x2}]*[@var{y1}, @var{y2}] (исходный размер [0,1]*[0,1]). Эта функция позволяет поместить график в произвольную область рисунка. Если параметр @var{rel}=@code{on}, то используется позиция относительно текщего @ref{subplot} (или @ref{inplot} с @var{rel}=@code{off}). Функция сбрасывает матрицу трансформации (повороты и сжатие графика) и должна вызываться первой для создания "подграфика".
@end deffn

@cindex columnplot
@anchor{columnplot}
@deffn {MGL command} columnplot @code{num ind [d=0]}
Помещает последующий вывод в @var{ind}-ую строку столбца из @var{num} строк. Положение столбца выбирается относительно последнего вызова @ref{subplot} (или @ref{inplot} с @var{rel}=@code{off}). Параметр @var{d} задает дополнительный зазор между строк. @sref{ColumnPlot sample}
@end deffn

@cindex stickplot
@anchor{stickplot}
@deffn {MGL command} stickplot @code{num ind tet phi}
Помещает последующий вывод в @var{ind}-ую ячейку "бруска" из @var{num} ячеек. При этом сам брусок повернут на углы @var{tet}, @var{phi}. Положение выбирается относительно последнего вызова @ref{subplot} (или @ref{inplot} с @var{rel}=@code{off}). @sref{StickPlot sample}
@end deffn

@cindex rotate
@anchor{rotate}
@deffn {MGL command} rotate @code{tetz tetx [tety=0]}
Вращает систему координат относительно осей @{x, z, y@} последовательно на углы @var{tetx}, @var{tetz}, @var{tety}.
@end deffn

@deffn {MGL command} rotate @code{tet x y z}
Вращает систему координат относительно вектора @{@var{x}, @var{y}, @var{z}@} на угол @var{tet}.
@end deffn

@cindex aspect
@anchor{aspect}
@deffn {MGL command} aspect @code{ax ay [az=1]}
Устанавливает соотношение размеров осей в отношении @var{ax:ay:az}. Для лучшего вида следует вызывать после функции @ref{rotate}.
@end deffn

@cindex perspective
@anchor{perspective}
@deffn {MGL command} perspective @code{val}
Добавляет (включает) перспективу для графика. Параметр @math{val ~ 1/z_@{eff@} \in [0,1)}. По умолчанию (@code{val=0}) перспектива отключена.
@end deffn

@c ##################################################################
@node Export to file @MGL{}, Primitives drawing @MGL{}, Transformation matrix @MGL{}, MGL interface
@section Экспорт в файл @MGL{}

@cindex write
@anchor{write}
@deffn {MGL command} write 'fname' [@code{solid=off}]
Экспортирует текущий кадр в файл 'fname' (тип определяется по расширению). Параметр @var{solid} задает вывод картинки на текущем фоне (обычно белом) или полупрозрачной. Если 'fname'='', то используется имя @samp{frame####.jpg}, где @samp{####} -- текущий номер кадра.
@end deffn

@cindex setsize
@anchor{setsize}
@deffn {MGL command} setsize @code{w h}
Изменяет размер картинки в пикселях. Функция должна вызываться @strong{перед} любыми функциями построения потому что полностью очищает содержимое рисунка. В некоторых программах исполнение этой команды может запрещено.
@end deffn


@c ##################################################################
@node Primitives drawing @MGL{}, Text printing @MGL{}, Export to file @MGL{}, MGL interface
@section Рисование примитивов

Эти команды рисуют рисуют простые объекты типа линий, точек, сфер, капель, конусов, и т.д.

@cindex clf
@anchor{clf}
@deffn {MGL command} clf
Очищает рисунок и заполняет его цветом по умолчанию (обычно белым). 
@end deffn

@cindex ball
@anchor{ball}
@deffn {MGL command} ball @code{x y} ['col'='r']
@deffnx {MGL command} ball @code{x y z} ['col'='r']
Рисует точку (шарик) с координатами @{@var{x}, @var{y}, @var{z}@} и цветом @var{col}.
@end deffn

@cindex line
@anchor{line}
@deffn {MGL command} line @code{x1 y1 x2 y2} ['stl'='']
@deffnx {MGL command} line @code{x1 y1 z1 x2 y2 z2} ['stl'='']
Рисует геодезическую линию (декартовых координатах -- прямую) из точки @{@var{x1},@var{y1},@var{z1}@} в @{@var{x2},@var{y2},@var{z2}@} использую стиль линии @var{stl}. Кривая рисуется даже если часть ее лежит вне диапазона осей координат.
@end deffn

@cindex curve
@anchor{curve}
@deffn {MGL command} curve @code{x1 y1 dx1 dy1 x2 y2 dx2 dy2} ['stl'='']
@deffnx {MGL command} curve @code{x1 y1 z1 dx1 dy1 dz1 x2 y2 z2 dx2 dy2 dz2} ['stl'='']
Рисует кривую Безье из точки @{@var{x1},@var{y1},@var{z1}@} в @{@var{x2},@var{y2},@var{z2}@} использую стиль линии @var{stl}. Касательные в точках пропорциональны @{@var{dx1},@var{dy1},@var{dz1}@}, @{@var{dx2},@var{dy2},@var{dz2}@}. Кривая рисуется даже если часть ее лежит вне диапазона осей координат.
@end deffn

@cindex facex
@anchor{facex}
@deffn {MGL command} facex @code{x0 y0 z0 wy wz} ['stl'='' @code{d1=0 d2=0}]
@cindex facey
@anchor{facey}
@deffnx {MGL command} facey @code{x0 y0 z0 wx wz} ['stl'='' @code{d1=0 d2=0}]
@cindex facez
@anchor{facez}
@deffnx {MGL command} facez @code{x0 y0 z0 wx wy} ['stl'='' @code{d1=0 d2=0}]
Рисует закрашенный прямоугольник (грань) перпендикулярно оси [x,y,z] в точке @{@var{x0}, @var{y0}, @var{z0}@} цветом @var{stl} и шириной @var{wx}, @var{wy}, @var{wz} вдоль соответствующего направления. При этом цвет может быть один для всей грани, или различным для разных вершин если указаны все 4 цвета (полезно для градиента цвета, например @samp{wwrr}). Параметры @var{d1}!=0, @var{d2}!=0 задают дополнительный сдвиг последней точки (т.е. рисуют четырехугольник). Грань будет нарисована даже если часть ее лежит вне диапазона осей координат.
@end deffn

@cindex sphere
@anchor{sphere}
@deffn {MGL command} sphere @code{x0 y0 r} ['col'='r']
@deffnx {MGL command} sphere @code{x0 y0 z0 r} ['col'='r']
Рисует сферу радиуса @var{r} с центром в точке @{@var{x}, @var{y}, @var{z}@} цветом @var{stl}.
@end deffn

@cindex drop
@anchor{drop}
@deffn {MGL command} drop @code{x0 y0 dx dy r} ['col'='b' @code{sh=1 asp=1}]
@deffnx {MGL command} drop @code{x0 y0 z0 dx dy dz r} ['col'='b' @code{sh=1 asp=1}]
Рисует каплю радиуса @var{r} в точке @{@var{x0},@var{y0},@var{z0}@} вытянутую вдоль направления @{@var{dx},@var{dy},@var{dz}@} цветом @var{col}. Параметр @var{sh} определяет степень вытянутости: @samp{0} -- сфера, @samp{1} -- классическая капля. Параметр @var{asp} определяет относительную ширину капли (аналог "эллиптичности" для сферы). @sref{Drops sample}
@end deffn

@cindex cone
@anchor{cone}
@deffn {MGL command} cone @code{x1 y1 z1 x2 y2 z2 r1} [@code{r2=-1} 'stl'='' @code{edge=off}]
Рисует трубу (или усеченный конус если @var{edge}=@code{off}) между точками @{@var{x1},@var{y1},@var{z1}@}, @{@var{x2},@var{y2},@var{z2}@} с радиусами на концах @var{r1}, @var{r2}. Если @var{r2}<0, то полагается @var{r2}=@var{r1}. Цвет конуса задается строкой @var{stl}.
@end deffn

@cindex rect
@anchor{rect}
@deffn {MGL command} rect @code{x1 y1 x2 y2} ['st'='']
@deffnx {MGL command} rect @code{x1 y1 z1 x2 y2 z2} ['st'='']
Рисует закрашенный прямоугольник (грань) с противоположными вершинами в точках @{@var{x1},@var{y1},@var{z1}@}, @{@var{x2},@var{y2},@var{z2}@} цветом @var{stl}. При этом цвет может быть один для всей грани, или различным для разных вершин если указаны все 4 цвета (полезно для градиента цвета, например @samp{wwrr}). Грань будет нарисована даже если часть ее лежит вне диапазона осей координат.
@end deffn

@c ##################################################################
@node Text printing @MGL{}, Axis and Colorbar @MGL{}, Primitives drawing @MGL{}, MGL interface
@section Вывод текста @MGL{}

Команды для вывода текста позволяют вывести строку текста в произвольном месте рисунка, в произвольном направлении и вдоль произвольной кривой. Можно использовать произвольное начертание шрифта и многие ТеХ-ие команды (детальнее @pxref{Font styles}). Аргумент @var{size} определяет размер текста: размер шрифта если положителен или относительный размер (=-@var{size}*@var{fontsize}) если отрицателен.

Параметры шрифта задаются строкой, которая может содержать символы стиля (@samp{rbiwou}) и/или выравнивания (@samp{LRC}). Также строка может содержать символы цвета @samp{wkrgbcymhRGBCYMHW} (@pxref{Line styles}) после символа @samp{:}. Стили шрифта: @samp{r} -- прямой, @samp{i} -- курсив, @samp{b} -- жирный, @samp{w} -- контурный, @samp{o} -- надчеркнутый, @samp{u} -- подчеркнутый. По умолчанию используется прямой шрифт. Типы выравнивания: @samp{L} -- по левому краю (по умолчанию), @samp{C} -- по центру, @samp{R} -- по правому краю. Например, строка @samp{iC:b} соответствует курсиву синего цвета с выравниванием по центру. По умолчанию используются параметры, определенные командой @ref{font}.

Если строка содержит символы @samp{aA}, то текст выводится в абсолютных координатах (полагаются в диапазоне [0,1]). При этом используются координаты относительно рисунка (если указано @samp{A}) или относительно последнего @ref{subplot}/@ref{inplot} (если указано @samp{a}).

@cindex text
@anchor{text}
@deffn {MGL command} text @code{x y} 'text' ['fnt'='' @code{size=-1.4}]
@deffnx {MGL command} text @code{x y z} 'text' ['fnt'='' @code{size=-1.4}]
Выводит строку @var{text} от точки @{@var{x},@var{y},@var{z}@} шрифтом @var{fnt} и размером @var{size}.
@end deffn

@deffn {MGL command} text @code{x y dx dy} 'text' [@code{size=-1.4}]
@deffnx {MGL command} text @code{x y z dx dy dz} 'text' [@code{size=-1.4}]
Выводит строку @var{text} от точки @{@var{x},@var{y},@var{z}@} вдоль направления @{@var{dx},@var{dy},@var{dz}@} шрифтом @var{fnt} и размером @var{size}.
@end deffn

@deffn {MGL command} text ydat 'text' ['fnt'='' @code{size=-1 zval=nan}]
@deffnx {MGL command} text xdat ydat 'text' ['fnt'='' @code{size=-1 zval=nan}]
@deffnx {MGL command} text xdat ydat zdat 'text' ['fnt'='' @code{size=-1}]
Выводит строку @var{text} вдоль кривой @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@} шрифтом @var{font}. Строка @var{font} может содержать символы: @samp{t} для вывода текста под кривой (по умолчанию), или @samp{T} для вывода текста над кривой. Если массив @var{xdat} не указан, то используется массив со значениями равно распределенными вдоль оси x. Если массив @var{zdat} не указан, то используется @var{zdat}[i] = @var{zval}. @sref{Text sample}
@end deffn

@cindex title
@anchor{title}
@deffn {MGL command} title 'text' ['fnt'='' @code{size=-2}]
Выводит строку @var{text} как заголовок (сверху рисунка). Может использоваться в любом месте (даже внутри @ref{subplot}).
@end deffn

@cindex fgets
@anchor{fgets}
@deffn {MGL command} fgets @code{x y} 'fname' [@code{n=0} 'fnt'='' @code{size=-1.4}]
@deffnx {MGL command} fgets @code{x y z} 'fname' [@code{n=0} 'fnt'='' @code{size=-1.4}]
Выводит @var{n}-ую строку файла @var{fname} от точки @{@var{x},@var{y},@var{z}@} шрифтом @var{fnt} и размером @var{size}.
@end deffn


@c ##################################################################
@node Axis and Colorbar @MGL{}, Legend @MGL{}, Text printing @MGL{}, MGL interface
@section Оси и Colorbar @MGL{}

Эти команды рисуют объекты для "измерения" типа осей координат, цветовой таблицы (colorbar), сетку по осям, обрамляющий параллелепипед и подписи по осям координат. См. также @ref{Axis settings @MGL{}}.

@cindex axis
@c @anchor{}
@deffn {MGL command} axis ['dir'='xyz' @code{adjust=off}]
Рисует оси координат и метки на них (@pxref{Axis settings @MGL{}}) в направлениях, указанных строкой @var{dir}. Если строка содержит символ @samp{_}, то подписи меток отображаться не будут. Шрифт подписей определяется командой @ref{font}. Метки будут "подогнаны" если @var{adjust}=@code{on} (с помощью вызова @code{adjust 'dir'}). 
@end deffn

@cindex colorbar
@anchor{colorbar}
@deffn {MGL command} colorbar ['sch'='' @code{pos=0}]
Рисует полосу соответствия цвета и числовых значений (colorbar) для цветовой схемы @var{sch} (используется текущая для @code{sch=''}) с краю от графика. Параметр @var{pos} задает местоположение: @samp{0} - справа (по умолчанию), @samp{1} - слева, @samp{2} - сверху, @samp{3} - снизу. Если строка @var{sch} содержит @samp{<>^_}, то параметр @var{pos} определяется как: @code{pos=0} для @samp{>} (справа), @code{pos=1} для @samp{<} (слева), @code{pos=2} для @samp{^} (сверху), @code{pos=3} для @samp{_} (снизу). Если строка содержит @samp{A}, то используются абсолютные координаты (относительно рисунка). @sref{Dens sample}
@end deffn

@deffn {MGL command} colorbar vdat ['sch'='' @code{pos=0}]
Аналогично предыдущему, но для цветовой схемы без сглаживания с заданными значениями @var{vdat}. @sref{ContD sample}
@end deffn

@deffn {MGL command} colorbar 'sch' @code{pos x y w h}
Аналогично первому, но в произвольном месте графика @{@var{x}, @var{y}@} (полагаются в диапазоне [0,1]). Параметры @var{w}, @var{h} задают относительную ширину и высоту colorbar.
@end deffn

@cindex grid
@anchor{grid}
@deffn {MGL command} grid ['dir'='xyz' 'pen'='B']
Рисует линии сетки в направлениях перпендикулярным @var{dir}. Шаг сетки такой же как у меток осей координат. Стиль линий задается параметром @var{pen} (по умолчанию -- сплошная темно синяя линия @samp{B-}).
@end deffn

@cindex box
@anchor{box}
@deffn {MGL command} box ['stl'='k' @code{ticks=on}]
Рисует ограничивающий параллелепипед цветом 'stl'. При @code{ticks=on} рисуются метки в соответствии с текущими настройками осей координат @ref{axis}.
@end deffn

@cindex xlabel
@anchor{xlabel}
@deffn {MGL command} xlabel 'text' [@code{pos=0 size=-1.4 shift=0}]
@cindex ylabel
@anchor{ylabel}
@deffnx {MGL command} ylabel 'text' [@code{pos=0 size=-1.4 shift=0}]
@cindex zlabel
@anchor{zlabel}
@deffnx {MGL command} zlabel 'text' [@code{pos=0 size=-1.4 shift=0}]
@cindex tlabel
@anchor{tlabel}
@deffnx {MGL command} tlabel 'text' [@code{pos=0 size=-1.4 shift=0}]
Выводит подпись @var{text} для x-,y-,z-,t-оси (где @samp{t} -- ``тернарная'' ось @math{t=1-x-y}). Параметр @var{pos} задает положение подписи: при @var{pos}=0 -- по центру оси, при @var{pos}>0 -- около максимальных значений, при @var{pos}<0 -- около минимальных значений. Параметр @var{size} задает размер шрифта (по умолчанию в 1.4 раза больше чем у меток). @xref{Text printing @MGL{}}.
@end deffn

@c ##################################################################
@node Legend @MGL{}, 1D plotting @MGL{}, Axis and Colorbar @MGL{}, MGL interface
@section Легенда @MGL{}

Эти команды обеспечивают рисование легенды графика (полезно для @ref{1D plotting}). Запись в легенде состоит из двух строк: одна для стиля линии и маркеров, другая с текстом описания (с включенным разбором TeX-их команд), накапливаемые во внутренние массивы с помощью команды @ref{addlegend} или опции @ref{legend}. Положение легенды можно задать автоматически или вручную. Параметры @var{font} и @var{size} задают стиль и размер шрифта. Параметр @var{llen} задает относительную ширину примера линии. Ели стиль линии пустой, то соответствующий текст печатается без отступа. Если строка @var{font} содержит символ @samp{A}, то координаты легенды считаются относительно картинки (а не текущего subplot). @sref{Legend sample}

@cindex legend
@anchor{legend}
@deffn {MGL command} legend [@code{pos=3} 'fnt'='rL' @code{size=-1 llen=0.1}]
Рисует легенду из накопленных записей шрифтом @var{fnt} размером @var{size}. Параметр @var{pos} задает положение легенды: @samp{0} -- в нижнем левом углу, @samp{1} -- нижнем правом углу, @samp{2} -- верхнем левом углу, @samp{3} -- верхнем правом углу (по умолчанию).
@end deffn

@deffn {MGL command} legend @code{x y} ['fnt'='rL' @code{size=-1 llen=0.1}]
Рисует легенду из накопленных записей шрифтом @var{font} размером @var{size}. Положение легенды задается параметрами @var{x}, @var{y}, которые полагаются нормированными в диапазоне [0,1].
@end deffn

@cindex addlegend
@anchor{addlegend}
@deffn {MGL command} addlegend 'text' 'stl'
Добавляет описание @var{text} кривой со стилем @var{stl} (@pxref{Line styles}) во внутренний массив записей легенды. Максимальное число записей 100.
@end deffn

@cindex clearlegend
@anchor{clearlegend}
@deffn {MGL command} clearlegend
Очищает внутренний массив записей легенды.
@end deffn

@cindex legendbox
@anchor{legendbox}
@deffn {MGL command} legendbox @code{val}
Включает/выключает рисование прямоугольника вокруг легенды. По умолчанию (=@code{on}) прямоугольник рисуется.
@end deffn

@cindex legendmarks
@anchor{legendmarks}
@deffn {MGL command} legendmarks @code{val}
Задает число маркеров в легенде. По умолчанию используется 1 маркер.
@end deffn

@c ##################################################################
@node 1D plotting @MGL{}, 2D plotting @MGL{}, Legend @MGL{}, MGL interface
@section 1D графики @MGL{}

Эти команды строят графики для одномерных (1D) массивов. Одномерными считаются массивы, зависящие только от одного параметра (индекса) подобно кривой в параметрической форме @{x(i),y(i),z(i)@}, i=1...n. Есть 5 основных типов 1D графиков: линия (@ref{plot}), линия с заполнением (@ref{area}), ступеньки (@ref{step}), прямоугольники (@ref{bars}, @ref{barh}) и вертикальные линии (@ref{stem}). Все эти типы графиков имеют похожий интерфейс. Есть версии для рисования в пространстве и на плоскости. В последнем случае имеется возможность использования только одного массива. Стиль линии и маркеров указывается строковой переменной. Если она равна @code{''}. Кроме того, есть еще несколько типов графиков для одномерных массивов, имеющих другой интерфейс и вид: поверхность вращения кривой (@ref{torus}), диаграмма (@ref{chart}), размер ошибки (@ref{error}), маркеры переменного размера (@ref{mark}), трубками (@ref{tube}) и т.д.

График рисуется для каждой строки если один из массивов матрица. Размер по 1-ой координате @strong{должен быть одинаков} для всех массивов @code{xdat.nx=ydat.nx=zdat.nx}. Если массив @var{xdat} не указан, то используется массив со значениями равно распределенными вдоль оси x. Если массив @var{zdat} не указан, то используется @var{zdat}[i] = @var{zval}. Строка @var{stl} задает цвет и стиль линии и маркеров (@pxref{Line styles}). По умолчанию (@code{stl=''}) рисуется сплошная линия с текущим цветом из палитры.

@cindex plot
@anchor{plot}
@deffn {MGL command} plot ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} plot xdat ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} plot xdat ydat zdat ['stl'='']
Рисует ломанную линию между точками @{@var{x}[i], @var{y}[i], @var{z}[i]@}. См. также @ref{area}, @ref{step}, @ref{stem}, @ref{tube}, @ref{mark}, @ref{error}, @ref{belt}, @ref{tens}. @sref{Plot sample}
@end deffn


@cindex radar
@anchor{radar}
@deffn {MGL command} radar adat ['stl'='' @code{r=-1}]
Рисует radar chart, представляющий собой ломанную с вершинами на радиальных линиях (типа ломанной в полярных координатах). График рисуется для каждой строки если один из массивов матрица. Параметр @var{r} задает дополнительный сдвиг данных (т.е. используется @var{a}+@var{r} вместо @var{a}). Если @code{r<0}, то @code{r=max(0, -min(a)}. Если @var{stl} содержит символ @samp{#}, то также рисуется "сетка" (радиальные линии и круг для @var{r}). См. также @ref{plot}. @sref{Radar sample}
@end deffn

@cindex tens
@anchor{tens}
@deffn {MGL command} tens ydat cdat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} tens xdat ydat cdat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} tens xdat ydat zdat cdat ['stl'='']
Рисует ломанную линию по точкам @{@var{x}[i], @var{y}[i], @var{z}[i]@} с цветом, определяемым массивом @var{c}[i] (типа графика натяжений). См. также @ref{plot}, @ref{mesh}, @ref{fall}. @sref{Tens sample}
@end deffn

@cindex area
@anchor{area}
@deffn {MGL command} area ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} area xdat ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} area xdat ydat zdat ['stl'='']
Рисует ломанную линию по точками @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@} и закрашивает ее вниз до плоскости осей координат. Можно использовать градиентное закрашивание если число указанных цветов в @var{stl} равно удвоенному числу кривых для построения. Если строка содержит символ @samp{a}, то линии рисуются одна поверх другой (с суммированием) -- того же эффекта можно достичь вызовом @code{cumsum ydat 'y'} перед построением графика. См. также @ref{plot}, @ref{bars}, @ref{stem}, @ref{region}. @sref{Area sample}
@end deffn

@cindex region
@anchor{region}
@deffn {MGL command} region fdat gdat ['stl'='' @code{inside=off}]
@deffnx {MGL command} region xdat fdat gdat ['stl'='' @code{inside=off}]
Закрашивает область между 2 кривыми @{@var{xdat}[i], @var{fdat}[i]@} и @{@var{xdat}[i], @var{gdat}[i]@}. При  @code{inside=off} закрашивается только область y1<y<y2, в противном случае также будет закращена область y2<y<y1. Можно использовать градиентное закрашивание если число указанных цветов @var{stl} равно удвоенному числу кривых для построения. См. также @ref{area}, @ref{bars}, @ref{stem}. @sref{Region sample}
@end deffn

@cindex stem
@anchor{stem}
@deffn {MGL command} stem ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} stem xdat ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} stem xdat ydat zdat ['stl'='']
Рисует вертикальные линии из точек @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@} до плоскости осей координат. См. также @ref{area}, @ref{bars}, @ref{plot}, @ref{mark}. @sref{Stem sample}
@end deffn

@cindex bars
@anchor{bars}
@deffn {MGL command} bars ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} bars xdat ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} bars xdat ydat zdat ['stl'='']
Рисует вертикальные полосы (прямоугольники) из точек @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@} до плоскости осей координат. Если строка @var{stl} содержит символ @samp{a}, то линии рисуются одна поверх другой. Если строка содержит символ @samp{f}, то рисуется график типа waterfall для определения кумулятивного эффекта последовательности положительных и отрицательных значений. Можно использовать разные цвета для положительных и отрицательных значений если число указанных цветов равно удвоенному числу кривых для построения. См. также @ref{barh}, @ref{area}, @ref{stem}, @ref{chart}. @sref{Bars sample}
@end deffn

@cindex barh
@anchor{barh}
@deffn {MGL command} barh xdat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} barh ydat xdat ['stl'='' @code{zval=nan}]
Рисует горизонтальные полосы (прямоугольники) из точек @{@var{xdat}[i], @var{ydat}[i]@} до плоскости оси y. Если массив @var{ydat} не указан, то используется массив со значениями равно распределенными вдоль оси y. Если строка @var{stl} содержит символ @samp{a}, то линии рисуются одна поверх другой. Если строка содержит символ @samp{f}, то рисуется график типа waterfall для определения кумулятивного эффекта последовательности положительных и отрицательных значений. Можно использовать разные цвета для положительных и отрицательных значений если число указанных цветов равно удвоенному числу кривых для построения. См. также @ref{bars}. @sref{Barh sample}
@end deffn

@cindex chart
@anchor{chart}
@deffn {MGL command} chart adat ['col'='']
Рисует цветные полосы (пояса) для массива данных @var{adat}. Число полос равно числу строк @var{adat} (равно @var{a.ny}). Цвет полос поочередно меняется из цветов указанных в @var{col} или в палитре (если @code{col=''}). Пробел в цветах соответствует прозрачному "цвету", т.е. соответствующая полоса не рисуется. Ширина полосы пропорциональна значению элемента в @var{adat}. График строится только для массивов не содержащих отрицательных значений. Если строка @var{col} содержит @samp{#}, то рисуется также черная граница полос. График выглядит лучше в 3d (после вращения системы координат) и/или в полярной системе координат (становится Pie chart). @sref{Chart sample}
@end deffn

@cindex step
@anchor{step}
@deffn {MGL command} step ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} step xdat ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} step xdat ydat zdat ['stl'='']
Рисует ступеньки для точек массива @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. См. также @ref{plot}, @ref{stem}, @ref{tile}, @ref{boxs}. @sref{Step sample}
@end deffn

@cindex torus
@anchor{torus}
@deffn {MGL command} torus zdat ['stl'='']
@deffnx {MGL command} torus rdat zdat ['stl'='']
Рисует поверхность вращения кривой @{@var{rdat}[i], @var{zdat}[i], @var{zdat}[i]@} относительно оси @ref{axialdir}. Если массив @var{rdat} не указан, то используется массив со значениями равно распределенными вдоль оси x. См. также @ref{plot}, @ref{axial}. @sref{Torus sample}
@end deffn

@cindex tube
@anchor{tube}
@deffn {MGL command} tube ydat rdat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} tube ydat @code{rval} ['stl'='' @code{zval=nan}]
@deffnx {MGL command} tube xdat ydat rdat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} tube xdat ydat @code{rval} ['stl'='' @code{zval=nan}]
@deffnx {MGL command} tube xdat ydat zdat rdat ['stl'='']
@deffnx {MGL command} tube xdat ydat zdat @code{rval} ['stl'='']
Рисует трубу радиуса @var{rdat}[i] (or @var{rval}) вдоль кривой между точками @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. См. также @ref{plot}. @sref{Tube sample}
@end deffn

@cindex mark
@anchor{mark}
@deffn {MGL command} mark ydat rdat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} mark xdat ydat rdat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} mark xdat ydat zdat rdat ['stl'='']
Рисует маркеры размером @var{rdat}[i]*@code{marksize} в точках @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. Для рисования маркеров одинакового размера можно использовать функцию @code{plot} с невидимой линией (со стилем содержащим @samp{ }). См. также @ref{plot}, @ref{textmark}, @ref{stem}, @ref{error}. @sref{Mark sample}
@end deffn

@cindex textmark
@anchor{textmark}
@deffn {MGL command} textmark ydat 'txt' ['stl'='' @code{zval=nan}]
@deffnx {MGL command} textmark ydat rdat 'txt' ['stl'='' @code{zval=nan}]
@deffnx {MGL command} textmark xdat ydat rdat 'txt' ['stl'='' @code{zval=nan}]
@deffnx {MGL command} textmark xdat ydat zdat rdat 'txt' ['stl'='']
Рисует текст @var{txt} как маркер с размером пропорциональным @var{rdat}[i]*@code{marksize} в точках @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. Если массив @var{rdat} не указан, то полагается @var{rdat}[i] = 1. См. также @ref{plot}, @ref{mark}, @ref{stem}. @sref{TextMark sample}
@end deffn

@cindex error
@anchor{error}
@deffn {MGL command} error ydat yerr ['stl'='' @code{zval=nan}]
@deffnx {MGL command} error xdat ydat yerr ['stl'='' @code{zval=nan}]
@deffnx {MGL command} error xdat ydat xerr yerr ['stl'='' @code{zval=nan}]
Рисует размер ошибки @{@var{xerr}[i], @var{yerr}[i]@} в точках @{@var{xdat}[i], @var{ydat}[i]@} на плоскости @var{z} = @var{zval}. Такой график полезен для отображения ошибки эксперимента, вычислений и пр. См. также @ref{plot}. @sref{Error sample}
@end deffn

@cindex boxplot
@anchor{boxplot}
@deffn {MGL command} boxplot adat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} boxplot xdat adat ['stl'='' @code{zval=nan}]
Рисует boxplot (называемый также как box-and-whisker diagram или как "ящик с усами") в точках @var{xdat}[i] на плоскости @var{z} = @var{zval}. Это график, компактно изображающий распределение вероятностей @var{adat}[i,j] (минимум, нижний квартиль (Q1), медиана (Q2), верхний квартиль (Q3) и максимум) вдоль второго (j-го) направления. См. также @ref{plot}, @ref{error}, @ref{bars}. @sref{BoxPlot sample}
@end deffn

@c ##################################################################
@node 2D plotting @MGL{}, 3D plotting @MGL{}, 1D plotting @MGL{}, MGL interface
@section 2D графики @MGL{}

Эти команды строят графики для двумерных (2D) массивов. Двумерными считаются массивы, зависящие только от двух параметров (индексов) подобно матрице @math{f(x_i,y_j), i=1...n, j=1...m}. Есть несколько основных типов 2D графиков: сплошная поверхность (@ref{surf}), сетчатая поверхность (@ref{mesh}), поверхность из ящиков (@ref{boxs}), поверхность из плиток (@ref{tile}), водопад (@ref{fall}), ленточки (@ref{belt}), график плотности (@ref{dens}), линии уровня (@ref{cont}), линии уровня с заполнением (@ref{contf}) и результат их вращения (@ref{axial}). В функциях @ref{cont}, @ref{contf} и @ref{axial} значения уровней можно задавать автоматически и вручную. Можно также нарисовать сетку (@ref{grid}) по массиву данных для улучшения вида графика плотности или линий уровня. Каждый тип графика имеет похожий интерфейс. Есть версия для рисования одного массива с автоматическими координатами и версия для параметрически заданной поверхности.

Строка @var{sch} задает цветовую схему (@pxref{Color scheme}. Предыдущая цветовая схема используется по умолчанию. Младшие размерности массивов @var{xdat}, @var{ydat}, @var{zdat} должны быть одинаковы @code{xdat.nx=zdat.nx && ydat.nx=zdat.ny} или @code{xdat.nx=ydat.nx=zdat.nx && xdat.ny=ydat.ny=zdat.ny}. Массивы @var{xdat} и @var{ydat} могут быть векторами (не матрицами как @var{zdat}). Если массивы @var{xdat}, @var{ydat} не указаны, то используются массивы со значениями равно распределенными вдоль осей x, y. График строится для каждого z среза данных.

@cindex surf
@anchor{surf}
@deffn {MGL command} surf zdat ['sch'='']
@deffnx {MGL command} surf xdat ydat zdat ['sch'='']
Рисует параметрически заданную поверхность @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. Если @var{sch} содержит @samp{#}, то на поверхности рисуется сетка. См. также @ref{mesh}, @ref{dens}, @ref{belt}, @ref{tile}, @ref{boxs}, @ref{surfc}, @ref{surfa}. @sref{Surf sample}
@end deffn

@cindex mesh
@anchor{mesh}
@deffn {MGL command} mesh zdat ['sch'='']
@deffnx {MGL command} mesh xdat ydat zdat ['sch'='']
Рисует сетчатую поверхность, заданную параметрически @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. См. также @ref{surf}, @ref{fall}, @ref{meshnum}, @ref{cont}, @ref{tens}. @sref{Mesh sample}
@end deffn

@cindex fall
@anchor{fall}
@deffn {MGL command} fall zdat ['sch'='']
@deffnx {MGL command} fall xdat ydat zdat ['sch'='']
Рисует водопад для параметрически заданной поверхности @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. График удобен для построения нескольких кривых, сдвинутых вглубь друг относительно друга. Если @var{sch} содержит @samp{x}, то линии рисуются вдоль x-оси (по умолчанию линии рисуются вдоль y-оси). См. также @ref{belt}, @ref{mesh}, @ref{tens}, @ref{meshnum}. @sref{Fall sample}
@end deffn

@cindex belt
@anchor{belt}
@deffn {MGL command} belt zdat ['sch'='']
@deffnx {MGL command} belt xdat ydat zdat ['sch'='']
Рисует ленточки для параметрически заданной поверхности @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. Если @var{sch} содержит @samp{x}, то линии рисуются вдоль x-оси (по умолчанию линии рисуются вдоль y-оси). См. также @ref{fall}, @ref{surf}, @ref{plot}, @ref{meshnum}. @sref{Belt sample}
@end deffn

@cindex boxs
@anchor{boxs}
@deffn {MGL command} boxs zdat ['sch'='']
@deffnx {MGL command} boxs xdat ydat zdat ['sch'='']
Рисует вертикальные ящики для параметрически заданной поверхности @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. См. также @ref{surf}, @ref{dens}, @ref{tile}, @ref{step}. @sref{Boxs sample}
@end deffn

@cindex tile
@anchor{tile}
@deffn {MGL command} tile zdat ['sch'='']
@deffnx {MGL command} tile xdat ydat zdat ['sch'='']
Рисует плитки для параметрически заданной поверхности @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. График может использоваться как 3d обобщение @ref{step}. См. также @ref{surf}, @ref{boxs}, @ref{step}, @ref{tiles}. @sref{Tile sample}
@end deffn

@cindex dens
@anchor{dens}
@deffn {MGL command} dens zdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} dens xdat ydat zdat ['sch'='' @code{zval=nan}]
Рисует график плотности для параметрически заданной поверхности @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@} при @var{z} = @var{zVal}. Если @var{sch} содержит @samp{#}, то рисуется сетка. См. также @ref{surf}, @ref{cont}, @ref{contf}, @ref{boxs}, @ref{tile}, @code{dens[xyz]}. @sref{Dens sample}
@end deffn

@cindex cont
@anchor{cont}
@deffn {MGL command} cont vdat zdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} cont vdat xdat ydat zdat ['sch'='' @code{zval=nan}]
Рисует линии уровня для параметрически заданной поверхности @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@} при @var{z} = @var{zval} (или при @var{z=vdat}[k] если @code{zval==nan}). Линии уровня рисуются для @var{z}=@var{vdat}[k]. Если @var{sch} содержит @samp{#}, то рисуется сетка. Если @var{sch} содержит @samp{t} или @samp{T}, то значения @var{vdat}[k] будут выведены вдоль контуров над (или под) кривой. См. также @ref{dens}, @ref{contf}, @ref{contd}, @ref{axial}, @code{cont[xyz]}. @sref{Cont sample}
@end deffn

@deffn {MGL command} cont zdat ['sch'='' @code{num=7 zval=nan}]
@deffnx {MGL command} cont xdat ydat zdat ['sch'='' @code{num=7 zval=nan}]
Как предыдущий с вектором @var{v} из @var{num} элементов равно распределенных в интервале цветовой шкалы (см., @ref{caxis}).
@end deffn

@cindex contf
@anchor{contf}
@deffn {MGL command} contf vdat zdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} contf vdat xdat ydat zdat ['sch'='' @code{zval=nan}]
Рисует закрашенные линии (контуры) уровня для параметрически заданной поверхности @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@} при @var{z} = @var{zval} (или при @var{z=v}[k] если @code{zval=nan}). Линии уровня рисуются для @var{z}=@var{vdat}[k]. Если @var{sch} содержит @samp{#}, то рисуется сетка. См. также @ref{dens}, @ref{cont}, @ref{contd}, @code{contf[xyz]}. @sref{ContF sample}
@end deffn

@deffn {MGL command} contf zdat ['sch'='' @code{num=7 zval=nan}]
@deffnx {MGL command} contf xdat ydat zdat ['sch'='' @code{num=7 zval=nan}]
Как предыдущий с вектором @var{v} из @var{num} элементов равно распределенных в интервале цветовой шкалы (см., @ref{caxis}).
@end deffn

@cindex contd
@anchor{contd}
@deffn {MGL command} contd vdat zdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} contd vdat xdat ydat zdat ['sch'='' @code{zval=nan}]
Рисует закрашенные линии (контуры) уровня для параметрически заданной поверхности @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@} при @var{z} = @var{zval} (или при @var{z=v}[k] если @code{zval==nan}) цветами заданными явно. Линии уровня рисуются для @var{z}=@var{vdat}[k]. Строка @var{sch} задает цвет контуров: цвет k-го контура определяется символом @code{sch[k%strlen(sch)]}. См. также @ref{dens}, @ref{cont}, @ref{contf}, @code{cont[xyz]}. @sref{ContD sample}
@end deffn

@deffn {MGL command} contd zdat ['sch'='' @code{num=7 zval=nan}]
@deffnx {MGL command} contd xdat ydat zdat ['sch'='' @code{num=7 zval=nan}]
Как предыдущий с вектором @var{v} из @var{num} элементов равно распределенных в интервале цветовой шкалы (см., @ref{caxis}).
@end deffn

@cindex axial
@anchor{axial}
@deffn {MGL command} axial vdat zdat ['sch'='']
@deffnx {MGL command} axial vdat xdat ydat zdat ['sch'='']
Рисует поверхность вращения линии уровня для параметрически заданной поверхности @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. Линии уровня рисуются для @var{zdat}[i,j]=@var{vdat}[k]. Если @var{sch} содержит @samp{#}, то рисуется сетчатая поверхность. Если строка содержит символы @samp{x}, @samp{y} или @samp{z}, то ось вращения устанавливается в указанное направление (по умолчанию вдоль оси @ref{axialdir}). См. также @ref{cont}, @ref{contf}, @ref{torus}, @ref{surf3}. @sref{Axial sample}
@end deffn

@deffn {MGL command} axial zdat ['sch'='' @code{num=3}]
@deffnx {MGL command} axial xdat ydat zdat ['sch'='' @code{num=3}]
Как предыдущий с вектором @var{v} из @var{num} элементов равно распределенных в интервале цветовой шкалы (см., @ref{caxis}).
@end deffn

@cindex grad
@anchor{grad}
@deffn {MGL command} grad pdat ['sch'='' @code{num=5 zval=nan}]
@deffnx {MGL command} grad xdat ydat pdat ['sch'='' @code{num=5 zval=nan}]
@deffnx {MGL command} grad xdat ydat zdat pdat ['sch'='' @code{num=5}]
Рисует линии градиента скалярного поля @var{pdat} заданного параметрически @{@var{xdat}[i,j], @var{ydat}[i,j]@} или @{@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]@}. Число линий пропорционально @var{num}. Линии рисуются только с границ интервала при @var{num}<0. См. также @ref{dens}, @ref{cont}, @ref{dens3}, @ref{cont3}, @ref{flow}. @sref{Grad sample}
@end deffn


@cindex grid2
@anchor{grid2}
@deffn {MGL command} grid2 zdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} grid2 xdat ydat zdat ['sch'='' @code{zval=nan}]
Рисует плоскую сету для параметрически заданной поверхности @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@} при @var{z} = @var{zval}. См. также @ref{dens}, @ref{cont}, @ref{contf}.
@end deffn


@c ##################################################################
@node 3D plotting @MGL{}, Dual plotting @MGL{}, 2D plotting @MGL{}, MGL interface
@section 3D графики @MGL{}

Эти функции строят графики для трехмерных (3D) массивов. Трехмерными считаются массивы, зависящие от трех параметров (индексов) подобно матрице @math{f(x_i,y_j,z_k), i=1...n, j=1...m, k=1...l}. Есть 5 основных типов 3D графиков: поверхность постоянного уровня (@ref{surf3}), график плотности на срезе (@var{dens3}), линии уровня на срезе (@ref{cont3}), закрашенные контуры уровня на срезе (@ref{contf3}) и график объемной прозрачности типа облака (@ref{cloud}). В функциях @ref{cont3}, @ref{contf3} и @ref{surf3} значения уровней можно задавать автоматически и вручную. Можно также нарисовать на срезе сетку (@ref{grid3}) по массиву данных для улучшения вида графика плотности или линий уровня. Каждый тип графика имеет похожий интерфейс. Есть версия для рисования одного массива с автоматическими координатами и версия для параметрически заданного массива.

Строка @var{sch} задает цветовую схему (@pxref{Color scheme}). Предыдущая цветовая схема используется по умолчанию. Массивы @var{x}, @var{y}, @var{z} могут быть векторами (не 3d массивами как @var{a}). Если массивы @var{xdat}, @var{ydat}, @var{zdat} не указаны, то используются массивы со значениями равно распределенными вдоль осей x, y, z.


@cindex surf3
@anchor{surf3}
@deffn {MGL command} surf3 adat @code{val} ['sch'='']
@deffnx {MGL command} surf3 xdat ydat zdat adat @code{val} ['sch'='']
Рисует поверхность уровня для 3d массива, заданного параметрически @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]) при @var{adat}(x,y,z)=@var{val}. Если @var{sch} содержит @samp{#}, то рисуется сетчатая поверхность. См. также @ref{cloud}, @ref{dens3}, @ref{surf3c}, @ref{surf3a}, @ref{axial}. @sref{Surf3 sample}
@end deffn

@deffn {MGL command} surf3 adat ['sch'='' @code{num=5}]
@deffnx {MGL command} surf3 xdat ydat zdat adat ['sch'='' @code{num=5}]
Рисует @var{num} поверхностей уровня равномерно распределенных в интервале цветовой шкалы (см. @ref{caxis}).
@end deffn

@cindex dens3
@anchor{dens3}
@deffn {MGL command} dens3 adat 'dir' [@code{sval=-1} 'sch'='']
@deffnx {MGL command} dens3 xdat ydat zdat adat 'dir' [@code{sval=-1} 'sch'='']
Рисует график плотности для 3d массива, заданного параметрически @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]). График рисуется на срезе @var{sval} в направлении @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@}. Если @var{stl} содержит @samp{#}, то на срезе рисуется сетка. См. также @ref{cont3}, @ref{contf3}, @ref{dens}, @ref{grid3}. @sref{Dens3 sample}
@end deffn

@cindex densa
@anchor{densa}
@deffn {MGL command} densa adat ['sch'='']
@deffnx {MGL command} densa xdat ydat zdat adat ['sch'='']
Рисует графики плотности на всех центральных срезах 3d данных.
@end deffn

@cindex cont3
@anchor{cont3}
@deffn {MGL command} cont3 vdat adat 'dir' [@code{sval=-1} 'sch'='']
@deffnx {MGL command} cont3 vdat xdat ydat zdat adat 'dir' [@code{sval=-1} 'sch'='']
Рисует линии уровня для 3d массива, заданного параметрически @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]). Линии рисуются для значений из массива @var{v} на срезе @var{sval} в направлении @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@}. Если @var{stl} содержит @samp{#}, то на срезе рисуется сетка. Если @var{sch} содержит @samp{t} или @samp{T}, то значения @var{vdat}[k] будут выведены вдоль контуров над (или под) кривой. См. также @ref{dens3}, @ref{contf3}, @ref{cont}, @ref{grid3}. @sref{Cont3 sample}
@end deffn

@deffn {MGL command} cont3 adat 'dir' [@code{sval=-1} 'sch'='' @code{num=7}]
@deffnx {MGL command} cont3 xdat ydat zdat adat 'dir' [@code{sval=-1} 'sch'='' @code{num=7}]
Как предыдущий с вектором @var{v} из @var{num} элементов равно распределенных в интервале цветовой шкалы (см., @ref{caxis}).
@end deffn

@cindex conta
@anchor{conta}
@deffn {MGL command} conta adat ['sch'='' @code{num=7}]
@deffnx {MGL command} conta xdat ydat zdat adat ['sch'='' @code{num=7}]
Рисует линии уровня на всех центральных срезах 3d данных.
@end deffn

@cindex contf3
@anchor{contf3}
@deffn {MGL command} contf3 vdat adat 'dir' [@code{sval=-1} 'sch'='']
@deffnx {MGL command} contf3 vdat xdat ydat zdat adat 'dir' [@code{sval=-1} 'sch'='']
Рисует закрашенные линии (контуры) уровня для 3d массива, заданного параметрически @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]). Линии рисуются для значений из массива @var{v} на срезе @var{sval} в направлении @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@}. Если @var{stl} содержит @samp{#}, то на срезе рисуется сетка. См. также @ref{dens3}, @ref{cont3}, @ref{contf}, @ref{grid3}. @sref{ContF3 sample}
@end deffn

@deffn {MGL command} contf3 adat 'dir' [@code{sval=-1} 'sch'='' @code{num=7}]
@deffnx {MGL command} contf3 xdat ydat zdat adat 'dir' [@code{sval=-1} 'sch'='' @code{num=7}]
Как предыдущий с вектором @var{v} из @var{num} элементов равно распределенных в интервале цветовой шкалы (см., @ref{caxis}).
@end deffn

@cindex contfa
@anchor{contfa}
@deffn {MGL command} contfa adat ['sch'='' @code{num=7}]
@deffnx {MGL command} contfa xdat ydat zdat adat ['sch'='' @code{num=7}]
Рисует закрашенные линии (контуры) уровня на всех центральных срезах 3d данных.
@end deffn

@cindex grid3
@anchor{grid3}
@deffn {MGL command} grid3 adat 'dir' [@code{sval=-1} 'sch'='']
@deffnx {MGL command} grid3 xdat ydat zdat adat 'dir' [@code{sval=-1} 'sch'='']
Рисует сетку для 3d массива, заданного параметрически @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]). График рисуется на срезе @var{sval} в направлении @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@}. См. также @ref{cont3}, @ref{contf3}, @ref{dens3}, @ref{grid2}.
@end deffn

@cindex grida
@anchor{grida}
@deffn {MGL command} grida adat ['sch'='']
@deffnx {MGL command} grida xdat ydat zdat adat ['sch'='']
Рисует сетку на всех центральных срезах 3d данных.
@end deffn

@cindex cloud
@anchor{cloud}
@deffn {MGL command} cloud adat ['sch'='']
@deffnx {MGL command} cloud xdat ydat zdat adat ['sch'='']
Рисует облачный график для 3d массива, заданного параметрически @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]). График состоит из кубиков с цветом и прозрачностью пропорциональной значениям @var{adat}. Результат похож на облако -- малые значения прозрачны, а большие нет. Число кубиков зависит от @ref{meshnum}. Параметр @var{alpha} меняет общую прозрачность графика. См. также @ref{surf3}. @sref{Cloud sample}
@end deffn

@cindex beam
@anchor{beam}
@deffn {MGL command} beam tr g1 g2 adat @code{rval} ['sch'='' @code{flag=0 num=3}]
Рисует поверхность уровня для 3d массива @var{adat} при постоянном значении @var{adat}=@var{val}. Это специальный тип графика для @var{adat} заданного в сопровождающей системе координат вдоль кривой @var{tr} с ортами @var{g1}, @var{g2} и с поперечным размером @var{rval}. Переменная @var{flag} -- битовый флаг: @samp{0x1} - рисовать в сопровождающих (не лабораторных) координатах; @samp{0x2} - рисовать проекцию на плоскость @math{\rho-z}; @samp{0x4} - рисовать нормированное в каждом сечении поле. Размеры массивов по 1-му индексу @var{tr}, @var{g1}, @var{g2} должны быть nx>2. Размеры массивов по 2-му индексу @var{tr}, @var{g1}, @var{g2} и размер по 3-му индексу массива @var{adat} должны быть одинаковы. См. также @ref{surf3}.
@end deffn


@c ##################################################################
@node Dual plotting @MGL{}, Vector fields @MGL{}, 3D plotting @MGL{}, MGL interface
@section Парные графики @MGL{}

Эти команды строят графики для двух связанных массивов. Есть несколько основных типов 3D графиков: поверхность и поверхность уровня с окраской по второму массиву (@ref{surfc}, @ref{surf3c}), поверхность и поверхность уровня с прозрачностью по второму массиву (@ref{surfa}, @ref{surf3a}), плитки переменного размера (@ref{tiles}), диаграмма точечного отображения (@ref{map}), STFA диаграмма (@ref{stfa}). В командах @ref{surf3a} и @ref{surf3c} значения уровней можно задавать автоматически и вручную. Каждый тип графика имеет похожий интерфейс. Есть версия для рисования одного массива с автоматическими координатами и версия для параметрически заданного массива.

Строка @var{sch} задает цветовую схему (@pxref{Color scheme}). Предыдущая цветовая схема используется по умолчанию. Массивы @var{x}, @var{y}, @var{z} могут быть векторами (не 3d массивами как @var{a}). Если массивы @var{xdat}, @var{ydat}, @var{zdat} не указаны, то используются массивы со значениями равно распределенными вдоль осей x, y, z.

@cindex surfc
@anchor{surfc}
@deffn {MGL command} surfc zdat cdat ['sch'='']
@deffnx {MGL command} surfc xdat ydat zdat cdat ['sch'='']
Рисует параметрически заданную поверхность @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@} с цветом, заданным массивом @var{cdat}[i,j]. Если @var{sch} содержит @samp{#}, то на поверхности рисуется сетка. См. также @ref{surf}, @ref{surfa}, @ref{surf3c}. @sref{SurfC sample}
@end deffn

@cindex surf3c
@anchor{surf3c}
@deffn {MGL command} surf3c adat cdat @code{val} ['sch'='']
@deffnx {MGL command} surf3c xdat ydat zdat adat cdat @code{val} ['sch'='']
Рисует поверхность уровня для 3d массива, заданного параметрически @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]) при @var{a}(x,y,z)=@var{val}. Аналогично @ref{surf3}, но цвет задается массивом @var{cdat}. Если @var{sch} содержит @samp{#}, то рисуется сетчатая поверхность. См. также @ref{surf3}, @ref{surfc}, @ref{surf3a}. @sref{Surf3C sample}
@end deffn

@deffn {MGL command} surf3c adat cdat ['sch'='' @code{num=5}]
@deffnx {MGL command} surf3c xdat ydat zdat adat cdat ['sch'='' @code{num=5}]
Рисует @var{num} поверхностей уровня равномерно распределенных в интервале цветовой шкалы (см. @ref{caxis}).
@end deffn

@cindex surfa
@anchor{surfa}
@deffn {MGL command} surfa zdat cdat ['sch'='']
@deffnx {MGL command} surfa xdat ydat zdat cdat ['sch'='']
Рисует параметрически заданную поверхность @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@} с прозрачностью, заданным массивом @var{cdat}[i,j]. Если @var{sch} содержит @samp{#}, то на поверхности рисуется сетка. См. также @ref{surf}, @ref{surfc}, @ref{surf3a}. @sref{SurfA sample}
@end deffn

@cindex surf3a
@anchor{surf3a}
@deffn {MGL command} surf3a adat cdat @code{val} ['sch'='']
@deffnx {MGL command} surf3a xdat ydat zdat adat cdat @code{val} ['sch'='']
Рисует поверхность уровня для 3d массива, заданного параметрически @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]) при @var{a}(x,y,z)=@var{val}. Аналогично @ref{surf3}, но прозрачность задается массивом @var{cdat}. Если @var{sch} содержит @samp{#}, то рисуется сетчатая поверхность. См. также @ref{surf3}, @ref{surfa}, @ref{surf3c}. @sref{Surf3A sample}
@end deffn

@deffn {MGL command} surf3a adat cdat ['sch'='' @code{num=5}]
@deffnx {MGL command} surf3a xdat ydat zdat adat cdat ['sch'='' @code{num=5}]
Рисует @var{num} поверхностей уровня равномерно распределенных в интервале цветовой шкалы (см. @ref{caxis}).
@end deffn

@cindex tiles
@anchor{tiles}
@deffn {MGL command} tiles zdat rdat ['sch'='']
@deffnx {MGL command} tiles xdat ydat zdat rdat ['sch'='']
Рисует плитки для параметрически заданной поверхности @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. Аналогично @ref{tile}, но размер плиток задается массивов @var{rdat}. Это создает эффект "прозрачности" при экспорте в файлы EPS. См. также @ref{surfa}, @ref{tile}. @sref{TileS sample}
@end deffn

@cindex map
@anchor{map}
@deffn {MGL command} map udat vdat ['sch'='' @code{pnts=on}]
@deffnx {MGL command} map xdat ydat udat vdat ['sch'='' @code{pnts=on}]
Визуализирует точечное отображение для матриц @{@var{udat}, @var{vdat} @} параметрически зависящих от координат @var{xdat}, @var{ydat}. Исходное положение ячейки задает ее цвет. Высота пропорциональна якобиану Jacobian(udat,vdat). График является аналогом диаграммы Арнольда. Если @code{pnts=off}, то рисуются грани, иначе цветные точки рисуются в узлах матриц (полезно для "запутанного" отображения). @sref{Map sample}
@end deffn

@cindex stfa
@anchor{stfa}
@deffn {MGL command} stfa re im @code{dn} ['sch'='' @code{pnts=on}]
@deffnx {MGL command} stfa xdat ydat re im @code{dn} ['sch'='' @code{pnts=on}]
Рисует спектрограмму комплексного массива @var{re}+i*@code{im} для Фурье размером @var{dn} точек. Параметр @var{dn} -- любое четное число. Например в 1D случае, результатом будет график плотности от массива @math{res[i,j]=|\sum_d^dn exp(I*j*d)*(re[i*dn+d]+I*im[i*dn+d])|/dn} размером @{int(nx/dn), dn, ny@}. Массивы @var{re}, @var{im} параметрически зависят от координат @var{xdat}, @var{ydat}. @sref{STFA sample}
@end deffn




@c ##################################################################
@node Vector fields @MGL{}, Other plotting @MGL{}, Dual plotting @MGL{}, MGL interface
@section Векторные поля @MGL{}

Эти функции рисуют графики для 2D и 3D векторных полей. Есть несколько типов графиков: просто векторное поле (@ref{vect}), вектора вдоль траектории (@ref{traj}), векторное поле каплями (@ref{dew}), нити тока (@ref{flow}), трубки тока (@ref{pipe}). Каждый тип графика имеет похожий интерфейс. Есть версия для рисования одного массива с автоматическими координатами и версия для параметрически заданного массива.

Цвет задается строкой @var{sch}. Предыдущая цветовая схема используется по умолчанию. Параметр @var{flag} побитовый флаг для настройки вид векторов: @code{1} -- двуцветный вектор, @code{2} -- одинаковая длина векторов, @code{4} -- рисует стрелку в точку сетки, @code{8} -- рисует стрелку с серединой в точке сетки, @code{16} -- рисует штрихи вместо стрелок. Все размеры массивов @var{ax} и @var{ay} должны быть одинаковы. Младшие размерности массивов @var{x}, @var{y} и @var{ax} должны быть одинаковы. Массивы @var{x} и @var{y} могут быть векторами (не матрицами как @var{ax}). График строится для каждого z среза @var{ax}, @var{ay} для 2D случаев.

@cindex traj
@anchor{traj}
@deffn {MGL command} traj xdat ydat udat vdat ['sch'='' @code{zval=nan len=0}]
@deffnx {MGL command} traj xdat ydat zdat udat vdat wdat ['sch'='' @code{len=0}]
Draws vectors @{@var{udat}, @var{vdat}, @var{wdat}@} along a curve @var{xdat}, @var{ydat}, @var{zdat}. The length and color of arrows are proportional to @math{\sqrt@{udat^2+vdat^2+wdat^2@}}. See also @code{vect}. @sref{Traj sample}
@end deffn

@cindex vect
@anchor{vect}
@deffn {MGL command} vect udat vdat ['sch'='' @code{zval=nan flag=0}]
@deffnx {MGL command} vect xdat ydat udat vdat ['sch'='' @code{zval=nan flag=0}]
Draws plane vector field plot for the field @{@var{udat}, @var{vdat}@} depending parametrically on coordinates @var{xdat}, @var{ydat} at level @var{z=zVal}. The length and color of arrows are proportional to @math{\sqrt@{udat^2+vdat^2@}}. The number of hachures depend on @var{meshnum}. See also @code{vectc, flow, pipe, dew}. @sref{Vect sample}
@end deffn

@deffn {MGL command} vect udat vdat wdat ['sch'='' @code{flag=0}]
@deffnx {MGL command} vect xdat ydat zdat udat vdat wdat ['sch'='' @code{flag=0}]
This is 3D version of the previous command. Here arrays @var{udat}, @var{vdat}, @var{wdat} must be 3-ranged tensors with equal sizes and the length and color of arrows are proportional to @math{\sqrt@{udat^2+vdat^2+wdat^2@}}. @sref{Vect 3D sample}
@end deffn

@cindex vectc
@anchor{vectc}
@deffn {MGL command} vectc udat vdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} vectc xdat ydat udat vdat ['sch'='' @code{zval=nan}]
Draws plane vector field plot for the field @{@var{udat}, @var{vdat}@} depending parametrically on coordinates @var{xdat}, @var{ydat} at level @var{z=zVal}. The color of hachures is proportional to @math{\sqrt@{udat^2+vdat^2@}}. The number of hachures depend on @var{meshnum}. See also @code{vect, flow, pipe, dew}. @sref{VectC sample}
@end deffn

@deffn {MGL command} vectc udat vdat wdat ['sch'='']
@deffnx {MGL command} vectc xdat ydat zdat udat vdat wdat ['sch'='']
This is 3D version of the previous command. Here arrays @var{udat}, @var{vdat}, @var{wdat} must be 3-ranged tensors with equal sizes and the color of hachures is proportional to @math{\sqrt@{udat^2+vdat^2+wdat^2@}}. @sref{VectC 3D sample}
@end deffn

@cindex vectl
@anchor{vectl}
@deffn {MGL command} vectl udat vdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} vectl xdat ydat udat vdat ['sch'='' @code{zval=nan}]
Draws plane vector field plot for the field @{@var{udat}, @var{vdat}@} depending parametrically on coordinates @var{xdat}, @var{ydat} at level @var{z=zVal}. The length of hachures is proportional to @math{\sqrt@{udat^2+vdat^2@}}. The number of hachures depend on @var{meshnum}. See also @code{vectc, flow, pipe, dew}. @sref{Vect sample}
@end deffn

@deffn {MGL command} vectl udat vdat wdat ['sch'='']
@deffnx {MGL command} vectl xdat ydat zdat udat vdat wdat ['sch'='']
This is 3D version of the previous command. Here arrays @var{udat}, @var{vdat}, @var{wdat} must be 3-ranged tensors with equal sizes and the length of hachures is proportional to @math{\sqrt@{udat^2+vdat^2+wdat^2@}}. @sref{Vect 3D sample}
@end deffn

@cindex dew
@anchor{dew}
@deffn {MGL command} dew udat vdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} dew xdat ydat udat vdat ['sch'='' @code{zval=nan}]
Draws dew-drops for plane vector field @{@var{udat}, @var{vdat}@} depending parametrically on coordinates @var{xdat}, @var{ydat} at level @var{z=zVal}. The color of drops is proportional to @math{\sqrt@{udat^2+vdat^2@}}. The number of drops depend on @var{meshnum}. Note that this is very expensive plot in memory usage and creation time! See also @code{vectc}. @sref{Dew sample}
@end deffn

@cindex flow
@anchor{flow}
@deffn {MGL command} flow udat vdat ['sch'='' @code{num=5 zval=nan}]
@deffnx {MGL command} flow xdat ydat udat vdat ['sch'='' @code{num=5 zval=nan}]
Draws plane flow threads for the vector field @{@var{udat}, @var{vdat}@} depending parametrically on coordinates @var{xdat}, @var{ydat} at level @var{z=zVal}. Number of threads is proportional to @var{num}. The color of lines is proportional to @math{\sqrt@{udat^2+vdat^2@}}. Warm color corresponds to normal flow (like attractor). Cold one corresponds to inverse flow (like source). See also @code{vect, vectc, pipe}. @sref{Flow sample}
@end deffn

@deffn {MGL command} flow udat vdat wdat ['sch'='' @code{num=3}]
@deffnx {MGL command} flow xdat ydat zdat udat vdat wdat ['sch'='' @code{num=3}]
This is 3D version of the previous command. Here arrays @var{udat}, @var{vdat}, @var{wdat} must be 3-ranged tensors with equal sizes and the color is proportional to @math{\sqrt@{udat^2+vdat^2+wdat^2@}}. @sref{Flow 3D sample}
@end deffn

@deffn {MGL command} flow @code{x0 y0} udat vdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} flow @code{x0 y0} xdat ydat udat vdat ['sch'='' @code{zval=nan}]
Draws plane flow threads for the vector field @{@var{udat}, @var{vdat}@} depending parametrically on coordinates @var{xdat}, @var{ydat} from point @{@var{x0}, @var{y0}@} at level @var{z=zVal}. The color of lines is proportional to @math{\sqrt@{udat^2+vdat^2@}}. Warm color corresponds to normal flow (like attractor). Cold one corresponds to inverse flow (like source). See also @code{vect, vectc, pipe}. @sref{Flow sample}
@end deffn

@deffn {MGL command} flow @code{x0 y0 z0} udat vdat wdat ['sch'='']
@deffnx {MGL command} flow @code{x0 y0 z0} xdat ydat zdat udat vdat wdat ['sch'='']
Draws flow thread from point @{@var{x0}, @var{y0}, @var{z0}@}. Arrays @var{udat}, @var{vdat}, @var{wdat} must be 3-ranged tensors with equal sizes and the color is proportional to @math{\sqrt@{udat^2+vdat^2+wdat^2@}}. @sref{Flow 3D sample}
@end deffn


@cindex pipe
@anchor{pipe}
@deffn {MGL command} pipe udat vdat ['sch'='' @code{r0=0.05 num=5 zval=nan}]
@deffnx {MGL command} pipe xdat ydat udat vdat ['sch'='' @code{r0=0.05 num=5 zval=nan}]
Draws plane flow pipes for the vector field @{@var{udat}, @var{vdat}@} depending parametrically on coordinates @var{xdat}, @var{ydat} at level @var{z=zVal}. Number of pipes is proportional to @var{num}. The color of pipes is proportional to @math{\sqrt@{udat^2+vdat^2@}}. Warm color corresponds to normal flow (like attractor). Cold one corresponds to inverse flow (like source). Parameter @var{r0} set the base pipe radius. If @var{r0}<0 then pipe radius is inverse proportional to amplitude. The size of @var{ax} and @var{ay} must be equal. See also @code{vect, vectc, pipe}. @sref{Flow sample}
@end deffn

@deffn {MGL command} pipe udat vdat wdat ['sch'='' @code{r0=0.05 num=3}]
@deffnx {MGL command} pipe xdat ydat zdat udat vdat wdat ['sch'='' @code{r0=0.05 num=3}]
This is 3D version of the previous command. Here arrays @var{udat}, @var{vdat}, @var{wdat} must be 3-ranged tensors with equal sizes and the color is proportional to @math{\sqrt@{udat^2+vdat^2+wdat^2@}}. @sref{Flow 3D sample}
@end deffn


@c ##################################################################
@node Other plotting @MGL{}, Nonlinear fitting @MGL{}, Vector fields @MGL{}, MGL interface
@section Other plotting @MGL{}

These commands perform miscelaneous plotting. There is unstructured data points plots (Dots), surface reconstruction (Crust), surfaces on the triangular mesh (TriPlot) or quadrangular mesh (QuadPlot), textual formula plotting (Plots by formula), data plots at edges (Dens[XYZ], Cont[XYZ], ContF[XYZ]), simple plot (SimplePlot). Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@cindex densx
@anchor{densx}
@deffn {MGL command} densx dat ['sch'='' @code{val=nan}]
@cindex densy
@anchor{densy}
@deffnx {MGL command} densy dat ['sch'='' @code{val=nan}]
@cindex densz
@anchor{densz}
@deffnx {MGL command} densz dat ['sch'='' @code{val=nan}]
These plotting commands draw density plot in x, y or z plain. If @var{dat} is a tensor (3-dimensional data) then interpolation to a given @var{val} is performed. These commands are useful for creating projections of the 3D data array to the bounding box. See also @code{cont[xyz], contf[xyz], dens}. @sref{Dens projection sample}
@end deffn

@cindex contx
@anchor{contx}
@deffn {MGL command} contx dat ['sch'='' @code{val=nan num=7}]
@cindex conty
@anchor{conty}
@deffnx {MGL command} conty dat ['sch'='' @code{val=nan num=7}]
@cindex contz
@anchor{contz}
@deffnx {MGL command} contz dat ['sch'='' @code{val=nan num=7}]
These plotting commands draw contour lines in x, y or z plain. If @var{dat} is a tensor (3-dimensional data) then interpolation to a given @var{val} is performed. These commands are useful for creating projections of the 3D data array to the bounding box. See also @code{dens[xyz], contf[xyz], cont}. @sref{Cont projection sample}
@end deffn

@cindex contfx
@anchor{contfx}
@deffn {MGL command} contfx dat ['sch'='' @code{val=nan num=7}]
@cindex contfy
@anchor{contfy}
@deffnx {MGL command} contfy dat ['sch'='' @code{val=nan num=7}]
@cindex contfz
@anchor{contfz}
@deffnx {MGL command} contfz dat ['sch'='' @code{val=nan num=7}]
These plotting commands draw solid contours in x, y or z plain. If @var{dat} is a tensor (3-dimensional data) then interpolation to a given @var{val} is performed. These commands are useful for creating projections of the 3D data array to the bounding box. See also @code{dens[xyz], cont[xyz], contf}.
@end deffn

@cindex dots
@anchor{dots}
@deffn {MGL command} dots xdat ydat zdat ['sch'='']
@deffnx {MGL command} dots xdat ydat zdat adat ['sch'='']
Draws the arbitrary placed points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. Variable @var{adat}[i] set transparency for dots. See also @code{crust, mark, plot}. @sref{Dots sample}
@end deffn

@cindex crust
@anchor{crust}
@deffn {MGL command} crust xdat ydat zdat ['sch'='']
Reconstructs and draws the surface for arbitrary placed points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. If string contain @samp{#} then wire plot is produced. See also @code{dots, triplot}. @sref{Crust sample}
@end deffn

@cindex triplot
@anchor{triplot}
@deffn {MGL command} triplot idat xdat ydat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} triplot idat xdat ydat zdat ['sch'='']
@deffnx {MGL command} triplot idat xdat ydat zdat cdat ['sch'='']
Draws the surface of triangles. Triangle vertexes are set by indexes @var{idat} of data points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. If string contain @samp{#} then wire plot is produced. First dimensions of @var{idat} must be 3 or greater. See also @code{dots, crust, quadplot}. Parameter @var{cdat} set the colors of triangles (if @var{idat}.ny=@var{cdat}.nx) or colors of vertexes (if @var{xdat}.nx=@var{cdat}.nx).
@end deffn

@cindex tricont
@anchor{tricont}
@deffn {MGL command} tricont vdat idat xdat ydat zdat cdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} tricont vdat idat xdat ydat zdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} tricont idat xdat ydat zdat ['sch'='' @code{num=7 zval=nan}]
Draws contour lines for surface of triangles at @var{z} = @var{zVal} (or for @var{z}=@var{vdat}[k] if @code{zval=nan}). Triangle vertexes are set by indexes @var{idat} of data points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. Contours are plotted for @var{zdat}[i,j]=@var{vdat}[k] for all k (or @var{num} contours equidistantly distributed in range [@var{Cmin}, @var{Cmax}].). See also @code{triplot, cont}.
@end deffn

@cindex quadplot
@anchor{quadplot}
@deffn {MGL command} quadplot idat xdat ydat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} quadplot idat xdat ydat zdat ['sch'='']
@deffnx {MGL command} quadplot idat xdat ydat zdat cdat ['sch'='']
Draws the surface of quadrangles. Quadrangle vertexes are set by indexes @var{idat} of data points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. If string contain @samp{#} then wire plot is produced. First dimensions of @var{idat} must be 4 or greater. See also @code{triplot, dots, crust}. Parameter @var{cdat} set the colors of triangles (if @var{idat}.ny=@var{cdat}.nx) or colors of vertexes (if @var{xdat}.nx=@var{cdat}.nx).
@end deffn

@cindex fplot
@anchor{fplot}
@deffn {MGL command} fplot 'y(x)' ['pen'='' @code{zval=nan num=100}]
Draws command function @samp{y(x)} at plane z=@var{zval} where @samp{x} variable is changed in @code{xrange}. You do not need to create the data arrays to plot it. The parameter @var{num} set the minimal number of points along coordinate(s) for plots. See also @code{plot}.
@end deffn

@deffn {MGL command} fplot 'x(t)' 'y(t)' 'z(t)' ['pen'='' @code{num=100}]
Draws command parametrical curve @{@samp{x(t)}, @samp{y(t)}, @samp{z(t)}@} where @samp{t} variable is changed in range [0, 1]. You do not need to create the data arrays to plot it. The parameter @var{num} set the minimal number of points along coordinate(s) for plots. See also @code{plot}.
@end deffn

@cindex fsurf
@anchor{fsurf}
@deffn {MGL command} fsurf 'z(x,y)' ['sch'='' @code{num=100}]
Draws command surface for function @samp{z(x,y)} where @samp{x}, @samp{y} variable are changed in @code{xrange, yrange}. You do not need to create the data arrays to plot it. The parameter @var{num} set the minimal number of points along coordinate(s) for plots. See also @code{surf}.
@end deffn

@deffn {MGL command} fsurf 'x(u,v)' 'y(u,v)' 'z(u,v)' ['sch'='' @code{num=100}]
Draws command parametrical surface @{@samp{x(u,v)}, @samp{y(u,v)}, @samp{z(u,v)}@} where @samp{u}, @samp{v} variable are changed in range [0, 1]. You do not need to create the data arrays to plot it. The parameter @var{num} set the minimal number of points along coordinate(s) for plots. See also @code{surf}.
@end deffn


@c ##################################################################
@node Nonlinear fitting @MGL{}, Data create @MGL{}, Other plotting @MGL{}, MGL interface
@section Nonlinear fitting @MGL{}

These commands fit data to formula. Fitting goal is to find formula parameters for the best fit the data points, i.e. to minimize the sum @math{\sum_i (f(x_i, y_i, z_i) - a_i)^2/s_i^2}. At this, approximation command @samp{f} can depend only on one argument @samp{x} (1D case), on two arguments @samp{x,y} (2D case) and on three arguments @samp{x,y,z} (3D case). The command @samp{f} also may depend on parameters. Normally the list of fitted parameters is specified by @var{var} string (like, @samp{abcd}). Usually user should supply initial values for fitted parameters by @var{ini} variable. But if he/she don't supply it then the zeros are used.

Commands @code{fit} and @code{fits} do not draw the obtained data themselves. They fill the data @var{out} by formula @samp{f} with found coefficients. At this, the @samp{x,y,z} coordinates are equidistantly distributed in the bounding box. Number of points in @var{out} is selected as maximal value of @var{out} size or 100. Also you may print the last formula with found coefficients by @code{putsfit} command. @sref{Fitting sample}

The dimensions of arrays must be at least the same as the number of specified arrays @var{xdat}, @var{ydat}, @var{zdat}. Also the fitting only along specified directions will be performed (for example, along x and y if only @var{xdat} and @var{ydat} are specified). If array @var{xdat} is not specified then its an automatic array is used with values equidistantly distributed along x.


@cindex fits
@anchor{fits}
@deffn {MGL command} fits adat sdat 'func' 'var' [ini=0]
@deffnx {MGL command} fits xdat adat sdat 'func' 'var' [ini=0]
@deffnx {MGL command} fits xdat ydat adat sdat 'func' 'var' [ini=0]
@deffnx {MGL command} fits xdat ydat zdat adat sdat 'func' 'var' [ini=0]
Fit data along x-, y- and z-directions for 1d-,2d- or 3d array specified parametrically @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]) with weight factor @var{sdat}[i,j,k].
@end deffn

@cindex fit
@anchor{fit}
@deffn {MGL command} fit adat 'func' 'var' [ini=0]
@deffnx {MGL command} fit xdat adat 'func' 'var' [ini=0]
@deffnx {MGL command} fit xdat ydat adat 'func' 'var' [ini=0]
@deffnx {MGL command} fit xdat ydat zdat adat 'func' 'var' [ini=0]
Fit data along x-, y- and z-directions for 1d-,2d- or 3d array specified parametrically @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]) with weight factor =1.
@end deffn

@cindex putsfit
@anchor{putsfit}
@deffn {MGL command} putsfit @code{x y} ['pre'='' 'fnt'='' @code{size=-1}]
Print last fitted formula with found coefficients (as numbers) at position @{@var{x}, @var{y}@}. The string @var{pre} will be printed before formula. All other parameters are the same as in @ref{Text printing @MGL{}}.
@end deffn


@c ##################################################################
@node Data create @MGL{}, Data filling @MGL{}, Nonlinear fitting @MGL{}, MGL interface
@section Data create @MGL{}

@cindex new
@anchor{new}
@deffn {MGL command} new dat [@code{nx=1 ny=1 nz=1}]
Creates or recreates the array @var{dat} with specified size and fills it by zero. This command does nothing if one of parameters @var{nx}, @var{ny}, @var{nz} is zero or negative.
@end deffn

@cindex var
@anchor{var}
@deffn {MGL command} var dat @code{num v1 [v2=nan]}
Creates new variable with name dat for one-dimensional array of size num. Array elements are equidistantly distributed in range [@var{v1}, @var{v2}]. If @var{v2}=@code{nan} then @var{v2=v1} is used. 
@end deffn

@cindex list
@anchor{list}
@deffn {MGL command} list dat @code{v1 ...}
Creates new variable with name @var{dat} and fills it by numeric values of command arguments @code{v1 ...}. Command can create one-dimensional and two-dimensional arrays with arbitrary values. For creating 2d array the user should use delimiter - which means that the following values lie in next row. Array sizes are [maximal of row sizes * number of rows]. For example, command @code{list 1 | 2 3} creates the array [1 0; 2 3]. Note, that the maximal number of arguments is 1000. 
@end deffn

@deffn {MGL command} list dat d1 ...
Creates new variable with name @var{dat} and fills it by data values of arrays of command arguments @var{d1 ...}. Command can create two-dimensional or three-dimensional (if arrays in arguments are 2d arrays) arrays with arbitrary values. Minor dimensions of all arrays in arguments should be equal to dimensions of first array d1. In the opposite case the argument will be ignored. Note, that the maximal number of arguments is 1000. 
@end deffn

@cindex copy
@anchor{copy}
@deffn {MGL command} copy dat1 dat2 ['eq'='' @code{on_axis=on}]
@deffnx {MGL command} copy dat1 @code{val}
Creates new variable with name @var{dat1} and fills it by data values of array @var{dat2}. At this, if parameter @var{eq} is specified then the data will be modified by corresponding formula by the same way as in @code{fill} command (for @code{on_axis=on}) or in @code{modify} command (for @code{on_axis=off}).
@end deffn

@cindex idset
@anchor{idset}
@deffn {MGL command} idset dat 'ids'
Set the symbol id for data columns. The string must contain one symbol 'a'...'z' per column (without spaces).
@end deffn

@cindex info
@anchor{info}
@deffn {MGL command} info dat [@code{detail=off}]
Display information (sizes, maximum/minimum, momentums and so on) about the data dat. Show brief information by default (if @code{detail=off}).
@end deffn

@deffn {MGL command} info 'text'
Display @var{text} as information (warning).
@end deffn

@c ------------------------------------------------------------------
@node Data filling @MGL{}, Rearrange data @MGL{}, Data create @MGL{}, MGL interface
@section Data filling @MGL{}
@cindex fill
@cindex modify

@cindex fill
@anchor{fill}
@deffn {MGL command} fill dat v1 v2 ['dir'='x']
Equidistantly fills the data values to range [@var{x1}, @var{x2}] in direction @var{dir}=@{@samp{x},@samp{y},@samp{z}@}.
@end deffn

@deffn {MGL command} fill dat 'eq' [vdat=0 wdat=0]
Command fills the value of array according to the formula in string @var{eq}. Formula is an arbitrary expression depending  on variables @samp{x}, @samp{y}, @samp{z}, @samp{u}, @samp{v}, @samp{w}. Coordinates @samp{x}, @samp{y}, @samp{z} are supposed to be normalized in @emph{bounding box} (in difference from @code{modify} commands). Variable @samp{u} is the original value of the array. Variables @samp{v} and @samp{w} are values of @var{vdat}, @var{wdat}.
@end deffn

@cindex modify
@anchor{modify}
@deffn {MGL command} modify dat 'eq' [@code{dim=0}]
Command fills the value of array according to the formula in string @var{eq}. Formula is an arbitrary expression depending  on variables @samp{x}, @samp{y}, @samp{z}, @samp{u}. Coordinates @samp{x}, @samp{y}, @samp{z} are data indexes normalized in range [0,1]. Variable @samp{u} is the original value of the array. Modification will be fulfilled only for slices >=@var{dim}.
@end deffn

@deffn {MGL command} modify dat 'eq' vdat [wdat=0]
Command fills the value of array according to the formula in string @var{eq}. Formula is an arbitrary expression depending  on variables @samp{x}, @samp{y}, @samp{z}, @samp{u}, @samp{v}, @samp{w}. Coordinates @samp{x}, @samp{y}, @samp{z} are data indexes normalized in range [0,1]. Variable @samp{u} is the original value of the array. Variables @samp{v} and @samp{w} are values of @var{vdat}, @var{wdat}. If optional data @var{vdat}, @var{wdat} (must be the same size as @var{dat}) are specified then variables @samp{v} and @samp{w} denote its values else they are zero.
@end deffn


@cindex put
@anchor{put}
@deffn {MGL command} put a @code{val [i=: j=: k=:]}
Function sets value(s) of array a[@var{i}, @var{j}, @var{k}] = @var{val}. Negative indexes @var{i}, @var{j}, @var{k}=@samp{:} set the value @var{val} to whole range in corresponding direction(s). For example, @code{put a val : 0 :} sets a[i,0,j]=@var{val} for i=0...(a.nx-1), j=0...(a.nz-1).
@end deffn

@deffn {MGL command} put a v [@code{i=: j=: k=:}]
Function copies value(s) from array @var{v} to the range of array @var{a}. Negative indexes @var{i}, @var{j}, @var{k}=@samp{:} set the range in corresponding direction(s). At this minor dimensions of array @var{v} should be large than corresponding dimensions of array @var{a}. For example, @code{put a v : 0 :} sets a[i,0,j]=v.ny>nz ? v[i,j] : v[i], where i=0...(a.nx-1), j=0...(a.nz-1) and condition v.nx>=a.nx is true.
@end deffn



@c ------------------------------------------------------------------
@node Rearrange data @MGL{}, File I/O @MGL{}, Data filling @MGL{}, MGL interface
@section Rearrange data @MGL{}

@cindex rearrange
@anchor{rearrange}
@deffn {MGL command} rearrange dat @code{mx [my=0 mz=0]}
Rearrange dimensions without changing data array so that resulting sizes should  be @var{mx}*@var{my}*@var{mz} < nx*ny*nz. If some of parameter @var{my} or @var{mz} are zero then it will be selected to optimal fill of data array. For example, if @var{my}=0 then it will be change to @var{my}=nx*ny*nz/@var{mx} and @var{mz} will be 1.
@end deffn

@cindex extend
@anchor{extend}
@deffn {MGL command} extend dat @code{n1 [n2=0]}
Increase the dimensions of the data by inserting new (|@var{n1}|+1)-th slices after (for @var{n1}>0) or before (for @var{n1}<0) of existed one. It is possible to insert 2 dimensions simultaneously for 1d data by using parameter @var{n2}. Data to new slices is copy from existed one. For example, for @var{n1}>0 new array will be 
@iftex
@math{a_{ij}^{new} = a_i^{old}} where j=0...@var{n1}. Correspondingly, for @var{n1}<0 new array will be @math{a_{ij}^{new} = a_j^{old}} where i=0...|@var{n1}|.
@end iftex
@ifnottex
a_ij^new = a_i^old where j=0...@var{n1}. Correspondingly, for @var{n1}<0 new array will be a_ij^new = a_j^old where i=0...|@var{n1}|.
@end ifnottex
@end deffn

@cindex transpose
@anchor{transpose}
@deffn {MGL command} transpose dat ['dim'='yxz']
Transposes (shift order of) dimensions of the data. New order of dimensions is specified int string @var{dim}. This command may be useful also for the reading of one-dimensional data.
@end deffn

@cindex squeeze
@anchor{squeeze}
@deffn {MGL command} squeeze dat @code{rx [ry=1 rz=1 sm=off]}
Reduces the data size by excluding data elements which indexes are not divisible by @var{rx}, @var{ry}, @var{rz} correspondingly. Parameter @var{sm} set to use smoothing
@iftex
(i.e. @math{a_{out}[i]=\sum_{j=i}^{i+r}a[j]/r}) or not (i.e. @math{a_{out}[i]=a[j*r]}).
@end iftex
@ifnottex
(i.e. out[i]=\sum_@{j=i@}^@{i+r@} a[j]/r) or not (i.e. out[i]=a[j*r]).
@end ifnottex
@end deffn

@cindex crop
@anchor{crop}
@deffn {MGL command} crop dat @code{n1 n2} 'dir'
Cuts off edges of the data @var{i}<@var{n1} and @var{i}>@var{n2} if @var{n2}>0 or @var{i}>@code{n[xyz]}-@var{n2} if @var{n2}<=0 along direction @var{dir}.
@end deffn

@cindex delete
@anchor{delete}
@deffn {MGL command} delete dat
Deletes variable @var{dat} and makes its memory free. Can be useful for huge data arrays.
@end deffn

@deffn {MGL command} delete dat 'dir' @code{[pos=off num=0]}
Delete @var{num} slices along @var{dir}-direction at position @var{pos}.
@end deffn

@cindex insert
@anchor{insert}
@deffn {MGL command} insert dat 'dir' @code{[pos=off num=0]}
Insert @var{num} slices along @var{dir}-direction at position @var{pos}.
@end deffn

@c ------------------------------------------------------------------
@node File I/O @MGL{}, Make another data @MGL{}, Rearrange data @MGL{}, MGL interface
@section File I/O @MGL{}

@cindex read
@anchor{read}
@deffn {MGL command} read dat 'fname'
Reads data from tab-separated text file with auto determining sizes of the data.
@end deffn

@deffn {MGL command} read dat 'fname' @code{mx [my=1 mz=1]}
Reads data from text file with specified data sizes. This command does nothing if one of parameters @var{mx}, @var{my} or @var{mz} is zero or negative.
@end deffn

@cindex readmat
@anchor{readmat}
@deffn {MGL command} readmat dat 'fname' [@code{dim=2}]
Read data from text file with size specified at beginning of the file by first @var{dim} numbers. At this, variable @var{dim} set data dimensions.
@end deffn

@cindex readall
@anchor{readall}
@deffn {MGL command} readall dat 'templ' @code{v1 v2 [dv=1 slice=off]}
Join data arrays from several text files. The file names are determined by function call @code{sprintf(fname,templ,val);}, where @var{val} changes from @var{v1} to @var{v2} with step @var{dv}. The data load one-by-one in the same slice if @var{slice}=@code{off} or as slice-by-slice if @var{slice}=@code{on}.
@end deffn

@deffn {MGL command} readall dat 'templ' @code{[slice=off]}
Join data arrays from several text files which filenames satisfied the template @var{templ} (for example, @var{templ}=@code{"t_*.dat"}). The data load one-by-one in the same slice if @var{slice}=@code{off} or as slice-by-slice if @var{slice}=@code{on}.
@end deffn

@cindex save
@anchor{save}
@deffn {MGL command} save dat 'fname'
Saves the whole data array to tab-separated text file.
@end deffn

@cindex readhdf
@anchor{readhdf}
@deffn {MGL command} readhdf dat 'fname' 'dname'
Reads data array named @var{dname} from HDF5 or HDF4 file @var{fname}.
@end deffn

@cindex savehdf
@anchor{savehdf}
@deffn {MGL command} savehdf dat 'fname' 'dname'
Saves data array named @var{dname} from HDF5 or HDF4 file @var{fname}.
@end deffn

@cindex import
@anchor{import}
@deffn {MGL command} import dat 'fname' 'sch' [@code{v1=0 v2=1}]
Reads data from bitmap file. The RGB values of bitmap pixels are transformed to float values in range [@var{v1}, @var{v2}] using color scheme @var{sch} (@pxref{Color scheme}).
@end deffn

@cindex export
@anchor{export}
@deffn {MGL command} export dat 'fname' 'sch' [@code{v1=0 v2=0}]
Saves data matrix to bitmap file. The data values are transformed from range [@var{v1}, @var{v2}] to RGB pixels of bitmap using color scheme @var{sch} (@pxref{Color scheme}). If @var{v1}>=@var{v2} then the values of @var{v1}, @var{v2} are automatically determined as minimal and maximal value of the data array.
@end deffn

@c ------------------------------------------------------------------
@node Make another data @MGL{}, Commands on direction @MGL{}, File I/O @MGL{}, MGL interface
@section Make another data @MGL{}

@cindex combine
@anchor{combine}
@deffn {MGL command} combine res adat bdat
Returns direct multiplication of arrays (like, res[i,j] = adat[i]*bdat[j] and so on).
@end deffn

@cindex evaluate
@anchor{evaluate}
@deffn {MGL command} evaluate res dat idat [@code{norm=on}]
@deffnx {MGL command} evaluate res dat idat jdat [@code{norm=on}]
@deffnx {MGL command} evaluate res dat idat jdat kdat [@code{norm=on}]
Get array which values is result of interpolation of original array for coordinates from other arrays. All dimensions must be the same for data @var{idat}, @var{jdat}, @var{kdat}. Coordinates from @var{idat}, @var{jdat}, @var{kdat} are supposed to be normalized in range [0,1] (if @var{norm}=@code{true}) or in range [0,nx], [0,ny], [0,nz] correspondingly.
@end deffn

@cindex hist
@anchor{hist}
@deffn {MGL command} hist res dat @code{num v1 v2 [nsub=0]}
@deffnx {MGL command} hist res dat wdat @code{num v1 v2 [nsub=0]}
Creates @var{num}-th points distribution @var{res} of the data values of @var{dat} in range [@var{v1}, @var{v2}]. Array @var{wdat} specifies weights of the data elements (all weight is 1 if @var{wdat} is not specified). Parameter @var{nsub} define the number of additional interpolated points (for smoothness of histogram).
@end deffn

@deffn {MGL command} hist res xdat adat
@deffnx {MGL command} hist res xdat ydat adat
@deffnx {MGL command} hist res xdat ydat zdat adat
Creates distribution @var{res} of the data values of @var{adat} in axis range [Min, Max]. Array @var{adat} look like weights of the data points.
@end deffn


@cindex momentum
@anchor{momentum}
@deffn {MGL command} momentum res dat 'how' ['dir'='z']
Get momentum (1D-array) of the data along direction @var{dir}. String @var{how} contain kind of momentum. The momentum is defined like as
@iftex
@math{res_k = \sum_{ij} how(x_i,y_j,z_k) a_{ij}/\sum_{ij} a_{ij}}
@end iftex
@ifnottex
res_k = \sum_ij how(x_i,y_j,z_k) a_ij/ \sum_ij a_ij
@end ifnottex
if @var{var}=@samp{z} and so on. Coordinates @samp{x}, @samp{y}, @samp{z} are data indexes normalized in range [0,1].
@end deffn

@cindex sum
@anchor{sum}
@deffn {MGL command} sum res dat 'dir'
Gets array which is the result of summation in given direction or direction(s).
@end deffn
@cindex max
@anchor{max}
@deffn {MGL command} max res dat 'dir'
Gets array which is the maximal data values in given direction or direction(s).
@end deffn
@cindex min
@anchor{min}
@deffn {MGL command} min res dat 'dir'
Gets array which is the minimal data values in given direction or direction(s).
@end deffn

@cindex resize
@anchor{resize}
@deffn {MGL command} resize res dat @code{mx [my=1 mz=1]}
Makes array @var{res} of sizes @var{mx}, @var{my}, @var{mz} with interpolated data of array @var{dat}. 
@end deffn

@cindex subdata
@anchor{subdata}
@deffn {MGL command} subdata res dat @code{xx [yy=: zz=:]}
Extracts sub-array data @var{res} from the original data @var{dat} array keeping fixed positive index. For example @code{subdata a b : 2} extracts 3d row (indexes are zero based), @code{subdata a b 4 :} extracts 5th column, @code{subdata a b : : 3} extracts 4th slice and so on. Note that symbol @samp{:} is defined @samp{:}=@code{-1} in MGL.
@end deffn

@cindex trace
@anchor{trace}
@deffn {MGL command} trace res dat
Gets array of diagonal elements dat[i,i] (for 2D case) or dat[i,i,i] (for 3D case) where i=0...nx-1. Function return copy of itself for 1D case. Data array must have dimensions ny,nz >= nx or ny,nz = 1.
@end deffn

@cindex transform
@anchor{transform}
@deffn {MGL command} transform dat 'type' real imag
Do integral transformation of complex data @var{real}, @var{imag} on specified direction. Now only Fourier transformation is supported. The order of transformations is specified in string @var{type}: first character for x-dimension, second one for y-dimension, third one for z-dimension. The possible character are: @samp{f} is forward Fourier transformation, @samp{i} is inverse Fourier transformation, @samp{s} is Sine transform, @samp{c} is Cosine transform, @samp{h} is Hankel transform, @samp{n} or @samp{ } is no transformation.
@end deffn

@cindex transforma
@anchor{transforma}
@deffn {MGL command} transforma dat 'type' ampl phase
Do integral transformation of complex data @var{ampl}, @var{phase} on specified direction. Now only Fourier transformation is supported. The order of transformations is specified in string @var{type}: first character for x-dimension, second one for y-dimension, third one for z-dimension. The possible character are: @samp{f} is forward Fourier transformation, @samp{i} is inverse Fourier transformation, @samp{s} is Sine transform, @samp{c} is Cosine transform, @samp{h} is Hankel transform, @samp{n} or @samp{ } is no transformation.
@end deffn

@cindex stfad
@anchor{stfad}
@deffn {MGL command} stfad res real imag @code{dn} ['dir'='x']
Short time Fourier analysis for real and imaginary parts. Output  is amplitude of partial Fourier of length @var{dn}. For example if @var{dir}=@samp{x}, result will have size @{int(nx/dn), dn, ny@} and it will contain @math{res[i,j,k]=|\sum_d^dn exp(I*j*d)*(real[i*dn+d,k]+I*imag[i*dn+d,k])|/dn}.
@end deffn

@cindex pde
@anchor{pde}
@deffn {MGL command} pde res 'ham' ini_re ini_im [@code{dz=0.1 k0=100}]
Solves equation du/dz = i*k0*@var{ham}(p,q,x,y,z,|u|)[u], where p=-i/k0*d/dx, q=-i/k0*d/dy are pseudo-differential operators. Parameters @var{ini_re}, @var{ini_im} specify real and imaginary part of initial field distribution. Coordinates of the equation (and the solution) are supposed to be in the bounding box. Note, that really this ranges are increased by factor 3/2 for purpose of reducing reflection from boundaries. Parameter @var{dz} set the step along evolutionary coordinate z. At this moment, simplified form of function @var{ham} is supported -- all ``mixed'' terms (like @samp{x*p}->x*d/dx) are excluded. For example, in 2D case this function is effectively @math{ham = f(p,z) + g(x,z,u)}. However commutable combinations (like @samp{x*q}->x*d/dy) are allowed. Here variable @samp{u} is used for field amplitude |u|. This allow one solve nonlinear problems -- for example, for non-linear Shrodinger equation you may set @code{ham='p^2+q^2-u^2'}. You may specify imaginary part for wave absorption, like @code{ham = 'p^2+i*x*(x>0)'}, but only if dependence on variable @samp{i} is linear (i.e. @math{ham = hre+i*him}).
@end deffn

@cindex ray
@anchor{ray}
@deffn {MGL command} ray res 'ham' @code{x0 y0 z0 p0 q0 v0 [dt=0.1 tmax=10]}
Solves GO ray equation like d@emph{r}/dt = d @var{ham}/d@emph{p}, d@emph{p}/dt = -d @var{ham}/d@emph{r}. This is Hamiltonian equations for particle trajectory in 3D case. Here @var{ham} is Hamiltonian which may depend on coordiantes @samp{x}, @samp{y}, @samp{z}, momentums @samp{p}=px, @samp{q}=py, @samp{v}=pz and time @samp{t}: @math{ham = H(x,y,z,p,q,v,t)}. The starting point (at @code{t=0}) is defined by variables @{@var{x0}, @var{y0}, @var{z0}, @var{p0}, @var{q0}, @var{v0}@}. Parameters @var{dt} and @var{tmax} specify the integration step and maximal time for ray tracing. Result is array of @{x,y,z,p,q,v,t@} with dimensions @{7 * int(@var{tmax}/@var{dt}+1) @}.
@end deffn

@cindex qo2d
@anchor{qo2d}
@deffn {MGL command} qo2d res 'ham' ini_re ini_im ray [@code{r=1 k0=100} xx=0 yy=0]
Solves equation du/dt = i*k0*@var{ham}(p,q,x,y,|u|)[u], where p=-i/k0*d/dx, q=-i/k0*d/dy are pseudo-differential operators (see @code{mglPDE()} for details). Parameters @var{ini_re}, @var{ini_im} specify real and imaginary part of initial field distribution. Parameters @var{ray} set the reference ray, i.e. the ray around which the accompanied coordinate system will be maked. You may use, for example, the array created by @code{mglRay()} function. Note, that the reference ray @strong{must be} smooth enough to make accompanied coodrinates unambiguity. Otherwise errors in the solution may appear. If @var{xx} and @var{yy} are non-zero then Cartesian coordinates for each point will be written into them. @sref{Beam tracing sample} 
@end deffn

@cindex jacobian
@anchor{jacobian}
@deffn {MGL command} jacobian res xdat ydat [zdat=0]
Computates the Jacobian for transformation @{i,j,k@} to @{@var{xdat},@var{ydat},@var{zdat}@} where initial coordinates  @{i,j,k@} are data indexes normalized in range [0,1]. The Jacobian is determined by formula det||@math{dr_\alpha/d\xi_\beta}|| where @math{r}=@{@var{xdat},@var{ydat},@var{zdat}@} and @math{\  xi}=@{i,j,k@}. All dimensions must be the same for all data arrays. Data must be 3D if all 3 arrays @{@var{xdat},@var{ydat},@var{zdat}@} are specified or 2D if only 2 arrays @{@var{xdat},@var{ydat}@} are specified.
@end deffn



@c ------------------------------------------------------------------
@node Commands on direction @MGL{}, Operators @MGL{}, Make another data @MGL{}, MGL interface
@section Commands on direction @MGL{}

These commands change the data in some direction like differentiations, integrations and so on. The direction in which the change will applied is specified by the string parameter, which may contain @samp{x}, @samp{y} or @samp{z} characters for 1-st, 2-nd and 3-d dimension correspondingly.

@cindex cumsum
@anchor{cumsum}
@deffn {MGL command} cumsum dat 'dir'
Cumulative summation of the data in given direction or directions.
@end deffn
@cindex integrate
@anchor{integrate}
@deffn {MGL command} integrate dat 'dir'
Integrates (like cumulative summation) the data in given direction or directions.
@end deffn
@cindex diff
@anchor{diff}
@deffn {MGL command} diff dat 'dir'
Differentiates the data in given direction or directions.
@end deffn
@deffn {MGL command} diff dat xdat ydat [zdat=0]
Differentiates the data @var{dat} specified parametrically in direction @var{xdat} with @var{ydat}, @var{zdat}=constant. Parameter @var{zdat} can be omitted that correspond to 2D case. Parametrical differentiation uses the formula (for 2D case): @math{da/dx = (a_j*y_i-a_i*y_j)/(x_j*y_i-x_i*y_j)} where @math{a_i=da/di, a_j=da/dj} denotes usual differentiation along 1st and 2nd dimensions. The similar formula is used for 3D case. Note, that you may change the order of arguments -- for example, if you have 2D data a(i,j) which depend on coordinates @{x(i,j), y(i,j)@} then usual derivative along @samp{x} will be @code{diff a x y} and usual derivative along @samp{y} will be @code{diff a y x}.
@end deffn

@cindex diff2
@anchor{diff2}
@deffn {MGL command} diff2 dat 'dir'
Double-differentiates (like Laplace operator) the data in given direction.
@end deffn

@cindex sinfft
@anchor{sinfft}
@deffn {MGL command} sinfft dat 'dir'
Do Sine transform of the data in given direction or directions. The Sine transform is @math{\sum a_i \sin(k i)}.
@end deffn
@cindex cosfft
@anchor{cosfft}
@deffn {MGL command} cosfft dat 'dir'
Do Cosine transform of the data in given direction or directions. The Cosine transform is @math{\sum a_i \cos(k i)}.
@end deffn
@cindex hankel
@anchor{hankel}
@deffn {MGL command} hankel dat 'dir'
Do Hankel transform of the data in given direction or directions. The Hankel transform is @math{\sum a_i J_0(k i)}.
@end deffn


@cindex swap
@anchor{swap}
@deffn {MGL command} swap dat 'dir'
Swaps the left and right part of the data in given direction (useful for Fourier spectrum).
@end deffn
@cindex roll
@anchor{roll}
@deffn {MGL command} roll dat 'dir' num
Rolls the data along direction 'dir'. Resulting array will be out[i] = ini[(i+num)%nx] if @code{dir='x'}.
@end deffn

@cindex mirror
@anchor{mirror}
@deffn {MGL command} mirror dat 'dir'
Mirror the left-to-right part of the data in given direction. Looks like change the value index @var{i}->@var{n-i}.
@end deffn

@cindex sew
@anchor{sew}
@deffn {MGL command} sew dat ['dir'='xyz' @code{da=2*pi}]
Remove value steps (like phase jumps after inverse trigonometric commands) with period @var{da} in given direction.
@end deffn
@cindex smooth
@anchor{smooth}
@deffn {MGL command} smooth data @code{type} ['dir'='xyz']
Smooths the data on specified direction or directions by method @var{Type}. Now 4 methods are supported: @samp{0} does nothing, @samp{1} linear averaging by 3 points, @samp{2} linear averaging by 5 points, @samp{3} quadratic averaging by 5 points.
@end deffn

@cindex envelop
@anchor{envelop}
@deffn {MGL command} envelop dat ['dir'='x']
Find envelop for data values along direction @var{dir}. Only one direction can be specified at once.
@end deffn

@cindex normsl
@anchor{normsl}
@deffn {MGL command} normsl dat @code{v1 v2} ['dir'='z' @code{keep=on sym=off}]
Normalizes data slice-by-slice along direction @var{dir} the data in slices to range [@var{v1},@var{v2}]. If flag @var{sym}=@code{on} then symmetrical interval [-max(|v1|,|v2|), max(|v1|,|v2|)] is used. If @var{keep} is set then maximal value of k-th slice will be limited by 
@iftex
@math{\sqrt{\sum a_{ij}(k)/\sum a_{ij}(0)}}.
@end iftex
@ifnottex
@math{\sqrt@{\sum a_ij(k)/\sum a_ij(0)@}}.
@end ifnottex
@end deffn

@cindex norm
@anchor{norm}
@deffn {MGL command} norm dat @code{v1 v2 [sym=off dim=0]}
Normalizes the data to range [@var{v1},@var{v2}]. If flag @var{sym}=@code{on} then symmetrical interval [-max(|v1|,|v2|), max(|v1|,|v2|)] is used. Modification will be applied only for slices >=@var{dim}.
@end deffn

@c ------------------------------------------------------------------
@node Operators @MGL{}, Program flow @MGL{}, Commands on direction @MGL{}, MGL interface
@section Operators @MGL{}

@cindex multo
@anchor{multo}
@deffn {MGL command} multo dat dat2
Multiplies the data by the other one for each element.
@end deffn
@deffn {MGL command} multo dat @code{val}
Multiplies each element by the number.
@end deffn

@cindex divto
@anchor{divto}
@deffn {MGL command} divto dat dat2
Divides the data by the other one for each element.
@end deffn
@deffn {MGL command} divto dat @code{val}
Divides each element by the number.
@end deffn

@cindex addto
@anchor{addto}
@deffn {MGL command} addto dat dat2
Adds the other data.
@end deffn
@deffn {MGL command} addto dat @code{val}
Adds the number to each element.
@end deffn

@cindex subto
@anchor{subto}
@deffn {MGL command} subto dat dat2
Subtracts the other data.
@end deffn
@deffn {MGL command} subto dat @code{val}
Subtracts the number to each element.
@end deffn

@c ------------------------------------------------------------------
@node Program flow @MGL{}, Command options @MGL{}, Operators @MGL{}, MGL interface
@section Program flow @MGL{}

These commands control program flow, like, conditions, cycles, define script arguments and so on.

@cindex chdir
@anchor{chdir}
@deffn {MGL command} chdir 'path'
Changes the current directory to @var{path}.
@end deffn

@cindex define
@anchor{define}
@deffn {MGL command} define $N smth
Sets @var{N}-th script argument to @var{smth}. Note, that @var{smth} is used as is (with @samp{'} symbols if present).
@end deffn
@deffn {MGL command} define name smth
Create scalar variable @code{name} which have the numeric value of @code{smth}. Later you can use this variable as usual number.
@end deffn
@cindex defchr
@anchor{defchr}
@deffn {MGL command} defchr $N smth
Sets @var{N}-th script argument to character with value evaluated from @var{smth}. Note, that @var{smth} is used as is (with @samp{'} symbols if present).
@end deffn
@cindex defnum
@anchor{defnum}
@deffn {MGL command} defnum $N smth
Sets @var{N}-th script argument to number with value evaluated from @var{smth}. Note, that @var{smth} is used as is (with @samp{'} symbols if present).
@end deffn
@cindex defpal
@anchor{defpal}
@deffn {MGL command} defpal $N smth
Sets @var{N}-th script argument to palette character at position evaluated from @var{smth}. Note, that @var{smth} is used as is (with @samp{'} symbols if present).
@end deffn

@cindex call
@anchor{call}
@deffn {MGL command} call 'fname' [ARG1 ARG2 ... ARG9]
Executes function @var{fname} (or script if function is not found). Optional arguments will be passed to functions.
@end deffn
@cindex func
@anchor{func}
@deffn {MGL command} func 'fname' [narg=0]
Define the function @var{fname} and number of required arguments. The arguments will be placed in script parameters $1, $2, ... $9. Note, you should stop script execution before function definition(s) by command @code{stop}.
@end deffn
@cindex return
@anchor{return}
@deffn {MGL command} return
Return from the function.
@end deffn


@cindex if
@anchor{if}
@deffn {MGL command} if dat 'cond'
Starts block which will be executed if @var{dat} satisfy to @var{cond}.
@end deffn
@deffn {MGL command} if @code{val}
Starts block which will be executed if @code{val} is nonzero.
@end deffn
@cindex elseif
@anchor{elseif}
@deffn {MGL command} elseif dat 'cond'
Starts block which will be executed if previous @code{if} or @code{elseif} is false and @var{dat} satisfy to @var{cond}.
@end deffn
@deffn {MGL command} elseif @code{val}
Starts block which will be executed if previous @code{if} or @code{elseif} is false and @code{val} is nonzero.
@end deffn
@cindex else
@anchor{else}
@deffn {MGL command} else
Starts block which will be executed if previous @code{if} or @code{elseif} is false.
@end deffn
@cindex endif
@anchor{endif}
@deffn {MGL command} endif
Finishes @code{if/elseif/else} block.
@end deffn

@cindex for
@anchor{for}
@deffn {MGL command} for $N @code{v1 v2 [dv=1]}
Starts cycle with @var{N}-th argument changing from @var{v1} to @var{v2} with the step @var{dv}.
@end deffn
@deffn {MGL command} for $N dat
Starts cycle with @var{N}-th argument changing for @var{dat} values.
@end deffn
@cindex next
@anchor{next}
@deffn {MGL command} next
Finishes @code{for} cycle.
@end deffn

@cindex once
@anchor{once}
@deffn {MGL command} once @code{val}
The code between once on and once off will be executed only once. Useful for large data manipulation in programs like UDAV.
@end deffn
@cindex stop
@anchor{stop}
@deffn {MGL command} stop
Terminate execution.
@end deffn

@c ------------------------------------------------------------------
@node  Command options @MGL{}, Suffixes, Program flow @MGL{}, MGL interface
@section Command options @MGL{}

Command options allow the easy setup of the plot by changing of global settings only for this plot. Options are specified at the end of string. Each option is separated from the previous text by symbol @samp{;}. Options work so that them remember the current settings, change settings as it being set in the option, execute command and return the original settings back. So, the options usage for data handling commands or for graphics setup commands is useless.

The most useful options are @code{xrange, yrange, zrange}. They sets the boundaries for data change. This boundaries are used for automatically filled variables. So, these options allow one to change the position of some plots. For example, in command @code{plot y; xrange 0.1 0.9} the x coordinate will be equidistantly distributed in range 0.1 ... 0.9.

The full list of options are:
@cindex alpha
@deffn {MGL command} alpha @code{val}
Sets alpha value (transparency) of the plot. The value should be in range [0, 1].
@end deffn
@cindex alphadef
@deffn {MGL command} alphadef @code{val}
Sets alpha value (transparency) of the plot. The value should be in range [0, 1].
@end deffn
@cindex ambient
@deffn {MGL command} ambient @code{val}
Sets brightness of ambient light for the plot. The value should be in range [0, 1].
@end deffn
@cindex crange
@deffn {MGL command} crange @code{val1 val2}
Sets boundaries of color change for the plot.
@end deffn
@cindex xrange
@deffn {MGL command} xrange @code{val1 val2}
Sets boundaries of x coordinate change for the plot.
@end deffn
@cindex yrange
@deffn {MGL command} yrange @code{val1 val2}
Sets boundaries of y coordinate change for the plot.
@end deffn
@cindex zrange
@deffn {MGL command} zrange @code{val1 val2}
Sets boundaries of z coordinate change for the plot.
@end deffn
@cindex cut
@deffn {MGL command} cut @code{val}
Sets whether to cut or to project the plot points lying outside the bounding box.
@end deffn
@cindex fontsize
@deffn {MGL command} fontsize @code{val}
Sets the size of text.
@end deffn
@cindex marksize
@deffn {MGL command} marksize @code{val}
Sets the size of marks.
@end deffn
@cindex meshnum
@deffn {MGL command} meshnum @code{val}
Work like @code{meshnum} command.
@end deffn
@cindex legend
@deffn {MGL command} legend 'txt'
Adds string 'txt' to internal legend accumulator. The style of described line and mark is taken from arguments of the plot command. The maximal number of entries is 100.
@end deffn

@c ------------------------------------------------------------------
@node  Suffixes, Utilities, Command options @MGL{}, MGL interface
@section Suffixes for variable

Suffixes can get some numerical value (like its size, maximal or minimal value, the sum of elements and so on) of the data array in variable and use it later as usual number in command arguments. The suffixes start from point @samp{.} right after (without spaces) variable name or its sub-array. For example, @code{a.nx} give the x-size of data a, @code{b(1).max} give maximal value of second row of variable b, @code{c(:,0).sum} give sum of element in first column of c and so on.

The full list of suffixes are:
@table @strong
@item nx, ny, nz
Give the data size in x-, y-, z-direction correspondingly.
@item max
Give maximal value of the data.
@item min
Give minimal value of the data.
@item mx, my, mz
Give x-, y-, z-position of data maximum.
@item ax, ay, az, aa
Give x-, y-, z-position of data mass center or average data value.
@item wx, wy, wz, wa
Give width in x-, y-, z-direction or data dispersion value.
@item sx, sy, sz, sa
Give skewness in x-, y-, z-direction or data skewness value.
@item kx, ky, kz, ka
Give kurtosis in x-, y-, z-direction or data kurtosis value.
@item sum
Give sum of data values.
@item a
Give first value of data array.
@item fst
Give first nonzero value of data array.
@item lst
Give last nonzero value of data array.
@end table

@c ------------------------------------------------------------------
@node  Utilities, , Suffixes, MGL interface
@section Utilities for parsing MGL

MathGL library provides several tools for parsing MGL scripts. There is tools saving it to bitmap (@code{mgl2png}, @code{mgl2gif}) or vectorial (@code{mgl2eps}, @code{mgl2svg}) images. Tool @code{mglview} show MGL script and allow to rotate and setup the image. Also you can translate MGL script to C++ file by help of @code{mgl2cpp} tool.

All of this tools have similar set of arguments. First argument is name of script file, next argument is optional output file name, last arguments are options. There are options for setting script parameters (it is @code{$0, $1, ... $9}) and locale settings. The script parameters have format @samp{-Nval}. Here N=0,1...9 is parameter ID and val is its value. For example, option @samp{-1test} set to substitute @samp{test} instead of @code{$1} in the script. Option -Lval set locale to val. For example, @samp{-Lutf8} will set UTF-8 locale for script.

Additionally you can create animated GIF file or a set of JPEG files with names @samp{frameNNNN.jpg} (here @samp{NNNN} is frame index). You should use @code{mgl2gif} tool and specify the values of @code{$0} parameter for making animation. Values of the parameter @code{$0} can be specified inside the script by comment @code{##a val} for each value @code{val} (one comment for one value) or by option(s) @samp{-Aval}. Tool @code{mgl2gif} will execute script several times (once for each specified value of @code{$0}) and save result in animated GIF file. For saving each frame in JPEG just add command @code{write ''} at the end of the script.


